/****************************************************************************/
/*D
   
NP - numerical procedures

DESCRIPTION:

All num procs start with the base class, containing the Init, Display amd
Execute functions.

struct np_base {

    /* data */
    ENVVAR v;							/* is an environment variable		*/
    MULTIGRID *mg;						/* associated multigrid				*/
    INT status;							/* has a status, NO type and size...*/

    /* functions */
    INT	(*Init) (struct np_base *, INT, char **); /* initializing routine   */
    INT (*Display) (struct np_base *);                   /* Display routine */
    INT (*Execute) (struct np_base *, INT, char **);     /* Execute routine */
};
typedef struct np_base NP_BASE;

The derived classes are defined in the headers
iter.h, ls.h, nls.h, assemble.h, error.h, transfer.h, e. g.

typedef struct {
	INT error_code;                     /* error code                       */
	INT converged;                      /* error code                       */
	VEC_SCALAR first_defect;            /* first defect                     */
	VEC_SCALAR last_defect;             /* last defect                      */
	INT number_of_linear_iterations;    /* number of iterations             */
} LRESULT;

struct np_linear_solver {
	NP_BASE base;                        /* inherits base class             */

	/* data (optinal, necessary for calling the generic execute routine)    */
    VECDATA_DESC *x;                     /* solution                        */
    VECDATA_DESC *b;                     /* defect                          */
    MATDATA_DESC *A;                     /* matrix                          */
	VEC_SCALAR reduction;                /* reduction factor                */
	VEC_SCALAR abslimit;                 /* absolute limit for the defect   */
	
	/* functions */
	INT (*PreProcess)  
	     (struct np_linear_solver *,     /* pointer to (derived) object     */
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *,                         /* baselevel used by the solver    */ 
		  INT *);                        /* result                          */ 
    INT (*Defect)                        /* b := b - Ax                     */
	     (struct np_linear_solver *,     /* pointer to (derived) object     */ 
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *);                        /* result                          */ 
    INT (*Residuum)                      /* computes norm of the defect     */
	     (struct np_linear_solver *,     /* pointer to (derived) object     */ 
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  LRESULT *);                    /* result structure                */ 
    INT (*Solver)                        /* b := b - Ax                     */
	     (struct np_linear_solver *,     /* pointer to (derived) object     */ 
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  VEC_SCALAR,                    /* reduction factor                */
		  VEC_SCALAR,                    /* absolute limit for the defect   */
		  LRESULT *);                    /* result structure                */ 
	INT (*PostProcess) 
	     (struct np_linear_solver *,     /* pointer to (derived) object     */ 
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *);                        /* result                          */ 
};
typedef struct np_linear_solver NP_LINEAR_SOLVER;

struct np_assemble {

	NP_BASE base;                        /* inherits base class             */

	/* data (optinal, necessary for calling the generic execute routine)    */
    VECDATA_DESC *x;                     /* solution                        */
    VECDATA_DESC *c;                     /* correction                      */
    VECDATA_DESC *b;                     /* defect                          */
    MATDATA_DESC *A;                     /* matrix                          */
	
	/* functions */
	INT (*PreProcess)  
	     (struct np_assemble *,          /* pointer to (derived) object     */
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *);                        /* result                          */ 
    INT (*Assemble)        
	     (struct np_assemble *,          /* pointer to (derived) object     */
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *);                        /* result                          */ 
    INT (*AssembleSolution)        
	     (struct np_assemble *,          /* pointer to (derived) object     */
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  INT *);                        /* result                          */ 
    INT (*AssembleDefect)        
	     (struct np_assemble *,          /* pointer to (derived) object     */
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *);                        /* result                          */ 
    INT (*AssembleMatrix)        
	     (struct np_assemble *,          /* pointer to (derived) object     */
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,			     /* current solution	(initial)	*/
		  VECDATA_DESC *,			     /* defect for current solution     */
		  VECDATA_DESC *,			     /* correction to be computed  		*/
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *);                        /* result                          */ 
	INT (*PostProcess) 
	     (struct np_assemble *,          /* pointer to (derived) object     */
		  INT,                           /* level                           */ 
		  VECDATA_DESC *,                /* solution vector                 */ 
		  VECDATA_DESC *,                /* defect vector                   */ 
		  MATDATA_DESC *,                /* matrix                          */ 
		  INT *);                        /* result                          */ 
};
typedef struct np_assemble NP_ASSEMBLE;


Here, the interface is defined which can be used by the nonlinear solver,
i. e. the nonlinear solver can use only the funtions of the interface
in the derived class.

For the realisation, the user defines a final class, e. g.

typedef struct
{
	NP_LINEAR_SOLVER ls;

	NP_ITER *Iter;
	INT maxiter;
	INT baselevel;
	INT display;
	VECDATA_DESC *c;

} NP_LS;

This struct is not public and can be used in ls.c only.
For the initialization of a linear solver an iteration is necessary
which can be get by

	npls->Iter = (NP_ITER *)GetNumProcByName(mg,name,ITER_CLASS_NAME);

Here, the class name checks if the num proc 'name' is of the correct
class. 

Every final class must be constructed by a constructor.

typedef INT (*ConstructorProcPtr)   (NP_BASE *);

typedef struct
{
	ENVVAR v;						/* class name							*/
	INT size;                       /* size of the object                   */
	ConstructorProcPtr Construct;	/* construct one object of this class 	*/
} NP_CONSTRUCTOR;

For example

static INT LSConstruct (NP_BASE *theNP)
{
    NP_LINEAR_SOLVER *np;
	
	theNP->Init = LinearSolverInit;
	theNP->Display = LinearSolverDisplay;
	theNP->Execute = NPLinearSolverExecute;

	np = (NP_LINEAR_SOLVER *) theNP;
	np->PreProcess = LinearSolverPreProcess;
	np->Defect = LinearDefect;
	np->Residuum = LinearResiduum;
	np->Solver = LinearSolver;
	np->PostProcess = LinearSolverPostProcess;

    return(0);
}

The final class must be constructed by

	CreateClass (LINEAR_SOLVER_CLASS_NAME ".ls",sizeof(NP_LS),LSConstruct);

Then, the numproc has the name 'linear_solver.ls', starting with the
name of the derived class and ending with the final class name.

D*/
/****************************************************************************/
