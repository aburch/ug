/****************************************************************************/
/*                                                                          */
/* File:      ifcmd.ct                                                      */
/*                                                                          */
/* Purpose:   template routines for interface functions                     */
/*                                                                          */
/* Author:    Klaus Birken                                                  */
/*            Institut fuer Computeranwendungen III                         */
/*            Universitaet Stuttgart                                        */
/*            Pfaffenwaldring 27                                            */
/*            70569 Stuttgart                                               */
/*            internet: birken@ica3.uni-stuttgart.de                        */
/*                                                                          */
/* History:   970110 kb  begin                                              */
/*                                                                          */
/* Remarks:                                                                 */
/*                                                                          */
/****************************************************************************/



/****************************************************************************/
/*                                                                          */
/* derived macros                                                           */
/*                                                                          */
/****************************************************************************/

#define _CAT(a,b)   a ## b
#define CAT(a,b)    _CAT(a,b)


#ifdef IF_WITH_ATTR
#define PART ifAttr
#else
#define PART ifHead
#endif


#ifdef IF_WITH_XARGS
	#define EXEC_LOOP(a,b,c)     IFExecLoopCplX(a,b,c)
	#define COMM_LOOP(a,b,c,d,e) IFCommLoopCplX(a,b,c,d,e)
	#define D_AB(p)              (p->cplAB)
	#define D_BA(p)              (p->cplBA)
	#define D_ABA(p)             (p->cplABA)
#else
	#define EXEC_LOOP(a,b,c)     IFExecLoopObj(a,b,c)
	#ifdef CPP_FRONTEND
	  #ifdef IF_CBR
	    #define COMM_LOOP(a,b,c,d,e) \
			CAT(IFCommLoopObj,a) (GatherScatter,b,c,d,e)
	  #else
	    #define COMM_LOOP(a,b,c,d,e) \
			CAT(IFCommLoopObj,a) (*GatherScatter,b,c,d,e)
	  #endif
	#else
	#define COMM_LOOP(a,b,c,d,e) IFCommLoopObj(a,b,c,d,e)
	#endif
	#define D_AB(p)              (p->objAB)
	#define D_BA(p)              (p->objBA)
	#define D_ABA(p)             (p->objABA)
#endif


#ifdef CPP_FRONTEND
#define IF_FUNCNAME   CAT(DDD_Interface::,IF_NAME)
#else
#define IF_FUNCNAME   CAT(DDD_IF,IF_NAME)
#endif

#ifdef CPP_FRONTEND
	#ifdef IF_CBR
		#define REFDECL &
	#else
		#define REFDECL *
	#endif
#endif


/****************************************************************************/
/*                                                                          */
/* auxiliary macros                                                         */
/*                                                                          */
/****************************************************************************/

#ifndef IF_AUX_MACROS
#define IF_AUX_MACROS

#define FIND_ATTR \
	ifAttr = ifHead->ifAttr;                          \
	while ((ifAttr!=NULL) && (ifAttr->attr!=attr))    \
	{                                                 \
		ifAttr = ifAttr->next;                        \
	}                                                 \
	if (ifAttr==NULL) continue;


#define CONCAT(txt,fct)    txt FUNCNAME_STR(fct)
#define FUNCNAME_STR(f)   #f


#endif


/****************************************************************************/
/*                                                                          */
/* routines                                                                 */
/*                                                                          */
/****************************************************************************/



/****************************************************************************/


#if defined(C_FRONTEND) || defined(CPP_FRONTEND)
void IF_FUNCNAME (
#ifdef C_FRONTEND
	DDD_IF ifId,
#endif
	#ifdef IF_WITH_ATTR
		DDD_ATTR attr,
	#endif
	#ifdef IF_EXECLOCAL
		#ifdef IF_WITH_XARGS
			ExecProcXPtr ExecProc)
		#else
			ExecProcPtr ExecProc)
		#endif
	#else
		#ifdef IF_ONEWAY
			int dir,
		#endif
		size_t itemSize,
#ifdef C_FRONTEND
		#ifdef IF_WITH_XARGS
			ComProcXPtr Gather, ComProcXPtr Scatter)
		#else
			ComProcPtr Gather, ComProcPtr Scatter)
		#endif
#endif
#ifdef CPP_FRONTEND
		#ifdef IF_WITH_XARGS
			DDD_GatherScatterX REFDECL GatherScatter)
		#else
			DDD_GatherScatter  REFDECL GatherScatter)
		#endif
#endif
	#endif
{
	#ifdef CPP_FRONTEND
		DDD_IF ifId     = _id;
		//ComProcPtr Scatter = GatherScatter->Scatter;
		//ComProcPtr Gather  = GatherScatter->Gather;
	#endif
#endif

#ifdef F_FRONTEND
void IF_FUNCNAME (DDD_IF *_ifId,
	#ifdef IF_WITH_ATTR
		DDD_ATTR *_attr,
	#endif
	#ifdef IF_EXECLOCAL
		#ifdef IF_WITH_XARGS
			ExecProcXPtr ExecProc)
		#else
			ExecProcPtr ExecProc)
		#endif
	#else
		#ifdef IF_ONEWAY
			int *_dir,
		#endif
		size_t *_itemSize,
		#ifdef IF_WITH_XARGS
			ComProcXPtr Gather, ComProcXPtr Scatter)
		#else
			ComProcPtr Gather, ComProcPtr Scatter)
		#endif
	#endif
{
	/* in F_FRONTEND, copy call-by-ref params into variables */
	DDD_IF ifId     = *_ifId;
	#ifdef IF_WITH_ATTR
	DDD_ATTR attr   = *_attr;
	#endif
	#ifndef IF_EXECLOCAL
		#ifdef IF_ONEWAY
		int    dir      = *_dir;
		#endif
		size_t itemSize = *_itemSize;
	#endif
#endif  /* F_FRONTEND */

	IF_PROC		  *ifHead;
	unsigned long tries;
	int           recv_mesgs;


	/* prohibit using standard interface (IF0) */
	if (ifId==STD_INTERFACE)
	{
		DDD_PrintError('E', 4300,
			CONCAT("cannot use standard interface in ",IF_FUNCNAME));
		HARD_EXIT;
	}


	/* shortcuts can only be used without extended handler arguments */
	#ifndef IF_WITH_XARGS
		/* if shortcut tables are invalid -> recompute */
		IFCheckShortcuts(ifId);
	#endif


#ifdef IF_EXECLOCAL

	ForIF(ifId,ifHead)
	{
		#ifdef IF_WITH_ATTR
			IF_ATTR	    *ifAttr;
			FIND_ATTR; /* find ifAttr */
		#endif

		EXEC_LOOP(ExecProc, D_BA(PART),  PART->nBA);
		EXEC_LOOP(ExecProc, D_AB(PART),  PART->nAB);
		EXEC_LOOP(ExecProc, D_ABA(PART), PART->nABA);
	}

#else /* ! IF_EXECLOCAL */

	STAT_ZEROTIMER;
	STAT_RESET1;
	STAT_SETCOUNT(20,0);
	STAT_SETCOUNT(21,0);
	STAT_SETCOUNT(22,0);

	/* allocate storage for in and out buffers */
	ForIF(ifId,ifHead)
	{
		#ifdef IF_WITH_ATTR
			IF_ATTR	    *ifAttr;
		#endif
		#ifdef IF_ONEWAY
			int      nOut, nIn;
		#endif

		#ifdef IF_WITH_ATTR
			/* set default values for buffer length */
			ifHead->lenBufIn  = 0;
			ifHead->lenBufOut = 0;
			FIND_ATTR; /* find ifAttr */
			/* if no ATTR can be found, buffer length will be 0 */
		#endif
		

		#ifdef IF_EXCHANGE
			IFGetMem(ifHead, itemSize, PART->nItems, PART->nItems);
		#endif

		#ifdef IF_ONEWAY
			if (dir==IF_FORWARD) {
				nOut = PART->nAB; nIn = PART->nBA;
			}
			else {
				nOut = PART->nBA; nIn = PART->nAB;
			}
			IFGetMem(ifHead, itemSize, nIn+PART->nABA, nOut+PART->nABA);
		#endif

		STAT_SETCOUNT(20,STAT_GETCOUNT(20)+ifHead->nItems);
		STAT_SETCOUNT(21,STAT_GETCOUNT(21)+2);
		STAT_SETCOUNT(22,STAT_GETCOUNT(22)+ifHead->lenBufIn+ifHead->lenBufOut);
	}
	STAT_TIMER1(63);


	/* init communication, initiate receives */
	recv_mesgs = IFInitComm(ifId);


	/* build messages using gather-handler and send them away */
	ForIF(ifId,ifHead)
	{
		char   *buffer;
		#ifdef IF_WITH_ATTR
			IF_ATTR *ifAttr;
		#endif
		#ifdef IF_ONEWAY
			int      nOut;
			#ifdef IF_WITH_XARGS
			COUPLING **datOut;
			#else
			IFObjPtr  *datOut;
			#endif
		#endif

		#ifdef IF_WITH_ATTR
		FIND_ATTR; /* find ifAttr */
		#endif

		buffer = ifHead->msgBufOut;

		#ifdef IF_EXCHANGE
			/* exchange BA and AB during send */
			buffer= COMM_LOOP(Gather, D_BA(PART), buffer, itemSize, PART->nBA);
			buffer= COMM_LOOP(Gather, D_AB(PART), buffer, itemSize, PART->nAB);
		#endif

		#ifdef IF_ONEWAY
			if (dir==IF_FORWARD) {
				nOut = PART->nAB;  datOut = D_AB(PART);
			}
			else {
				nOut = PART->nBA;  datOut = D_BA(PART);
			}

			buffer= COMM_LOOP(Gather, datOut, buffer, itemSize, nOut);
		#endif

		buffer= COMM_LOOP(Gather, D_ABA(PART), buffer, itemSize, PART->nABA);

		IFInitSend(ifHead);
	}



	/* poll receives and scatter data */
	for(tries=0; tries<MAX_TRIES && recv_mesgs>0; tries++)
	{
		/* poll receive calls */
		ForIF(ifId,ifHead)
		{
			if (ifHead->lenBufIn>0 && ifHead->msgIn!=-1)
			{
				int error = InfoARecv(ifHead->vc, ifHead->msgIn);
				/* TODO complete error handling */
				if (error==1)
				{
					char     *buffer;
					#ifdef IF_ONEWAY
						int      nIn;
						#ifdef IF_WITH_XARGS
						COUPLING **datIn;
						#else
						IFObjPtr  *datIn;
						#endif
					#endif
					#ifdef IF_WITH_ATTR
						IF_ATTR  *ifAttr;
					#endif

					#ifdef CtrlTimeoutsDetailed
					printf("%4d: IFCTRL %02d received msg    from "
						"%4d after %10ld, size %ld\n",
						me, ifId, ifHead->proc,
						(unsigned long)tries,
						(unsigned long)ifHead->lenBufIn);
					#endif

					recv_mesgs--;
					ifHead->msgIn=-1;

					#ifdef IF_WITH_ATTR
					FIND_ATTR; /* find ifAttr */
					#endif

					buffer = ifHead->msgBufIn;

					/* get data using scatter-handler */
					#ifdef IF_EXCHANGE
						buffer = COMM_LOOP(Scatter,
									D_AB(PART), buffer, itemSize, PART->nAB);
						buffer = COMM_LOOP(Scatter,
									D_BA(PART), buffer, itemSize, PART->nBA);
					#endif

					#ifdef IF_ONEWAY
						if (dir==IF_FORWARD) {
							nIn  = PART->nBA;  datIn = D_BA(PART);
						}
						else {
							nIn  = PART->nAB;  datIn = D_AB(PART);
						}

						buffer = COMM_LOOP(Scatter, datIn, buffer, itemSize, nIn);
					#endif

					buffer = COMM_LOOP(Scatter,
						D_ABA(PART), buffer, itemSize, PART->nABA);
				}
			}
		}
	}

	/* finally poll send completion */
	if (recv_mesgs>0)
	{
		sprintf(cBuffer, CONCAT("receive-timeout for IF %02d in ",IF_FUNCNAME), ifId);
		DDD_PrintError('E', 4200, cBuffer);

		ForIF(ifId,ifHead)
		{
			if (ifHead->lenBufIn>0 && ifHead->msgIn!=-1)
			{
				sprintf(cBuffer,
					"  waiting for message (from proc %d, size %ld)",
					ifHead->proc, (unsigned long)ifHead->lenBufIn);
				DDD_PrintError('E', 4201, cBuffer);
			}
		}
	}
	else
	{
		#ifdef CtrlTimeouts
		printf("%4d: IFCTRL %02d received msg  all after %10ld tries\n",
			me, ifId, (unsigned long)tries);
		#endif

		if (! IFPollSend(ifId))
		{
			sprintf(cBuffer, CONCAT("send-timeout for IF %02d in ",IF_FUNCNAME), ifId);
			DDD_PrintError('E', 4210, cBuffer);

			ForIF(ifId,ifHead)
			{
				if (ifHead->lenBufOut>0 && ifHead->msgOut!=-1)
				{
					sprintf(cBuffer,
						"  waiting for send completion (to proc %d, size %ld)",
						ifHead->proc, (unsigned long)ifHead->lenBufOut);
					DDD_PrintError('E', 4211, cBuffer);
				}
			}
		}
	}


	/* free memory */
	IFExitComm(ifId);

	STAT_TIMER1(60);

#endif /* IF_EXECLOCAL */
}


/****************************************************************************/

/* undefs for all input macros and defines */

#undef IF_NAME
#undef IF_FUNCNAME

#ifdef IF_ONEWAY
#undef IF_ONEWAY
#endif

#ifdef IF_EXCHANGE
#undef IF_EXCHANGE
#endif

#ifdef IF_EXECLOCAL
#undef IF_EXECLOCAL
#endif


#ifdef IF_WITH_ATTR
#undef IF_WITH_ATTR
#endif

#ifdef IF_WITH_XARGS
#undef IF_WITH_XARGS
#endif

#ifdef IF_CBR
#undef IF_CBR
#endif



/* undefs for derived macros */

#undef PART
#undef EXEC_LOOP
#undef COMM_LOOP
#undef D_AB
#undef D_BA
#undef D_ABA


#ifdef CPP_FRONTEND
#undef REFDECL
#endif


#undef _CAT
#undef CAT



/****************************************************************************/

