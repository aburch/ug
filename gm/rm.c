// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:
/****************************************************************************/
/*																			*/
/* File:	  rm.c	                                                                                                                */
/*																			*/
/* Purpose:   rule manager for 2D and 3D refinement rules					*/
/*																			*/
/* Author:	  Stefan Lang                                                                                   */
/*			  Institut fuer Computeranwendungen III                                                 */
/*			  Universitaet Stuttgart										*/
/*			  Pfaffenwaldring 27											*/
/*			  70550 Stuttgart												*/
/*																			*/
/* History:   21.11.95 begin, ugp version 3.0								*/
/*																			*/
/* Remarks:                                                                                                                             */
/*																			*/
/****************************************************************************/

/****************************************************************************/
/*																			*/
/* include files															*/
/*			  system include files											*/
/*			  application include files                                                                     */
/*																			*/
/****************************************************************************/

/* standard C library */
#include <assert.h>
#include <stdio.h>

/* low module */
#include "fileopen.h"

/* dev module */
#include "devices.h"

/* gm module */
#include "evm.h"
#include "gm.h"
#include "refine.h"
#include "rm.h"
#include "GenerateRules.h"

#include "defaults.h"

/****************************************************************************/
/*																			*/
/* defines in the following order											*/
/*																			*/
/*		  compile time constants defining static data size (i.e. arrays)	*/
/*		  other constants													*/
/*		  macros															*/
/*																			*/
/****************************************************************************/

/* macros defining best refrule, specify exactly one of them !! */
/*#define __SHORTEST_INTERIOR_EDGE__*/
/*#define __MIDDLE_INTERIOR_EDGE__*/
#define __LONGEST_INTERIOR_EDGE__

#define NOINDEX         -1


/****************************************************************************/
/*																			*/
/* data structures used in this source file (exported data structures are	*/
/*		  in the corresponding include file!)								*/
/*																			*/
/****************************************************************************/


/****************************************************************************/
/*																			*/
/* definition of exported global variables									*/
/*																			*/
/****************************************************************************/

INT MaxRules[TAGS] = {0,0,0,0,0,0,0,0};
INT MaxNewCorners[TAGS] = {0,0,0,0,0,0,0,0};
INT MaxNewEdges[TAGS] = {0,0,0,0,0,0,0,0};
INT CenterNodeIndex[TAGS] = {0,0,0,0,0,0,0,0};
REFRULE *RefRules[TAGS] = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
SHORT   *Pattern2Rule[TAGS] = {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

#ifdef __THREEDIM__
/* define the standard regular rules for tetrahedrons */
FULLREFRULEPTR theFullRefRule;
static ElementVectorProcPtr theDirectionElemEval;
#endif


/****************************************************************************/
/*																			*/
/* definition of variables global to this source file only (static!)		*/
/*																			*/
/****************************************************************************/

#ifdef __TWODIM__
static REFRULE Empty_Rule =
{-1,-1,-1,-1,{-1,-1,-1,-1},-1,
 {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1}},
 {{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
 {{-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}};

/* define Rules for Triangles */
static REFRULE TriangleRules[18] = {
  /* T_NOREF */
  {TRIANGLE,T_NOREF,-1,0,
   {0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1}},
   {{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_COPY */
  {TRIANGLE,T_COPY,REGULAR_CLASS|IRREGULAR_CLASS,1,
   {0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1}},
   {{4,0,1,-1},{4,1,2,-1},{4,2,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,1,2,-1},{20,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_RED */
  {TRIANGLE,T_RED,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,1,1,0},(1<<3)-1,
   {{0,1},{1,2},{0,2},{-1,-1},{-1,-1}},
   {{3,0,3,0},{3,3,1,0},{3,1,4,0},{3,4,2,0},
                             {3,2,5,0},{3,5,0,2},{1,3,4,0},{1,4,5,0},
                             {1,5,3,0},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,5,-1},{20, 3,22,-1},0},
                             {TRIANGLE,{3,1,4,-1},{20,21, 3,-1},0},
                             {TRIANGLE,{4,2,5,-1},{ 21,22,3,-1},0},
                             {TRIANGLE,{3,4,5,-1},{ 1, 2, 0,-1},0}}},


  /* T_BISECT_1 edge 0 bisected */
  {TRIANGLE,T_BISECT_1_0,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {1,0,0,0},1,
   {{0,1},{-1,-1},{-1,-1},{-1,-1},{-1,-1}},
   {{3,0,3,-1},{3,3,1,-1},{ 1, 3, 2,-1},{4,1,2,-1},
                             {4,2,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,2,-1},{20, 1,22,-1},0},
                             {TRIANGLE,{3,1,2,-1},{20,21, 0,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_1 edge 1 bisected */
  {TRIANGLE,T_BISECT_1_1,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {0,1,0,0},1<<1,
   {{-1,-1},{0,2},{-1,-1},{-1,-1},{-1,-1}},
   {{3,1,4,-1},{3,4,2,-1},{ 1, 4, 0,-1},{4,0,1,-1},
                             {4,2,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,1,4,-1},{20,21, 1,-1},0},
                             {TRIANGLE,{0,4,2,-1},{ 0,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_1 edge 2 bisected */
  {TRIANGLE,T_BISECT_1_2,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {0,0,1,0},1<<2,
   {{-1,-1},{-1,-1},{0,2},{-1,-1},{-1,-1}},
   {{3,2,5,-1},{3,5,0,-1},{ 1, 5, 1,-1},{4,0,1,-1},
                             {4,1,2,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,1,5,-1},{20, 1,22,-1},0},
                             {TRIANGLE,{5,1,2,-1},{ 0,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},


  /* T_BISECT_2_T1 edge 2 not bisected */
  {TRIANGLE,T_BISECT_2_T1_2,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {1,1,0,0},(1<<2)-1,
   {{0,1},{1,2},{-1,-1},{-1,-1},{-1,-1}},
   {{1,3,2,-1},{1,3,4,-1},{ 3, 0, 3,-1},{ 3, 3, 1,-1},
                             {3,1,4,-1},{3,4,2,-1},{4,0,2,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,2,-1},{20, 2,22,-1},0},
                             {TRIANGLE,{3,1,4,-1},{20,21, 2,-1},0},
                             {TRIANGLE,{3,4,2,-1},{ 1,21, 0,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_T1 edge 0 not bisected */
  {TRIANGLE,T_BISECT_2_T1_0,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {0,1,1,0},6,
   {{-1,-1},{0,2},{1,2},{-1,-1},{-1,-1}},
   {{1,0,4,-1},{1,4,5,-1},{4,0,1,-1},{3,1,4,-1},
                             {3,4,2,-1},{3,2,5,-1},{3,5,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,1,4,-1},{20,21, 1,-1},0},
                             {TRIANGLE,{0,4,5,-1},{ 0, 2,22,-1},0},
                             {TRIANGLE,{5,4,2,-1},{ 1,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_T1 edge 1 not bisected */
  {TRIANGLE,T_BISECT_2_T1_1,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {1,0,1,0},5,
   {{0,1},{-1,-1},{1,2},{-1,-1},{-1,-1}},
   {{1,3,5,-1},{1,1,5,-1},{3,0,3,-1},{3,3,1,-1},
                             {4,1,2,-1},{3,2,5,-1},{3,5,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,5,-1},{20, 1,22,-1},0},
                             {TRIANGLE,{3,1,5,-1},{20, 2, 0,-1},0},
                             {TRIANGLE,{5,1,2,-1},{ 1,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_T2 edge 1 not bisected */
  {TRIANGLE,T_BISECT_2_T2_1,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {1,0,1,0},5,
   {{0,1},{-1,-1},{0,2},{-1,-1},{-1,-1}},
   {{1,3,5,-1},{1,3,2,-1},{3,0,3,-1},{3,3,1,-1},
                             {4,1,2,-1},{3,2,5,-1},{3,5,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,5,-1},{20, 1,22,-1},0},
                             {TRIANGLE,{5,3,2,-1},{ 0, 2,22,-1},0},
                             {TRIANGLE,{3,1,2,-1},{20,21, 1,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_T2 edge 2 not bisected */
  {TRIANGLE,T_BISECT_2_T2_2,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {1,1,0,0},3,
   {{0,1},{0,2},{-1,-1},{-1,-1},{-1,-1}},
   {{1,3,4,-1},{1,4,0,-1},{3,0,3,-1},{3,3,1,-1},
                             {3,1,4,-1},{3,4,2,-1},{4,2,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,4,-1},{20, 1, 2,-1},0},
                             {TRIANGLE,{3,1,4,-1},{20,21, 0,-1},0},
                             {TRIANGLE,{0,4,2,-1},{ 0,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_T2 edge 0 not bisected */
  {TRIANGLE,T_BISECT_2_T2_0,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {0,1,1,0},6,
   {{-1,-1},{1,2},{0,2},{-1,-1},{-1,-1}},
   {{1,4,5,-1},{1,5,1,-1},{4,0,1,-1},{3,1,4,-1},
                             {3,4,2,-1},{3,2,5,-1},{3,5,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,1,5,-1},{20, 1,22,-1},0},
                             {TRIANGLE,{5,1,4,-1},{ 0,21, 2,-1},0},
                             {TRIANGLE,{5,4,2,-1},{ 1,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_Q edge 0 not bisected */
  {TRIANGLE,T_BISECT_2_Q_0,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {0,1,1,0},6,
   {{-1,-1},{0,2},{0,3},{-1,-1},{-1,-1}},
   {{1,4,5,-1},{4,0,1,-1},{3,1,4,-1},{3,4,2,-1},
                             {3,2,5,-1},{3,5,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,4,5},{20,21, 1,22},0},
                             {TRIANGLE,{5,4,2,-1},{ 0,21,22,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_Q edge 1 not bisected */
  {TRIANGLE,T_BISECT_2_Q_1,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {1,0,1,0},5,
   {{0,1},{-1,-1},{0,2},{-1,-1},{-1,-1}},
   {{1,3,5,-1},{3,0,3,-1},{3,3,1,-1},{4,1,2,-1},
                             {3,2,5,-1},{3,5,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,5,-1},{20, 1,22,-1},0},
                             {QUADRILATERAL,{3,1,2,5},{20,21,22, 0},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_2_Q edge 2 not bisected */
  {TRIANGLE,T_BISECT_2_Q_2,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {1,1,0,0},3,
   {{0,1},{0,2},{-1,-1},{-1,-1},{-1,-1}},
   {{1,3,4,-1},{3,0,3,-1},{3,3,1,-1},{3,1,4,-1},
                             {3,4,2,-1},{4,2,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,3,4,2},{20, 1,21,22},0},
                             {TRIANGLE,{3,1,4,-1},{20,21, 0,-1},0},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* T_BISECT_3 edge 0 */
  {TRIANGLE,T_BISECT_3_0,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,1,1,0},7,
   {{0,1},{3,2},{0,2},{-1,-1},{-1,-1}},
   {{1,3,4,-1},{1,3,2,-1},{1,3,5,-1},{3,0,3,-1},
                             {3,3,1,-1},{3,1,4,-1},{3,4,2,-1},{3,2,5,-1},
                             {3,5,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,5,-1},{20, 1,22,-1},0},
                             {TRIANGLE,{5,3,2,-1},{ 0, 2,22,-1},0},
                             {TRIANGLE,{3,4,2,-1},{ 3,21, 1,-1},0},
                             {TRIANGLE,{3,1,4,-1},{20,21, 2,-1},0}}},

  /* T_BISECT_3 edge 1 */
  {TRIANGLE,T_BISECT_3_1,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,1,1,0},7,
   {{0,1},{0,2},{1,2},{-1,-1},{-1,-1}},
   {{1,4,0,-1},{1,4,3,-1},{1,4,5,-1},{3,0,3,-1},
                             {3,3,1,-1},{3,1,4,-1},{3,4,2,-1},{3,2,5,-1},
                             {3,5,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,4,-1},{20, 3, 1,-1},0},
                             {TRIANGLE,{0,4,5,-1},{ 0, 2,22,-1},0},
                             {TRIANGLE,{5,4,2,-1},{ 1,21,22,-1},0},
                             {TRIANGLE,{3,1,4,-1},{20,21, 0,-1},0}}},

  /* T_BISECT_3 edge 2 */
  {TRIANGLE,T_BISECT_3_2,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,1,1,0},7,
   {{0,1},{2,2},{1,2},{-1,-1},{-1,-1}},
   {{1,5,3,-1},{1,5,1,-1},{1,5,4,-1},{3,0,3,-1},
                             {3,3,1,-1},{3,1,4,-1},{3,4,2,-1},{3,2,5,-1},
                             {3,5,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,3,5,-1},{20, 1,22,-1},0},
                             {TRIANGLE,{3,1,5,-1},{20, 2, 0,-1},0},
                             {TRIANGLE,{5,1,4,-1},{ 1,21, 3,-1},0},
                             {TRIANGLE,{5,4,2,-1},{ 2,21,22,-1},0}}},

};

/* define Rules for Quadrilaterals */
static REFRULE QuadrilateralRules[17] =
{
  /* Q_NOREF */
  {QUADRILATERAL,Q_NOREF,-1,0,
   {0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1}},
   {{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_COPY */
  {QUADRILATERAL,Q_COPY,REGULAR_CLASS|IRREGULAR_CLASS,1,
   {0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1}},
   {{4,0,1,-1},{4,1,2,-1},{4,2,3,-1},{4,3,0,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,2,3},{20,21,22,23},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_RED */
  {QUADRILATERAL,Q_RED,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,1,1,1,1},(1<<5)-1,
   {{0,1},{1,2},{2,3},{3,0},{0,2}},
   {{3,0,4,-1},{3,4,1,-1},{3,1,5,-1},{3,5,2,-1},
                             {3,2,6,-1},{3,6,3,-1},{3,3,7,-1},{3,7,0,-1},
                             {1,4,8,-1},{1,5,8,-1},{1,6,8,-1},{1,7,8,-1}},
   {{QUADRILATERAL,{0,4,8,7},{20, 1, 3,23},-1},
                             {QUADRILATERAL,{4,1,5,8},{20,21, 2, 0},-1},
                             {QUADRILATERAL,{8,5,2,6},{ 1,21,22, 3},-1},
                             {QUADRILATERAL,{7,8,6,3},{ 0, 2,22,23},-1}}},

  /* Q_CLOSE_1 edge 0 and 1 bisected */
  {QUADRILATERAL,Q_CLOSE_1_0,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {1,1,0,0,1},3+16,
   {{0,1},{1,2},{-1,-1},{-1,-1},{0,2}},
   {{1,4,8,-1},{1,5,8,-1},{1,3,8,-1},{3,0,4,-1},
                             {3,4,1,-1},{3,1,5,-1},{3,5,2,-1},{4,2,3,-1},
                             {4,3,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,4,8,3},{20, 1, 2,23},-1},
                             {QUADRILATERAL,{4,1,5,8},{20,21, 2, 0},-1},
                             {QUADRILATERAL,{8,5,2,3},{ 1,21,22, 0},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_1 edge 1 and 2 bisected */
  {QUADRILATERAL,Q_CLOSE_1_1,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {0,1,1,0,1},6+16,
   {{-1,-1},{0,2},{1,3},{-1,-1},{0,3}},
   {{1,0,8,-1},{1,5,8,-1},{1,6,8,-1},{4,0,1,-1},
                             {3,1,5,-1},{3,5,2,-1},{3,2,6,-1},{3,6,3,-1},
                             {4,3,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,5,8},{20,21, 1, 2},-1},
                             {QUADRILATERAL,{8,5,2,6},{ 0,21,22, 2},-1},
                             {QUADRILATERAL,{0,8,6,3},{ 0, 1,22,23},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_1 edge 2 and 3 bisected */
  {QUADRILATERAL,Q_CLOSE_1_2,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {0,0,1,1,1},12+16,
   {{-1,-1},{-1,-1},{1,3},{0,3},{0,2}},
   {{1,1,8,-1},{1,6,8,-1},{1,7,8,-1},{4,0,1,-1},
                             {4,1,2,-1},{3,2,6,-1},{3,6,3,-1},{3,3,7,-1},
                             {3,7,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,8,7},{20, 1, 2,23},-1},
                             {QUADRILATERAL,{8,1,2,6},{ 0,21,22, 2},-1},
                             {QUADRILATERAL,{7,8,6,3},{ 0, 1,22,23},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_1 edge 0 and 3 bisected */
  {QUADRILATERAL,Q_CLOSE_1_3,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {1,0,0,1,1},9+16,
   {{0,1},{-1,-1},{-1,-1},{0,3},{0,2}},
   {{1,4,8,-1},{1,2,8,-1},{1,7,8,-1},{3,0,4,-1},
                             {3,4,1,-1},{4,1,2,-1},{4,2,3,-1},{3,3,7,-1},
                             {3,7,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,4,8,7},{20, 1, 2,23},-1},
                             {QUADRILATERAL,{4,1,2,8},{20,21, 2, 0},-1},
                             {QUADRILATERAL,{7,8,2,3},{ 0, 1,22,23},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_BLUE edge 0 and 2 bisected */
  {QUADRILATERAL,Q_BLUE_0,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {1,0,1,0,0},5,
   {{0,1},{-1,-1},{0,2},{-1,-1},{-1,-1}},
   {{1,4,6,-1},{3,0,4,-1},{3,4,1,-1},{4,1,2,-1},
                             {3,2,6,-1},{3,6,3,-1},{4,3,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,4,6,3},{20, 1,22,23},-1},
                             {QUADRILATERAL,{4,1,2,6},{20,21,22, 0},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_BLUE edge 1 and 3 bisected */
  {QUADRILATERAL,Q_BLUE_1,REGULAR_CLASS|IRREGULAR_CLASS,2,
   {0,1,0,1,0},10,
   {{-1,-1},{0,2},{-1,-1},{0,3},{-1,-1}},
   {{1,5,7,-1},{4,0,1,-1},{3,1,5,-1},{3,5,2,-1},
                             {4,2,3,-1},{3,3,7,-1},{3,7,0,-1},{-1,-1,-1,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,5,7},{20,21, 1,23},-1},
                             {QUADRILATERAL,{7,5,2,3},{ 0,21,22,23},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_2 edge 0 bisected */
  {QUADRILATERAL,Q_CLOSE_2_0,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {1,0,0,0,1},1+16,
   {{0,1},{-1,-1},{-1,-1},{-1,-1},{0,2}},
   {{1,4,8,-1},{1,2,8,-1},{1,3,8,-1},{3,0,4,-1},
                             {3,4,1,-1},{4,1,2,-1},{4,2,3,-1},{4,3,0,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,4,8,3},{20, 1, 2,23},-1},
                             {QUADRILATERAL,{4,1,2,8},{20,21, 2, 0},-1},
                             {TRIANGLE,{8,2,3,-1},{ 1,22, 0,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_2 edge 1 bisected */
  {QUADRILATERAL,Q_CLOSE_2_1,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {0,1,0,0,1},2+16,
   {{-1,-1},{0,2},{-1,-1},{-1,-1},{0,3}},
   {{1,0,8,-1},{1,5,8,-1},{1,3,8,-1},{4,0,1,-1},
                             {3,1,5,-1},{3,5,2,-1},{4,2,3,-1},{4,3,0,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,5,8},{20,21, 1, 2},-1},
                             {QUADRILATERAL,{8,5,2,3},{ 0,21,22, 2},-1},
                             {TRIANGLE,{0,8,3,-1},{ 0, 1,23,-1},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_2 edge 2 bisected */
  {QUADRILATERAL,Q_CLOSE_2_2,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {0,0,1,0,1},4+16,
   {{-1,-1},{-1,-1},{1,3},{-1,-1},{0,2}},
   {{1,0,8,-1},{1,1,8,-1},{1,6,8,-1},{4,0,1,-1},
                             {4,1,2,-1},{3,2,6,-1},{3,6,3,-1},{4,3,0,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,1,8,-1},{20, 1, 2,-1},-1},
                             {QUADRILATERAL,{8,1,2,6},{ 0,21,22, 2},-1},
                             {QUADRILATERAL,{0,8,6,3},{ 0, 1,22,23},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_2 edge 3 bisected */
  {QUADRILATERAL,Q_CLOSE_2_3,REGULAR_CLASS|IRREGULAR_CLASS,3,
   {0,0,0,1,1},8+16,
   {{-1,-1},{-1,-1},{-1,-1},{0,3},{0,2}},
   {{1,1,8,-1},{1,2,8,-1},{1,7,8,-1},{4,0,1,-1},
                             {4,1,2,-1},{4,2,3,-1},{3,3,7,-1},{3,7,0,-1},
                             {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,8,7},{20, 1, 2,23},-1},
                             {TRIANGLE,{1,2,8,-1},{21, 2, 0,-1},-1},
                             {QUADRILATERAL,{7,8,2,3},{ 0, 1,22,23},-1},
                             {-1,{-1,-1,-1,-1},{-1,-1,-1,-1},-1}}},

  /* Q_CLOSE_3 edge 0 not bisected */
  {QUADRILATERAL,Q_CLOSE_3_0,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {0,1,1,1,0},14,
   {{-1,-1},{0,2},{1,2},{0,3},{-1,-1}},
   {{1,7,5,-1},{1,5,6,-1},{1,6,7,-1},{4,0,1,-1},
                             {3,1,5,-1},{3,5,2,-1},{3,2,6,-1},{3,6,3,-1},
                             {3,3,7,-1},{3,7,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,1,5,7},{20,21, 1,23},-1},
                             {TRIANGLE,{7,5,6,-1},{ 0, 2, 3,-1},-1},
                             {TRIANGLE,{5,2,6,-1},{21,22, 1,-1},-1},
                             {TRIANGLE,{7,6,3,-1},{ 1,22,23,-1},-1}}},

  /* Q_CLOSE_3 edge 1 not bisected */
  {QUADRILATERAL,Q_CLOSE_3_1,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,0,1,1,0},13,
   {{0,1},{-1,-1},{1,2},{0,2},{-1,-1}},
   {{1,7,4,-1},{1,4,6,-1},{1,6,7,-1},{3,0,4,-1},
                             {3,4,1,-1},{4,1,2,-1},{3,2,6,-1},{3,6,3,-1},
                             {3,3,7,-1},{3,7,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,4,7,-1},{20, 1,23,-1},-1},
                             {TRIANGLE,{7,4,6,-1},{ 0, 3, 2,-1},-1},
                             {TRIANGLE,{7,6,3,-1},{ 1,22,23,-1},-1},
                             {QUADRILATERAL,{4,1,2,6},{20,21,22, 1},-1}}},

  /* Q_CLOSE_3 edge 2 not bisected */
  {QUADRILATERAL,Q_CLOSE_3_2,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,1,0,1,0},11,
   {{0,1},{2,2},{-1,-1},{0,2},{-1,-1}},
   {{1,7,4,-1},{1,4,5,-1},{1,5,7,-1},{3,0,4,-1},
                             {3,4,1,-1},{3,1,5,-1},{3,5,2,-1},{4,2,3,-1},
                             {3,3,7,-1},{3,7,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{TRIANGLE,{0,4,7,-1},{20, 1,23,-1},-1},
                             {TRIANGLE,{4,5,7,-1},{ 2, 3, 0,-1},-1},
                             {TRIANGLE,{4,1,5,-1},{20,21, 1,-1},-1},
                             {QUADRILATERAL,{7,5,2,3},{ 1,21,22,23},-1}}},

  /* Q_CLOSE_3 edge 3 not bisected */
  {QUADRILATERAL,Q_CLOSE_3_3,REGULAR_CLASS|IRREGULAR_CLASS,4,
   {1,1,1,0,0},7,
   {{0,1},{2,2},{0,2},{-1,-1},{-1,-1}},
   {{1,6,4,-1},{1,4,5,-1},{1,5,6,-1},{3,0,4,-1},
                             {3,4,1,-1},{3,1,5,-1},{3,5,2,-1},{3,2,6,-1},
                             {3,6,3,-1},{4,3,0,-1},{-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{QUADRILATERAL,{0,4,6,3},{20, 1,22,23},-1},
                             {TRIANGLE,{4,5,6,-1},{ 2, 3, 0,-1},-1},
                             {TRIANGLE,{4,1,5,-1},{20,21, 1,-1},-1},
                             {TRIANGLE,{5,2,6,-1},{21,22, 1,-1},-1}}}

};

#endif

#ifdef __THREEDIM__

static INT theBFRRDirID;      /* env type for BestFullRefRule       */

static REFRULE Empty_Rule =
{-1,-1,-1,-1,
 {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},-1,
 {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                        {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                        {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                        {-1,-1}},
 {{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                        {-1,-1,-1,-1},{-1,-1,-1,-1}},
 {{-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                        {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1}}};

/* define the regular rules for pyramids */
static REFRULE PyramidRules[2] =
{
  /* PYR_NO_REF */
  {PYRAMID,0,-1,0,
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1}},
   {{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1}}},

  /* PYR_COPY */
  {PYRAMID,1,COPY_CLASS,1,
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1}},
   {{ 4, 0, 1,-1},{ 4, 1, 2,-1},{ 4, 2, 3,-1},{ 4, 3, 0,-1},
                    { 4, 0, 4,-1},{ 4, 1, 4,-1},{ 4, 2, 4,-1},{ 4, 3, 4,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{PYRAMID,{ 0, 1, 2, 3, 4,-1,-1,-1},{20,21,22,23,24,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1}}}

};

/* define the regular rules for hexahedra */
static REFRULE HexahedronRules[3] =
{
  /* HEX_NO_REF */
  {HEXAHEDRON,0,-1,0,
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1}},
   {{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1}}},

  /* HEX_COPY */
  {HEXAHEDRON,1,COPY_CLASS,1,
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},0,
   {{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},{-1,-1},
                    {-1,-1}},
   {{4,0,1,-1},{4,1,2,-1},{4,2,3,-1},{4,3,0,-1},
                    {4,0,4,-1},{4,1,5,-1},{4,2,6,-1},{4,3,7,-1},
                    {4,4,5,-1},{4,5,6,-1},{4,6,7,-1},{4,7,4,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},{-1,-1,-1,-1},
                    {-1,-1,-1,-1},{-1,-1,-1,-1}},
   {{HEXAHEDRON,{0,1,2,3,4,5,6,7},{20,21,22,23,24,25},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1},
                    {-1,{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1},-1}}},

  /* HEX_RED */
  {HEXAHEDRON,2,REGULAR_CLASS,8,
   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},(1<<19)-1,

   /* sonandnode */
   {{0,1},{1,2},{2,3},{3,0},
                     {0,4},{1,5},{2,6},{3,7},
                     {4,5},{5,6},{6,7},{7,4},
                     {0,2},{0,5},{1,6},{2,7},{0,7},{4,6},{0,6}},

   /* new edges */
   {{3, 0, 8,-1},{3, 8, 1,-1},{3, 1, 9,-1},{3, 9, 2,-1},
                     {3, 2,10,-1},{3,10, 3,-1},{3, 3,11,-1},{3,11, 0,-1},
                     {2, 8,20, 0},{2, 9,20, 0},{2,10,20, 0},{2,11,20, 0},

                     {3, 0,12,-1},{2, 8,21, 1},{3, 1,13,-1},{2, 9,22, 2},
                     {3, 2,14,-1},{2,10,23, 3},{3, 3,15,-1},{2,11,24, 4},
                     {1,20,26,-1},

                     {2,12,21, 1},{2,21,13, 1},{2,13,22, 2},{2,22,14, 2},
                     {2,14,23, 3},{2,23,15, 3},{2,15,24, 4},{2,24,12, 4},
                     {1,21,26,-1},{1,22,26,-1},{1,23,26,-1},{1,24,26,-1},

                     {3,12, 4,-1},{2,21,16, 1},{3,13, 5,-1},{2,22,17, 2},
                     {3,14, 6,-1},{2,23,18, 3},{3,15, 7,-1},{2,24,19, 4},
                     {1,26,25,-1},

                     {3, 4,16,-1},{3,16, 5,-1},{3, 5,17,-1},{3,17, 6,-1},
                     {3, 6,18,-1},{3,18, 7,-1},{3, 7,19,-1},{3,19, 4,-1},
                     {2,16,25, 5},{2,17,25, 5},{2,18,25, 5},{2,19,25, 5}},

   /* sons */
   {{HEXAHEDRON,{ 0, 8,20,11,12,21,26,24},{20,21, 1, 3,24, 4},-1},
                     {HEXAHEDRON,{ 8, 1, 9,20,21,13,22,26},{20,21,22, 2, 0, 5},
                     0x1<<PATHDEPTHSHIFT | 0x2},
                     {HEXAHEDRON,{20, 9, 2,10,26,22,14,23},{20, 1,22,23, 3, 6},
                     0x2<<PATHDEPTHSHIFT | 0x2 | 0x3<<3},
                     {HEXAHEDRON,{11,20,10, 3,24,26,23,15},{20, 0, 2,23,24, 7},
                     0x1<<PATHDEPTHSHIFT | 0x3},

                     {HEXAHEDRON,{12,21,26,24, 4,16,25,19},{ 0,21, 5, 7,24,25},
                     0x1<<PATHDEPTHSHIFT | 0x5},
                     {HEXAHEDRON,{21,13,22,26,16, 5,17,25},{ 1,21,22, 6, 4,25},
                     0x2<<PATHDEPTHSHIFT | 0x5 | 0x2<<3},
                     {HEXAHEDRON,{26,22,14,23,25,17, 6,18},{ 2, 5,22,23, 7,25},
                     0x3<<PATHDEPTHSHIFT | 0x5 | 0x2<<3 | 0x3<<(2*3)},
                     {HEXAHEDRON,{24,26,23,15,19,25,18, 7},{ 3, 4, 6,23,24,25},
                     0x2<<PATHDEPTHSHIFT | 0x5 | 0x3<<3}}}

};
#endif

/* data for CVS */
static char rcsid[] = "$Header$";


/****************************************************************************/
/*																			*/
/* forward declarations of functions used before they are defined			*/
/*																			*/
/****************************************************************************/


/****************************************************************************/
/*																			*/
/* Function:  IsAllowedToRefine                                                                                         */
/*																			*/
/* Purpose:   determine whether element is allowed to be refined            */
/*																			*/
/* Param:	  ELEMENT *theElement: element to look after					*/
/*																			*/
/* return:	  INT 1: element can be refined                                                                 */
/*				  0: element cannot be refined                                                          */
/*																			*/
/****************************************************************************/

INT IsAllowedToRefine (const ELEMENT *theElement)
{
  if (REFINECLASS(theElement)==RED) return (FALSE);
  return (TRUE);
}


#ifdef __THREEDIM__
/****************************************************************************/
/*																			*/
/* Function:  ShortestInteriorEdge											*/
/*																			*/
/* Purpose:   compute best full refined refrule for the element                         */
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                                 */
/*																			*/
/* return:	  INT Mark: number of refrule									*/
/*																			*/
/****************************************************************************/

static INT ShortestInteriorEdge (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM];
  INT i, flags;
  COORD Dist_0_5, Dist_1_3, Dist_2_4;

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* compute distances */
  V3_EUKLIDNORM_OF_DIFF(MidPoints[0], MidPoints[5], Dist_0_5)
  V3_EUKLIDNORM_OF_DIFF(MidPoints[1], MidPoints[3], Dist_1_3)
  V3_EUKLIDNORM_OF_DIFF(MidPoints[2], MidPoints[4], Dist_2_4)

  /* return best Refrule (shortest interior edge) */
  flags = (Dist_0_5 < Dist_1_3) ;
  flags |= ((Dist_1_3 < Dist_2_4) <<1) ;
  flags |= ((Dist_2_4 < Dist_0_5) <<2) ;
  assert(flags != 7);

  switch(flags)
  {
  case 0 :                                              /* Dist_0_5 = Dist_2_4 = Dist_1_3 */
    return (FULL_REFRULE_0_5);
  case 1 :                                              /* Dist_0_5 < Dist_2_4 < Dist_1_3 */
    return (FULL_REFRULE_0_5);
  case 2 :                                              /* Dist_1_3 < Dist_0_5 < Dist_2_4 */
    return (FULL_REFRULE_1_3);
  case 3 :                                              /* Dist_0_5 < Dist_1_3 < Dist_2_4 */
    return (FULL_REFRULE_0_5);
  case 4 :                                              /* Dist_2_4 < Dist_1_3 < Dist_0_5 */
    return (FULL_REFRULE_2_4);
  case 5 :                                              /* Dist_2_4 < Dist_0_5 < Dist_1_3 */
    return (FULL_REFRULE_2_4);
  case 6 :                                              /* Dist_1_3 < Dist_2_4 < Dist_0_5 */
    return (FULL_REFRULE_1_3);
  }
}

/****************************************************************************/
/*																			*/
/* Function:  MinimalSideAngle												*/
/*																			*/
/* Purpose:   compute best full refined refrule for the element                         */
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                                 */
/*																			*/
/* return:	  INT Mark: number of refrule									*/
/*																			*/
/****************************************************************************/

#ifdef __ALLRULES__

static INT MinimalSideAngle (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM];
  INT i,j,k,l,imin;
  COORD MaxAngle,Max,Min;

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* try possebilities */
  Min = 190.0;
  for (i=0; i<3; i++)
  {
    j = OPPOSITE_EDGE(theElement,i);
    Corners[2] = MidPoints[i];
    Corners[3] = MidPoints[j];

    Max = 0.0;
    for (k=0; k<2; k++)
    {
      for (l=0; l<2; l++)
        Corners[l] = MidPoints[SideEdgesOfEdge[i][k][l]];
      if (TetMaxSideAngle(theElement,Corners,&MaxAngle))
        return (FULL_REFRULE_0_5);
      Max = MAX(Max,MaxAngle);
    }
    for (k=0; k<2; k++)
    {
      for (l=0; l<2; l++)
        Corners[l] = MidPoints[SideEdgesOfEdge[j][k][l]];
      if (TetMaxSideAngle(theElement,Corners,&MaxAngle))
        return (FULL_REFRULE_0_5);
      Max = MAX(Max,MaxAngle);
    }
    if (Max<Min)
    {
      Min = Max;
      imin = i;
    }
  }

  switch (imin)
  {
  case 0 :
    return (FULL_REFRULE_0_5);
  case 1 :
    return (FULL_REFRULE_1_3);
  case 2 :
    return (FULL_REFRULE_2_4);
  }
}

/****************************************************************************/
/*																			*/
/* Function:  MinimalSideEntry												*/
/*																			*/
/* Purpose:   compute best full refined refrule for the element                         */
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                                 */
/*																			*/
/* return:	  INT Mark: number of refrule									*/
/*																			*/
/****************************************************************************/

static INT MinimalSideEntry (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM];
  INT i,j,k,l,imin;
  COORD Angle[MAX_EDGES_OF_ELEM],Length[MAX_EDGES_OF_ELEM],Max,Min,help;

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* try possebilities */
  Min = MAX_C;
  for (i=0; i<3; i++)
  {
    j = OPPOSITE_EDGE(theElement,i);
    Corners[2] = MidPoints[i];
    Corners[3] = MidPoints[j];

    Max = 0.0;
    for (k=0; k<2; k++)
    {
      for (l=0; l<2; l++)
        Corners[l] = MidPoints[SideEdgesOfEdge[i][k][l]];
      if (TetAngleAndLength(theElement,Corners,Angle,Length))
        return (FULL_REFRULE_0_5);
      for (l=0; l<EDGES_OF_ELEM(theElement); l++)
        if (Angle[l]>PI/2.0)
        {
          help = ABS(Length[l]*(COORD)(cos((double)Angle[l])/sin((double)Angle[l])));
          Max = MAX(Max,help);
        }
    }
    for (k=0; k<2; k++)
    {
      for (l=0; l<2; l++)
        Corners[l] = MidPoints[SideEdgesOfEdge[j][k][l]];
      if (TetAngleAndLength(theElement,Corners,Angle,Length))
        return (FULL_REFRULE_0_5);
      for (i=0; i<EDGES_OF_ELEM(theElement); i++)
        if (Angle[l]>PI/2.0)
        {
          help = ABS(Length[l]*(COORD)(cos((double)Angle[l])/sin((double)Angle[l])));
          Max = MAX(Max,help);
        }
    }
    if (Max<Min)
    {
      Min = Max;
      imin = i;
    }
  }

  switch (imin)
  {
  case 0 :
    return (FULL_REFRULE_0_5);
  case 1 :
    return (FULL_REFRULE_1_3);
  case 2 :
    return (FULL_REFRULE_2_4);
  }
}

/****************************************************************************/
/*																			*/
/* Function:  BestLaplaceMMatrix										    */
/*																			*/
/* Purpose:   compute best full refined refrule for the element:		    */
/*			  optimal laplace-disc w.r.t. M-Matrix eigenschaft				*/
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                             */
/*																			*/
/* return:	  INT Mark: number of refrule								    */
/*																			*/
/****************************************************************************/

static INT BestLaplaceMMatrix (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM];
  INT i,j,k,l,imin,TBFR,refrule;
  COORD Angle[MAX_EDGES_OF_ELEM],Length[MAX_EDGES_OF_ELEM],sum,Min;
  char buffer[64];

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* try possebilities */
  Min = MAX_C; imin = -1;
  for (i=0; i<3; i++)
  {
    j = OPPOSITE_EDGE(theElement,i);
    Corners[2] = MidPoints[i];
    Corners[3] = MidPoints[j];

    sum = 0.0;
    for (k=0; k<2; k++)
    {
      for (l=0; l<2; l++)
        Corners[l] = MidPoints[SideEdgesOfEdge[i][k][l]];
      if (TetAngleAndLength(theElement,Corners,Angle,Length))
        return (FULL_REFRULE_0_5);
      for (l=0; l<EDGES_OF_ELEM(theElement); l++)
        if (Angle[l]>PI/2.0)
          sum += ABS(Length[l]*(COORD)cos((double)Angle[l])/(COORD)sin((double)Angle[l]));
    }
    for (k=0; k<2; k++)
    {
      for (l=0; l<2; l++)
        Corners[l] = MidPoints[SideEdgesOfEdge[j][k][l]];
      if (TetAngleAndLength(theElement,Corners,Angle,Length))
        return (FULL_REFRULE_0_5);
      for (i=0; i<EDGES_OF_ELEM(theElement); i++)
        if (Angle[l]>PI/2.0)
          sum += ABS(Length[l]*(COORD)cos((double)Angle[l])/(COORD)sin((double)Angle[l]));
    }
    if (sum<Min)
    {
      Min = sum;
      imin = i;
    }
  }

  switch (imin)
  {
  case 0 :
    refrule = FULL_REFRULE_0_5;
    break;
  case 1 :
    refrule = FULL_REFRULE_1_3;
    break;
  case 2 :
    refrule = FULL_REFRULE_2_4;
    break;
  }


  TBFR = ShortestInteriorEdge(theElement);
  if (imin == -1)
  {
    refrule = TBFR;
    UserWrite ("#");
  }

  return (refrule);
}

#endif

/****************************************************************************/
/*																			*/
/* Function:  MaxPerpendicular											    */
/*																			*/
/* Purpose:   compute best full refined refrule for the element:		    */
/*			  optimal laplace-disc w.r.t. M-Matrix eigenschaft				*/
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                             */
/*																			*/
/* return:	  INT Mark: number of refrule								    */
/*																			*/
/****************************************************************************/

static INT MaxPerpendicular (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM],a,b,c;
  INT i,j,k,l,imin,TBFR,refrule;
  COORD Angle[MAX_EDGES_OF_ELEM],Length[MAX_EDGES_OF_ELEM],sprd,Max;
  char buffer[64];

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* try possebilities */
  Max = -MAX_C; imin = -1;
  for (i=0; i<3; i++)
  {
    j = OPPOSITE_EDGE(theElement,i);

    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,i,0)],Corners[CORNER_OF_EDGE(theElement,i,1)],a)
    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,j,0)],Corners[CORNER_OF_EDGE(theElement,j,1)],b)
    V3_VECTOR_PRODUCT(a,b,c)
    V3_Normalize(c);
    V3_SUBTRACT(MidPoints[i],MidPoints[j],a)
    V3_Normalize(a);
    V3_SCALAR_PRODUCT(a,c,sprd)
    sprd = ABS(sprd);

    if (sprd>Max)
    {
      Max = sprd;
      imin = i;
    }
  }

  switch (imin)
  {
  case 0 :
    refrule = FULL_REFRULE_0_5;
    break;
  case 1 :
    refrule = FULL_REFRULE_1_3;
    break;
  case 2 :
    refrule = FULL_REFRULE_2_4;
    break;
  }


  TBFR = ShortestInteriorEdge (theElement);
  if (imin == -1)
  {
    refrule = TBFR;
    UserWrite ("#");
  }

  return (refrule);
}

/****************************************************************************/
/*																			*/
/* Function:  MaxRightAngle                                                                                         */
/*																			*/
/* Purpose:   compute best full refined refrule for the element:		    */
/*			  optimal laplace-disc w.r.t. M-Matrix eigenschaft				*/
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                             */
/*																			*/
/* return:	  INT Mark: number of refrule								    */
/*																			*/
/****************************************************************************/

static INT MaxRightAngle (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM],a,b,c;
  INT i,j,k,l,imin,TBFR,refrule;
  COORD Angle[MAX_EDGES_OF_ELEM],Length[MAX_EDGES_OF_ELEM],sprd,Min;
  char buffer[64];

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* try possebilities */
  Min = MAX_C; imin = -1;
  for (i=0; i<3; i++)
  {
    j = OPPOSITE_EDGE(theElement,i);

    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,i,0)],Corners[CORNER_OF_EDGE(theElement,i,1)],a)
    V3_Normalize(a);
    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,j,0)],Corners[CORNER_OF_EDGE(theElement,j,1)],b)
    V3_Normalize(b);
    V3_SCALAR_PRODUCT(a,b,sprd)
    sprd = ABS(sprd);

    if (sprd<Min)
    {
      Min = sprd;
      imin = i;
    }
  }

  switch (imin)
  {
  case 0 :
    refrule = FULL_REFRULE_0_5;
    break;
  case 1 :
    refrule = FULL_REFRULE_1_3;
    break;
  case 2 :
    refrule = FULL_REFRULE_2_4;
    break;
  }


  TBFR = ShortestInteriorEdge (theElement);
  if (imin == -1)
  {
    refrule = TBFR;
    UserWrite ("#");
  }

  return (refrule);
}

/****************************************************************************/
/*																			*/
/* Function:  MaxArea												        */
/*																			*/
/* Purpose:   compute best full refined refrule for the element:		    */
/*			  optimal laplace-disc w.r.t. M-Matrix eigenschaft				*/
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                             */
/*																			*/
/* return:	  INT Mark: number of refrule								    */
/*																			*/
/****************************************************************************/

static INT MaxArea (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM],a,b,c;
  INT i,j,k,l,imin,TBFR,refrule;
  COORD Angle[MAX_EDGES_OF_ELEM],Length[MAX_EDGES_OF_ELEM],norm,Max;
  char buffer[64];

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* try possebilities */
  Max = -MAX_C; imin = -1;
  for (i=0; i<3; i++)
  {
    j = OPPOSITE_EDGE(theElement,i);

    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,i,0)],Corners[CORNER_OF_EDGE(theElement,i,1)],a)
    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,j,0)],Corners[CORNER_OF_EDGE(theElement,j,1)],b)
    V3_VECTOR_PRODUCT(a,b,c)
    V3_EUKLIDNORM(c,norm)

    if (norm>Max)
    {
      Max = norm;
      imin = i;
    }
  }

  switch (imin)
  {
  case 0 :
    refrule = FULL_REFRULE_0_5;
    break;
  case 1 :
    refrule = FULL_REFRULE_1_3;
    break;
  case 2 :
    refrule = FULL_REFRULE_2_4;
    break;
  }


  TBFR = ShortestInteriorEdge (theElement);
  if (imin == -1)
  {
    refrule = TBFR;
    UserWrite ("#");
  }

  return (refrule);
}

/****************************************************************************/
/*																			*/
/* Function:  Alignment														*/
/*																			*/
/* Purpose:   compute best full refined refrule for the element according	*/
/*			  to velocity													*/
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                                 */
/*																			*/
/* return:	  INT Mark: number of refrule									*/
/*																			*/
/****************************************************************************/

static INT Alignment (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM], help, MidPoint;
  DOUBLE_VECTOR Velocity;
  INT i, flags, imax;
  COORD Dist_0_5, Dist_1_3, Dist_2_4, max;

  /* get physical position of the corners */
  V3_CLEAR(MidPoint)
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));
  (*theDirectionElemEval)(theElement,Corners,LMP(CORNERS_OF_ELEM(theElement)),Velocity);

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* compute differences */
  max=-MAX_C;
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
  {
    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,i,0)], Corners[CORNER_OF_EDGE(theElement,i,1)], help)
    V3_Normalize(help);
    if (ABS(Velocity[0]*help[0]+Velocity[1]*help[1]+Velocity[2]*help[2])>max) {imax=i; max=ABS(Velocity[0]*help[0]+Velocity[1]*help[1]+Velocity[2]*help[2]);}
  }
  V3_EUKLIDNORM_OF_DIFF(MidPoints[0], MidPoints[5], Dist_0_5)
  V3_EUKLIDNORM_OF_DIFF(MidPoints[1], MidPoints[3], Dist_1_3)
  V3_EUKLIDNORM_OF_DIFF(MidPoints[2], MidPoints[4], Dist_2_4)
  switch (imax)
  {
  case 0 : if (Dist_1_3<Dist_2_4) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_2_4);
  case 1 : if (Dist_0_5<Dist_2_4) return (FULL_REFRULE_0_5);
    else return (FULL_REFRULE_2_4);
  case 2 : if (Dist_1_3<Dist_0_5) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_0_5);
  case 3 : if (Dist_0_5<Dist_2_4) return (FULL_REFRULE_0_5);
    else return (FULL_REFRULE_2_4);
  case 4 : if (Dist_1_3<Dist_0_5) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_0_5);
  case 5 : if (Dist_1_3<Dist_2_4) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_2_4);
  }
}

/****************************************************************************/
/*																			*/
/* Function:  YAlignment													*/
/*																			*/
/* Purpose:   compute best full refined refrule for the element                         */
/*																			*/
/* Param:	  ELEMENT *theElement: for that element                                                 */
/*																			*/
/* return:	  INT Mark: number of refrule									*/
/*																			*/
/****************************************************************************/

static INT YAlignment (ELEMENT *theElement)
{
  COORD *Corners[MAX_CORNERS_OF_ELEM];
  COORD_VECTOR MidPoints[MAX_EDGES_OF_ELEM], help;
  INT i, flags, imax;
  COORD Dist_0_5, Dist_1_3, Dist_2_4, max;

  /* get physical position of the corners */
  for (i=0; i<CORNERS_OF_ELEM(theElement); i++)
    Corners[i] = CVECT(MYVERTEX(CORNER(theElement,i)));

  /* get physical position of the midpoints of the edges */
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
    V3_LINCOMB(0.5, Corners[CORNER_OF_EDGE(theElement,i,0)], 0.5, Corners[CORNER_OF_EDGE(theElement,i,1)], MidPoints[i]);

  /* compute differences */
  max=-1.0;
  for (i=0; i<EDGES_OF_ELEM(theElement); i++)
  {
    V3_SUBTRACT(Corners[CORNER_OF_EDGE(theElement,i,0)], Corners[CORNER_OF_EDGE(theElement,i,1)], help)
    V3_Normalize(help);
    if (ABS(help[1]+help[2])>max) {imax=i; max=ABS(help[1]+help[2]);}
  }
  V3_EUKLIDNORM_OF_DIFF(MidPoints[0], MidPoints[5], Dist_0_5)
  V3_EUKLIDNORM_OF_DIFF(MidPoints[1], MidPoints[3], Dist_1_3)
  V3_EUKLIDNORM_OF_DIFF(MidPoints[2], MidPoints[4], Dist_2_4)
  switch (imax)
  {
  case 0 : if (Dist_1_3<Dist_2_4) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_2_4);
  case 1 : if (Dist_0_5<Dist_2_4) return (FULL_REFRULE_0_5);
    else return (FULL_REFRULE_2_4);
  case 2 : if (Dist_1_3<Dist_0_5) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_0_5);
  case 3 : if (Dist_0_5<Dist_2_4) return (FULL_REFRULE_0_5);
    else return (FULL_REFRULE_2_4);
  case 4 : if (Dist_1_3<Dist_0_5) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_0_5);
  case 5 : if (Dist_1_3<Dist_2_4) return (FULL_REFRULE_1_3);
    else return (FULL_REFRULE_2_4);
  }
}
#endif /* __THREEDIM__ */

/****************************************************************************/
/*																			*/
/* Function:  MarkForRefinement                                                                                         */
/*																			*/
/* Purpose:   mark an element for refinement								*/
/*																			*/
/* Param:	  ELEMENT *theElement: element to refine						*/
/*			  INT type: type of refinement mark:							*/
/*						REGULAR_MARK										*/
/*																			*/
/* return:	  INT 1: element has been marked								*/
/*				  0: element cannot be marked								*/
/*																			*/
/****************************************************************************/

INT MarkForRefinement (ELEMENT *theElement, INT rule, void *data)
{
  INT side;

  /* regulary refined elements can not be be marked */
  if (REFINECLASS(theElement)==RED) return(GM_ERROR);

  SETCOARSEN(theElement,0);

  /* choose dimension */
  switch (DIM)
  {
                #ifdef __TWODIM__
  /* 2D case */
  case (2) :
    /* TODO: this is ugly, but preserves compatibility */
    side = (INT) data;
    switch (TAG(theElement))
    {
    case (TRIANGLE) :
      switch (rule)
      {
      case UNREFINE :
        SETCOARSEN(theElement,1);
        SETMARK(theElement,NO_REF);
        SETMARKCLASS(theElement,0);
        break;

      case NO_REFINEMENT :
        SETMARK(theElement,NO_REF);
        SETMARKCLASS(theElement,0);
        break;

      case COPY :
        SETMARK(theElement,T_COPY);
        SETMARKCLASS(theElement,RED);
        break;

      case RED :
        SETMARK(theElement,T_RED);
        SETMARKCLASS(theElement,RED);
        break;

      /* TODO: these marks must be introduced first
         case BISECTION_3:
              if (side<0) return (GM_ERROR);
              SETMARK(theElement,TRI_BISECT_3+side%3);
              SETMARKCLASS(theElement,RED);
              break;

         case BISECTION_1:
              if (side<0) return (GM_ERROR);
              SETMARK(theElement,TRI_BISECT_1+side%3);
              SETMARKCLASS(theElement,RED);
              break;

         case BISECTION_2_Q:
              if (side<0) return (GM_ERROR);
              SETMARK(theElement,TRI_BISECT_2_Q+side%3);
              SETMARKCLASS(theElement,RED);
              break;

         case BISECTION_2_T1:
              if (side<0) return (GM_ERROR);
              SETMARK(theElement,TRI_BISECT_2_T1+side%3);
              SETMARKCLASS(theElement,RED);
              break;

         case BISECTION_2_T2:
              if (side<0) return (GM_ERROR);
              SETMARK(theElement,TRI_BISECT_2_T2+side%3);
              SETMARKCLASS(theElement,RED);
              break;
       */

      default :
        return(GM_ERROR);
      }
      break;

    case (QUADRILATERAL) :
      switch (rule)
      {
      case UNREFINE :
        SETCOARSEN(theElement,1);
        SETMARK(theElement,NO_REF);
        break;

      case NO_REFINEMENT :
        SETMARK(theElement,NO_REF);
        break;

      case COPY :
        SETMARK(theElement,Q_COPY);
        SETMARKCLASS(theElement,RED);
        break;

      case RED :
        SETMARK(theElement,Q_RED);
        SETMARKCLASS(theElement,RED);
        break;

      /* TODO: these mark must be introduced first */
      case BLUE :
        if (side<0) return (GM_ERROR);
        if (side%2 == 0)
          SETMARK(theElement,Q_BLUE_0);
        else
          SETMARK(theElement,Q_BLUE_1);
        SETMARKCLASS(theElement,RED);
        break;

      default :
        return(GM_ERROR);
      }
      break;

    default :
      return(GM_ERROR);
    }
    break;
                        #endif /* __TWODIM__ */


                #ifdef __THREEDIM__
  /* 3D case */
  case (3) :
    switch (TAG(theElement))
    {
    case (TETRAHEDRON) :
      switch(rule)
      {
      case (UNREFINE) :
        SETMARK(theElement,NO_REF);
        SETCOARSEN(theElement,1);
        break;
      case (NO_REFINEMENT) :
        SETMARK(theElement,NO_REF);
        break;
      case (COPY) :
        SETMARK(theElement,TET_COPY);
        SETMARKCLASS(theElement,RED);
        break;
      case (RED) :
        SETMARK(theElement,(*theFullRefRule)(theElement));
        SETMARKCLASS(theElement,RED);
        break;
      default :
        return(GM_ERROR);
      }
      break;

    case (PYRAMID) :
      switch(rule)
      {
      case (UNREFINE) :
        SETMARK(theElement,NO_REF);
        SETCOARSEN(theElement,1);
        break;
      case (NO_REFINEMENT) :
        SETMARK(theElement,NO_REF);
        break;
      case (COPY) :
        SETMARK(theElement,PYR_COPY);
        SETMARKCLASS(theElement,RED);
        break;
      case (RED) :
        SETMARK(theElement,PYR_RED);
        SETMARKCLASS(theElement,RED);
        break;
      default :
        return(GM_ERROR);
      }
      break;

    case (HEXAHEDRON) :
      switch(rule)
      {
      case (UNREFINE) :
        SETMARK(theElement,NO_REF);
        SETCOARSEN(theElement,1);
        break;
      case (NO_REFINEMENT) :
        SETMARK(theElement,NO_REF);
        break;
      case (COPY) :
        SETMARK(theElement,HEXA_COPY);
        SETMARKCLASS(theElement,RED);
        break;
      case (RED) :
        SETMARK(theElement,HEXA_RED);
        SETMARKCLASS(theElement,RED);
        break;
      default :
        return(GM_ERROR);
      }
      break;

    default :
      return(GM_ERROR);
    }
    break;
                        #endif /* __THREEDIM__ */

  default :
    return(GM_ERROR);
  }

  return(GM_OK);
}


/****************************************************************************/
/*																			*/
/* Function:  EstimateHere													*/
/*																			*/
/* Purpose:   return true (1) when element can be tagged for refinement         */
/*																			*/
/* Param:	  ELEMENT *theElement: element to refine						*/
/*																			*/
/* return:	  false: do not tag element                                                                     */
/*			  true:  element can be tagged for refinement					*/
/*																			*/
/****************************************************************************/

INT EstimateHere (ELEMENT *theElement)
{
  return(LEAFELEM(theElement));
}


/****************************************************************************/
/*																			*/
/* Function:  Patterns2Rules												*/
/*																			*/
/* Purpose:   return mark of rule for a specific pattern                                        */
/*																			*/
/* Param:	  ELEMENT * theElement: element rule is searches for			*/
/*			  int pattern: pattern a rule is searched for					*/
/*																			*/
/* return:	  INT: mark of rule												*/
/*																			*/
/****************************************************************************/

INT Patterns2Rules(ELEMENT *theElement, INT pattern)
{
        #ifdef __TWODIM__
  switch (TAG(theElement)) {
  case (TRIANGLE) :
    switch (pattern) {
    /* TODO: 0 can mean T_COPY OR T_NOREF */
    case (0) : return(T_NOREF);
    case (1) : return(T_BISECT_1_0);
    case (2) : return(T_BISECT_1_1);
    case (3) : return(T_BISECT_2_T1_2);
    case (4) : return(T_BISECT_1_2);
    case (5) : return(T_BISECT_2_T1_1);
    case (6) : return(T_BISECT_2_T1_0);
    case (7) : return(T_RED);
    default :
      assert(0);
      PrintErrorMessage('E',"Patterns2Rules","no mapping for TRIANGLE and this pattern!");
      return(-1);
    }
    break;
  case (QUADRILATERAL) :
    switch (pattern) {
    /* TODO: 0 can mean Q_COPY OR Q_NOREF */
    case (0) : return(Q_NOREF);
    case (5) : return(Q_BLUE_0);
    case (7) : return(Q_CLOSE_3_3);
    case (10) : return(Q_BLUE_1);
    case (11) : return(Q_CLOSE_3_2);
    case (13) : return(Q_CLOSE_3_1);
    case (14) : return(Q_CLOSE_3_0);

    case (1) :                                    /* mapping for green closure */
    case (17) : return(Q_CLOSE_2_0);

    case (2) :                                    /* mapping for green closure */
    case (18) : return(Q_CLOSE_2_1);

    case (3) :                                    /* mapping for green closure */
    case (19) : return(Q_CLOSE_1_0);

    case (4) :                                    /* mapping for green closure */
    case (20) : return(Q_CLOSE_2_2);

    case (6) :                                    /* mapping for green closure */
    case (22) : return(Q_CLOSE_1_1);

    case (8) :                                    /* mapping for green closure */
    case (24) : return(Q_CLOSE_2_3);

    case (9) :                                    /* mapping for green closure */
    case (25) : return(Q_CLOSE_1_3);

    case (12) :                                    /* mapping for green closure */
    case (28) : return(Q_CLOSE_1_2);

    case (15) :                                    /* mapping for green closure */
    case (31) : return(Q_RED);
    default :
      assert(0);
      PrintErrorMessage('E',"Patterns2Rules","no mapping for QUADRILATERAL and this pattern!");
      return(-1);
    }
    break;
  default :
    PrintErrorMessage('E',"Patterns2Rules","Elementtype not found!");
    return(-1);
  }
        #endif
        #ifdef __THREEDIM__
  switch (TAG(theElement)) {
  case (TETRAHEDRON) :
    return(Pattern2Rule[TAG(theElement)][pattern]);

  case (PYRAMID) :
    if (MARKCLASS(theElement) == RED) return(-1);

    /* no further red or green refinement of pyramid so far */
    return(0);

    switch (pattern) {
    /* copy rule */
    case (0) :
      return(0);
    default :
      PrintErrorMessage('E',"Patterns2Rules","no mapping for PYRAMID and this pattern!");
      return(-1);
    }
    break;

  case (HEXAHEDRON) :
    if (MARKCLASS(theElement) != RED) return(0);
    switch (pattern) {
    /* copy rule */
    case (0) :
      return(0);

    /* full red rule */
    case (262143) :
      return(HEXA_RED);
    default :
      PrintErrorMessage('E',"Patterns2Rules","no mapping for HEXAHEDRON and this pattern!");
      UserWriteF("pattern=%d\n",pattern);
      return(-1);
    }
    break;

  default :
    PrintErrorMessage('E',"Patterns2Rules","Elementtype not found!");
    return(-1);
  }
        #endif
  PrintErrorMessage('E',"Patterns2Rules","Elementtype not found!");
  return(-1);
}

/****************************************************************************/
/*																			*/
/* Function:  GetRefinementMark                                                                                         */
/*																			*/
/* Purpose:   gets rule of refinement										*/
/*																			*/
/* Param:	  ELEMENT *theElement: element to refine						*/
/*			  int *rule: filled with current refinement rule				*/
/*			  int *side: filled with side, if rule is oriented				*/
/*																			*/
/* return:	  int 0: side information valid                                                                 */
/*			  int 1: rule without orientation								*/
/*																			*/
/****************************************************************************/

INT GetRefinementMark (const ELEMENT *theElement, INT *rule, void *data)
{
  INT *side = data;

  if (MARK(theElement)==FULL_REFRULE) {*rule=RED; return(GM_RULE_WITHOUT_ORIENTATION);}
  switch (MARK(theElement))
  {
  case NO_REFINEMENT :
    *rule=NO_REFINEMENT;
    if (COARSEN(theElement)) *rule = UNREFINE;
    break;
  case COPY : *rule=COPY; break;
  default : *rule=NO_REFINEMENT;  break;
  }
  *side=0;
  return(GM_RULE_WITHOUT_ORIENTATION);
}


/****************************************************************************/
/*																			*/
/* Function:  ShowRefRule													*/
/*																			*/
/* Purpose:   fill SonList for theElement									*/
/*																			*/
/* Param:	  ELEMENT *theElement, ELEMENT *SonList[MAX_SONS]				*/
/*																			*/
/* return:	  0: ok                                                                                                                 */
/*			  1: error														*/
/*																			*/
/****************************************************************************/

static INT PrintEdgeData (struct edgedata theEdgeData)
{
  char buffer[128];

  sprintf(buffer,"typ=%d from=%2d to=%2d side=%d",(int)theEdgeData.type
          ,(int)theEdgeData.from
          ,(int)theEdgeData.to
          ,(int)theEdgeData.side);
  UserWrite(buffer);
  return(0);
}

static INT PrintSonData(struct sondata theSonData)
{
  char buffer[128];
  int i,j;

  sprintf(buffer,"tag=%d ",(int)theSonData.tag);

  j = 0;
  j = sprintf(buffer," corners=");
  for (i=0; i<element_descriptors[theSonData.tag]->corners_of_elem; i++)
  {
    j += sprintf(buffer+j,"%2d ",(int)theSonData.corners[i]);
  }
  UserWrite(buffer);

  j = 0;
  j += sprintf(buffer,"  nb=");
  for (i=0; i<element_descriptors[theSonData.tag]->sides_of_elem; i++)
  {
    j += sprintf(buffer+j,"%2d ",(int)theSonData.nb[i]);
  }
  UserWrite(buffer);

  sprintf(buffer,"  path=");
  UserWrite(buffer);
  for (i=8*sizeof(INT)-1; i>=0; i--)
  {
    sprintf(buffer,"%d",(int)((theSonData.path>>i) & 0x1));
    if (i%2 == 0 && theSonData.tag == TETRAHEDRON) sprintf(buffer+1," ");
    if (i%3 == 0 && theSonData.tag == HEXAHEDRON) sprintf(buffer+1," ");
    UserWrite(buffer);
  }

  return(0);
}

INT ShowRefRule (INT tag, INT nb)
{
  char buffer[128];
  INT i,j;
  REFRULE *theRule;

  if (MaxRules[tag]<=nb)
  {
    UserWriteF("ShowRefRule(): ERROR: nb=%d but MaxRules[%d]=%d\n",nb,tag,MaxRules[tag]);
    return (1);
  }

  theRule=&(RefRules[tag][nb]);

  /* header */
  UserWrite("\n");
  sprintf(buffer,"RefRule %3d:\n",nb);
  UserWrite(buffer);

  /* nsons, mark and class */
  sprintf(buffer,"   tag=%d mark=%3d class=%2d, nsons=%d\n",(int)theRule->tag,(int)theRule->mark,(int)theRule->class,(int)theRule->nsons);
  UserWrite(buffer);

  /* pattern */
  UserWrite("   pattern= ");
  for (i=0; i<(element_descriptors[tag]->edges_of_elem+element_descriptors[tag]->sides_of_elem+1); i++)
  {
    sprintf(buffer,"%2d ",(int)theRule->pattern[i]);
    UserWrite(buffer);
  }
  UserWrite("\n");

  /* pat */
  UserWrite("   pat    = ");
  for (i=0; i<(element_descriptors[tag]->edges_of_elem+element_descriptors[tag]->sides_of_elem+1); i++)
  {
    sprintf(buffer,"%2d ",(int)((theRule->pat>>i) & 0x1));
    UserWrite(buffer);
  }
  UserWrite("\n");

  /* sonandnode */
  for (i=0; i<MAX_NEW_CORNERS(tag); i++)
  {
    sprintf(buffer,"   newnode %2d: sonandnode[%2d][0]=%d",i,i,(int)theRule->sonandnode[i][0]);
    UserWrite(buffer);
    sprintf(buffer,"  [%2d][1]=%d\n",i,(int)theRule->sonandnode[i][1]);
    UserWrite(buffer);
  }
  UserWrite("\n");

  /* print edge data */
  UserWrite("   Edge data\n");
  for (i=0; i<MAX_NEW_EDGES(tag); i++)
  {
    sprintf(buffer,"      e %2d: ",i);
    UserWrite(buffer);
    PrintEdgeData(theRule->edges[i]);
    if (i%2 == 1) UserWrite("\n");
  }
  UserWrite("\n");

  /* print sondata data */
  UserWrite("   Son data\n");
  for (i=0; i<(int)theRule->nsons; i++)
  {
    sprintf(buffer,"      son %2d: ",i);
    UserWrite(buffer);
    PrintSonData(theRule->sons[i]);
    UserWrite("\n");
  }

  return (0);
}

/****************************************************************************/
/*																			*/
/* Function:  FReadRule														*/
/*																			*/
/* Purpose:   Read the rule data set and initialize the rules data                      */
/*																			*/
/* Input:	  FILE *stream: file which stores rules							*/
/*			  REFRULE *theRule: pointer to rule structure                                   */
/*																			*/
/* Output:	  INT															*/
/*				 0: ok														*/
/*				>0: error													*/
/*																			*/
/****************************************************************************/

static int FReadRule (FILE *stream, REFRULE *theRule)
{
  int i;
  int ns,p0,p1,p2,p3,p4,p5,pat;
  int type,from,to,side;
  int c0,c1,c2,c3,n0,n1,n2,n3,pa;
  int sn0,sn1;

  /* init tag */
  theRule->tag = TETRAHEDRON;

  if (fscanf(stream,"%d  %d %d %d %d %d %d  %d",&ns,&p0,&p1,&p2,&p3,&p4,&p5,&pat)!=8) return (1);

  theRule->nsons = ns;
  theRule->pattern[0] = p0;
  theRule->pattern[1] = p1;
  theRule->pattern[2] = p2;
  theRule->pattern[3] = p3;
  theRule->pattern[4] = p4;
  theRule->pattern[5] = p5;
  theRule->pat = pat;

  /* MAXEDGES = 16 for tetrahedra */
  for (i=0; i<16; i++)
  {
    if (fscanf(stream," %d %d %d %d",&type,&from,&to,&side)!=4) return (1);
    theRule->edges[i].type = type;
    theRule->edges[i].from = from;
    theRule->edges[i].to   = to;
    theRule->edges[i].side = side;
  }

  /* MAX_SONS = 12 for tetrahedra */
  for (i=0; i<12; i++)
  {
    if (fscanf(stream," %d %d %d %d %d %d %d %d %d",&c0,&c1,&c2,&c3,&n0,&n1,&n2,&n3,&pa)!=9) return (1);
    theRule->sons[i].tag = TETRAHEDRON;
    theRule->sons[i].corners[0] = c0;
    theRule->sons[i].corners[1] = c1;
    theRule->sons[i].corners[2] = c2;
    theRule->sons[i].corners[3] = c3;
    theRule->sons[i].nb[0]          = n0;
    theRule->sons[i].nb[1]          = n1;
    theRule->sons[i].nb[2]          = n2;
    theRule->sons[i].nb[3]          = n3;
    theRule->sons[i].path           = pa;
  }

  /* NEWCORNERS = 7 for tetrahedra */
  /* read edge node information */
  for (i=0; i<6; i++)
  {
    if (fscanf(stream," %d %d",&sn0,&sn1)!=2) return (1);
    theRule->sonandnode[i][0] = sn0;
    theRule->sonandnode[i][1] = sn1;
  }
  /* read center node information */
  if (fscanf(stream," %d %d",&sn0,&sn1)!=2) return (1);
  theRule->sonandnode[10][0] = sn0;
  theRule->sonandnode[10][1] = sn1;

  /* init Pattern and pat for center node */
  if (theRule->sonandnode[10][0] != NO_CENTER_NODE)
  {
    theRule->pattern[10] = 1;
    theRule->pat |= (1<<10);
  }

  return (0);
}

/****************************************************************************/
/*																			*/
/* Function:  InitRuleManager3D												*/
/*																			*/
/* Purpose:   Read the rule data set and initialize the rules data                      */
/*            structure for tetrahedrons. Initialize the regular refinement */
/*            rules (red rules) for hexahedrons. Irregular refinement of    */
/*			  green closure is done algorithmically.						*/
/*																			*/
/* Input:	  void															*/
/*																			*/
/* Output:	  INT															*/
/*				 0: ok														*/
/*				>0: error													*/
/*																			*/
/****************************************************************************/

#ifdef __THREEDIM__
INT InitRuleManager3D (void)
{
  int nRules, nPatterns, err, i, P2R;
  FILE *stream;
  FULLREFRULE *newFRR;
  REFRULE *Rules;
  char buffer[256];

  /************************************************************************/
  /*																		*/
  /* read refinement rules from for tetrahedrons file 'RefRules.data'		*/
  /*																		*/
  /************************************************************************/

  /* open file */
  if (GetDefaultValue(DEFAULTSFILENAME,"refrulefile",buffer)==0)
    stream = fileopen(buffer,"r");
  else
    stream = fileopen("RefRules.data","r");
  if (stream==NULL)
  {
    UserWrite("ERROR: could not open file 'RefRules.data'\n");
    fclose(stream);
    return (__LINE__);
  }

  /* read Rules and nPatterns from file */
  if (fscanf(stream,"%d %d\n",&nRules,&nPatterns)!=2)
  {
    UserWrite("ERROR: failed to read Rules and nPatterns\n");
    fclose(stream);
    return (__LINE__);
  }

  /* get storage for Rules */
  Rules = (REFRULE *) malloc(nRules*sizeof(REFRULE));
  if (Rules==NULL)
  {
    UserWrite("ERROR: no storage for Rules\n");
    fclose(stream);
    return (__LINE__);
  }

  /* get storage for Pattern2Rule */
  Pattern2Rule[TETRAHEDRON] = (SHORT *) malloc(nPatterns*sizeof(SHORT));
  if (Pattern2Rule[TETRAHEDRON]==NULL)
  {
    UserWrite("ERROR: no storage for Pattern2Rule\n");
    fclose(stream);
    return (__LINE__);
  }
  for (i=0; i<nPatterns; i++) Pattern2Rule[TETRAHEDRON][i] = -1;

  /* read Rules */
  for (i=0; i<nRules; i++)
  {
    Rules[i] = Empty_Rule;
    Rules[i].mark = i;
    Rules[i].class = REGULAR_CLASS|IRREGULAR_CLASS;
    if (FReadRule(stream,Rules+i)) return (__LINE__);
  }

  /* read Pattern2Rule */
  for (i=0; i<nPatterns; i++)
  {
    if (fscanf(stream,"%d",&P2R)!=1) return (__LINE__);
    Pattern2Rule[TETRAHEDRON][i] = P2R;
  }

  fclose(stream);

  /* now make rules for tetrahedrons globally available */
  MaxRules[TETRAHEDRON] = nRules;
  MaxNewCorners[TETRAHEDRON] = 11;
  MaxNewEdges[TETRAHEDRON] = 16;
  CenterNodeIndex[TETRAHEDRON] = 10;
  RefRules[TETRAHEDRON] = Rules;


  /************************************************************************/
  /*																		*/
  /*  init refinement rules from for pyramids                           */
  /*																		*/
  /************************************************************************/

  nRules = nPatterns = 2;

  /* make rules for tetrahedrons globally available */
  MaxRules[PYRAMID] = nRules;
  MaxNewCorners[PYRAMID] = 19;
  MaxNewEdges[PYRAMID] = 54;
  CenterNodeIndex[PYRAMID] = 18;
  RefRules[PYRAMID] = PyramidRules;

  /************************************************************************/
  /*																		*/
  /*  init refinement rules from for hexahedrons                        */
  /*																		*/
  /************************************************************************/

  /* make rules for tetrahedrons globally available */
  MaxRules[HEXAHEDRON] = nRules;
  MaxNewCorners[HEXAHEDRON] = 19;
  MaxNewEdges[HEXAHEDRON] = 54;
  CenterNodeIndex[HEXAHEDRON] = 18;
  RefRules[HEXAHEDRON] = HexahedronRules;


  /************************************************************************/
  /*																		*/
  /* install best full refrules for tetrahedrons							*/
  /*																		*/
  /************************************************************************/

  /* install the /Menu directory */
  if (ChangeEnvDir("/")==NULL)
  {
    PrintErrorMessage('F',"InitRuleManager3D","could not changedir to root");
    return(__LINE__);
  }
  theBFRRDirID = GetNewEnvDirID();
  if (MakeEnvItem("best full refrule",theBFRRDirID,sizeof(ENVDIR))==NULL)
  {
    PrintErrorMessage('F',"InitRuleManager3D","could not install '/best full refrule' dir");
    return(__LINE__);
  }
  if (ChangeEnvDir("/best full refrule")==NULL)
    return(__LINE__);

  newFRR = (FULLREFRULE *) MakeEnvItem("shortestie",theBFRRDirID,sizeof(FULLREFRULE));
  if (newFRR==NULL)
    return(__LINE__);
  newFRR->theFullRefRule = ShortestInteriorEdge;

  newFRR = (FULLREFRULE *) MakeEnvItem("maxper",theBFRRDirID,sizeof(FULLREFRULE));
  if (newFRR==NULL)
    return(__LINE__);
  newFRR->theFullRefRule = MaxPerpendicular;

  newFRR = (FULLREFRULE *) MakeEnvItem("mra",theBFRRDirID,sizeof(FULLREFRULE));
  if (newFRR==NULL)
    return(__LINE__);
  newFRR->theFullRefRule = MaxRightAngle;

  newFRR = (FULLREFRULE *) MakeEnvItem("maxarea",theBFRRDirID,sizeof(FULLREFRULE));
  if (newFRR==NULL)
    return(__LINE__);
  newFRR->theFullRefRule = MaxArea;

#ifdef __ALLRULES__
  newFRR = (FULLREFRULE *) MakeEnvItem("minangle",theBFRRDirID,sizeof(FULLREFRULE));
  if (newFRR==NULL)
    return(__LINE__);
  newFRR->theFullRefRule = MinimalSideAngle;

  newFRR = (FULLREFRULE *) MakeEnvItem("bestm",theBFRRDirID,sizeof(FULLREFRULE));
  if (newFRR==NULL)
    return(__LINE__);
  newFRR->theFullRefRule = BestLaplaceMMatrix;

  newFRR = (FULLREFRULE *) MakeEnvItem("minentry",theBFRRDirID,sizeof(FULLREFRULE));
  if (newFRR==NULL)
    return(__LINE__);
  newFRR->theFullRefRule = MinimalSideEntry;
#endif

  /* default full refrule */
  theFullRefRule = ShortestInteriorEdge;

  UserWrite("3D RefRules installed\n");

  return (GM_OK);
}

INT SetAlignementPtr (MULTIGRID *theMG, EVECTOR *direction)
{
  if (direction != NULL)
  {
    if ((*(direction->PreprocessProc))(ENVITEM_NAME(direction),theMG)) return(1);
    theDirectionElemEval = direction->EvalProc;
    theFullRefRule = Alignment;
  }
  else
    theFullRefRule = ShortestInteriorEdge;

  return(0);
}

#endif /* __THREEDIM__ */


/****************************************************************************/
/*																			*/
/* Function:  InitRuleManager2D												*/
/*																			*/
/* Purpose:   Initializes rules for triangles and quadrilaterals                */
/*																			*/
/* Input:	  void															*/
/*																			*/
/* Output:	  INT															*/
/*				 0: ok														*/
/*				>0: error													*/
/*																			*/
/****************************************************************************/

#ifdef __TWODIM__
INT InitRuleManager2D (void)
{
  int nRules, nPatterns, err, i, P2R;

  /************************************************************************/
  /*																		*/
  /*  init refinement rules for triangles                                       */
  /*																		*/
  /************************************************************************/

  /* get storage for Pattern2Rule */
  nPatterns = 17;       /* there are 2^3 different patterns */
  /* TODO: delete all concerning Pattern2Rule */
  Pattern2Rule[TRIANGLE] = (SHORT *) malloc(nPatterns*sizeof(SHORT));
  if (Pattern2Rule[TRIANGLE]==NULL)
  {
    UserWrite("ERROR: no storage for Pattern2Rule\n");
    return (__LINE__);
  }

  /* Pattern2Rule gives the starting index for rules with same pattern */
  Pattern2Rule[TRIANGLE][0] = T_COPY;                           /* 0 0 0 */
  Pattern2Rule[TRIANGLE][1] = T_BISECT_1_0;             /* 0 0 1 */
  Pattern2Rule[TRIANGLE][2] = T_BISECT_1_1;             /* 0 1 0 */
  Pattern2Rule[TRIANGLE][3] = T_BISECT_2_T1_0;          /* 0 1 1 */
  Pattern2Rule[TRIANGLE][4] = T_BISECT_1_2;                     /* 1 0 0 */
  Pattern2Rule[TRIANGLE][5] = NOINDEX;                  /* 1 0 1 */
  Pattern2Rule[TRIANGLE][6] = NOINDEX;                  /* 1 1 0 */
  Pattern2Rule[TRIANGLE][7] = T_RED;                            /* 1 1 1 */

  /* now make rules for tetrahedrons globally available */
  MaxRules[TRIANGLE] = 17;
  MaxNewCorners[TRIANGLE] = 3;
  MaxNewEdges[TRIANGLE] = 9;
  CenterNodeIndex[TRIANGLE] = 4;
  RefRules[TRIANGLE] = TriangleRules;


  /************************************************************************/
  /*																		*/
  /*  init refinement rules for quadrilaterals                          */
  /*																		*/
  /************************************************************************/

  /* get storage for Pattern2Rule */
  nPatterns = 32;       /* there are 2^5 different patterns */
  /* TODO: delete all concerning Pattern2Rule */
  Pattern2Rule[QUADRILATERAL] = (SHORT *) malloc(nPatterns*sizeof(SHORT));
  if (Pattern2Rule[QUADRILATERAL]==NULL)
  {
    UserWrite("ERROR: no storage for Pattern2Rule\n");
    return (__LINE__);
  }

  /* Pattern2Rule gives the starting index for rules with same pattern */
  Pattern2Rule[QUADRILATERAL][ 0] = NOINDEX;                    /* 0 0 0 0 0 */
  Pattern2Rule[QUADRILATERAL][ 1] = NOINDEX;                    /* 0 0 0 0 1 */
  Pattern2Rule[QUADRILATERAL][ 2] = NOINDEX;                    /* 0 0 0 1 0 */
  Pattern2Rule[QUADRILATERAL][ 3] = NOINDEX;                    /* 0 0 0 1 1 */
  Pattern2Rule[QUADRILATERAL][ 4] = NOINDEX;                    /* 0 0 1 0 0 */
  Pattern2Rule[QUADRILATERAL][ 5] = NOINDEX;                    /* 0 0 1 0 1 */
  Pattern2Rule[QUADRILATERAL][ 6] = NOINDEX;                    /* 0 0 1 1 0 */
  Pattern2Rule[QUADRILATERAL][ 7] = NOINDEX;                    /* 0 0 1 1 1 */
  Pattern2Rule[QUADRILATERAL][ 8] = NOINDEX;                    /* 0 1 0 0 0 */
  Pattern2Rule[QUADRILATERAL][ 9] = NOINDEX;                    /* 0 1 0 0 1 */
  Pattern2Rule[QUADRILATERAL][10] = NOINDEX;                    /* 0 1 0 1 0 */
  Pattern2Rule[QUADRILATERAL][11] = NOINDEX;                    /* 0 1 0 1 1 */
  Pattern2Rule[QUADRILATERAL][12] = NOINDEX;                    /* 0 1 1 0 0 */
  Pattern2Rule[QUADRILATERAL][13] = NOINDEX;                    /* 0 1 1 0 1 */
  Pattern2Rule[QUADRILATERAL][14] = NOINDEX;                    /* 0 1 1 1 0 */
  Pattern2Rule[QUADRILATERAL][15] = NOINDEX;                    /* 0 1 1 1 1 */
  Pattern2Rule[QUADRILATERAL][16] = NOINDEX;                    /* 1 0 0 0 0 */
  Pattern2Rule[QUADRILATERAL][17] = NOINDEX;                    /* 1 0 0 0 1 */
  Pattern2Rule[QUADRILATERAL][18] = NOINDEX;                    /* 1 0 0 1 0 */
  Pattern2Rule[QUADRILATERAL][19] = NOINDEX;                    /* 1 0 0 1 1 */
  Pattern2Rule[QUADRILATERAL][20] = NOINDEX;                    /* 1 0 1 0 0 */
  Pattern2Rule[QUADRILATERAL][21] = NOINDEX;                    /* 1 0 1 0 1 */
  Pattern2Rule[QUADRILATERAL][22] = NOINDEX;                    /* 1 0 1 1 0 */
  Pattern2Rule[QUADRILATERAL][23] = NOINDEX;                    /* 1 0 1 1 1 */
  Pattern2Rule[QUADRILATERAL][24] = NOINDEX;                    /* 1 1 0 0 0 */
  Pattern2Rule[QUADRILATERAL][25] = NOINDEX;                    /* 1 1 0 0 1 */
  Pattern2Rule[QUADRILATERAL][26] = NOINDEX;                    /* 1 1 0 1 0 */
  Pattern2Rule[QUADRILATERAL][27] = NOINDEX;                    /* 1 1 0 1 1 */
  Pattern2Rule[QUADRILATERAL][28] = NOINDEX;                    /* 1 1 1 0 0 */
  Pattern2Rule[QUADRILATERAL][29] = NOINDEX;                    /* 1 1 1 0 1 */
  Pattern2Rule[QUADRILATERAL][30] = NOINDEX;                    /* 1 1 1 1 0 */
  Pattern2Rule[QUADRILATERAL][31] = Q_RED;                      /* 1 1 1 1 1 */

  /* now make rules for tetrahedrons globally available */
  MaxRules[QUADRILATERAL] = 16;
  MaxNewCorners[QUADRILATERAL] = 4;
  MaxNewEdges[QUADRILATERAL] = 12;
  CenterNodeIndex[QUADRILATERAL] = 4;
  RefRules[QUADRILATERAL] = QuadrilateralRules;

  return (GM_OK);
}
#endif /* __TWODIM__ */


/****************************************************************************/
/*																			*/
/* Function:  InitRuleManager												*/
/*																			*/
/* Purpose:	  Initialize the 2- or 3D rule set								*/
/*																			*/
/* Input:	  void															*/
/*																			*/
/* Output:																	*/
/*																			*/
/*																			*/
/****************************************************************************/

INT InitRuleManager (void)
{
  INT err;

  /* init 2- or 3D rulemanager */
  if ((err=CONCAT3(InitRuleManager,DIM,D) ()) != GM_OK)
  {
    SetHiWrd(err,__LINE__);
    return(err);;
  }
}
