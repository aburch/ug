/*D

DATASTRUCTURE - Overview of UGs data structures

DESCRIPTION:

This page will give an overview of the data types defined in UG 
that are used to represent meshes and geometries. All data types discussed here are 
defined in the header file '/ug3/ug/gm/gm.h' of the grid manager module.
A description of the individual data types can be found in 
seperate pages for each data type. UGs data structure is very flexible
and covers two- and threedimensional elements and a general sparse
matrix structure. You can have different numbers of degrees of freedom 
in nodes, edges, sides
and elements of a three-dimensional mesh. Therefore the data structure
can be used e.g. also for non-conforming or mixed finite element discretizations.
To structure the data you can group vectors by using 'BLOCKVECTOR's; this
yields blockmatrices too.

UGs refinement module can refine and coarsen a given mesh structure. In
order to do that it needs a complete description of the geometry of the
domain. For full flexibility, the geometry is defined by patches, which are
mappings from a d-1 dimensional parameter space to d dimensional euclidean space.

If we imagine a three-dimensional mesh we can identify a hierarchy of 
geometrical objects like `elements, sides, edges` and `nodes`.
By element we mean just a simple geometric shape like
a triangle, a quadrilateral, a tetrahedron or a hexahedron. In our notation the element
does not include the number of degrees of freedom or the definition of the shape functions
as it is common in the Finite Element context. A side is meant to be a face of an element, that
is a d-1 dimensional object if we have a mesh in d dimensions (d=2,3). An edge is a connection
of two nodes, i.~e. a one-dimensional object and a node is a point in space (as far as geometry
is concerned). Note that in two space dimensions sides coincide with edges, or we can say that
a side consists of one edge and two nodes in that case.

The TeX version of this page contains a graphical representation of the data 
structure.

Size limitations of the data structure are described in a seperate page 'LIMITS'.

All data types have names with uppercase letters. Now we give a brief description
of all data types for which a seperate page is provided.

. DOMAIN - Structure that describes a two- or threedimensional domain.

. BOUNDARY_SEGMENT - A 'DOMAIN' is constructed from several 'BOUNDARY_SEGMENT' objects.
UG can handle also `internal` boundaries, e.g. for material interfaces.

. PROBLEM - Stores references to user defined coefficient functions. The purpose
of these functions depends on the problem class library. A problem corresponds 
to a 'DOMAIN' and provides a 'BOUNDARY_CONDITION' for each 'BOUNDARY_SEGMENT'
besides the coefficient functions. There may be several problems defined on a domain.

. BOUNDARY_CONDITION - For each 'BOUNDARY_SEGMENT' a corresponding 'BOUNDARY_CONDITION'
object must be allocated.

. FORMAT - This structure parametrizes the data structure. The format determines
the layout of the sparse matrix data structure and how it is determined from
the mesh data. 

. ELEMENT - UGs data structure is element oriented, so this is the basic data
type from which other objects can be reached locally. The variable element
concept allows several element types (e.g. triangles and quadrilaterals) in one mesh.
Elements give you access to the corresponding nodes and to neighboring elements.

. ELEMENTSIDE - When a side of an element is part of the external or internal
boundary of the domain, this side has a corresponding 'ELEMENTSIDE' object
describing the position on the boundary.

. BNDSEGDESC - Combines pointers to 'BOUNDARY_SEGMENT' and 'BOUNDARY_CONDITION'
in order to save memory.a

. NODE - Corners of the elements are described by the 'NODE' structure. Only the
information that is different per level is stored here. E.g. geometric information 
for a node e.g. is stored only once in a 'VERTEX' object. Several 'NODE' objects share
share one 'VERTEX' if they are at the same position on different levels.

. VERTEX - Geometric data of a 'NODE'. This contains x,y (,z), i.e global
coordinates, the position in the coarser grid level (local coordinates) and
boundary information if the node is on the boundary (see 'VSEGMENT').

. VSEGMENT - A vertex can reside on several boundary segments, especially when
internal boundaries are defined. Therefore it stores a list of 'VSEGMENT'
structures, one for each position on a boundary segment.

. LINK - The mesh structure implies a neighbor relationship on the 'NODE'
objects (the `mesh graph`). 
Since the mesh is unstructured a linked list must be used to provide
references to all neighbors. The 'LINK' data type forms that list and each
'LINK' object represents one neighbor.

. EDGE - The 'LINK' structure represents a directed edge of the mesh graph from
some node `a` to node `b`. The 'LINK' from node `b` to node `a` must always exist
since the neighbor relation is symmetric and therefore the two 'LINK' objects
are combined to form an 'EDGE' object.

. GEOM_OBJECT - This is an union of 'ELEMENT', 'NODE' and 'EDGE', the basic
geometric objects.

. VECTOR - This structure is part of UGs sparse matrix data structure. Degrees
of freedom (and additional values) associated with `one geometric object` 
('ELEMENT', 'NODE', 'EDGE' and also sides in 3D for which there is no extra data type)  
are stored in a 'VECTOR' object. In each 'VECTOR' starts a list of 'MATRIX' objects
representing the rows of the global stiffness matrix corresponding to all
degrees of freedom in the 'VECTOR'.

. MATRIX - Contains all matrix entries coupling the degrees of freedom
in two 'VECTOR' objects. 'MATRIX' objects always come in pairs connecting two
'VECTOR' objects in both directions. The graph induced by the 'MATRIX'-'VECTOR'
structure is completely independend from the mesh graph represented by the
'LINK'-'NODE' structure.

. BLOCKVECTOR - Gives you the facility to structure a 'VECTOR'-list. The
'VECTOR'-list itself remains unchanged but additional data is inserted
in the grid. The substructuring can be hierarchical. Each 'VECTOR' sublist
described by a 'BLOCKVECTOR' can be processed by itself. Via the
'BLOCKVECTOR' structure there is also a blockmatrix structure induced to
the 'MATRIX' structure but without any additional memory need.

. CONNECTION - The two 'MATRIX' objects connecting two 'VECTOR' objects 
are combined to a 'CONNECTION' object. This is similar to the combination of two
'LINK' objects in an 'EDGE'.

. GRID - All objects allocated on one grid level can be accessed via the
'GRID' structure.

. MULTIGRID - Several grid levels are combined to form a 'MULTIGRID' structure.
It also provides access to the data structure parameters ('FORMAT'), the
geometry ('DOMAIN') and the problem description ('PROBLEM'). The 'MULTIGRID'
structure is basically an environment item (see 'ENVIRONMENT'). Several
'MULTIGRID' objects can be handled simultaneously by the grid manager module.

`IMPORTANT:` The access to all components of the data types is realized with
macros. Through the use of macros the data structure can be changed without
changing the code that uses it. 

SEE ALSO:

'LIMITS', all data types mentioned above.

.p DataStructure.eps
.cb
Graphical representation of the data structure with references.
.ce

D*/

/*D

DOMAIN - Data type describing a domain.

STRUCTURES:

.vb
struct domain {

    /* fields for environment directory */
    ENVDIR d;

    /* domain variables */
    COORD MidPoint[DIM];                // point in the middle of domain    
    COORD radius;                       // defines sphere around MidPoint  
                                        // containing the domain           
    INT numOfSegments;                  // number of boundary segments     
    INT numOfCorners;                   // number of corner points        
    INT domConvex;                      // is the domain convex?        
} ;

typedef struct domain DOMAIN;
.ve

DESCRIPTION:

The 'DOMAIN' structure describes a two- or three-dimensional domain. This geometry
information is used by UG when it refines a grid, i.e. complex geometries are approximated
better when the grid is refined. The 'DOMAIN' structure is a directory in the
environment tree (see 'ENVIRONMENT' in the 'ug/low' section). 

A domain is made up of one or several `boundary segments` which are defined by the
'BOUNDARY_SEGMENT' (see that page) structure. 
The 'BOUNDARY_SEGMENT' objects are stored in the environment
tree in the corresponding 'DOMAIN'. The points where boundary segments join are
called corners of the domain. For each corner a 'NODE' is automatically created.

Domains are created with the function 'CreateDomain'.

. d - Makes the 'DOMAIN' an environment directory. 'd' stores also the name of
the domain.

. MidPoint,radius -  Defines a ball which should contain the domain. This information
is used in the graphics module to initialize the view with a reasonable transformation.

. numOfSegments -  Gives the number of 'BOUNDARY_SEGMENT' structures that
will define the domain. 

. numOfCorners - Number of corners defined by the domain.

. domConvex - True, if the domain is convex.

MACROS:

The components of the 'DOMAIN' structure are only read internally. The
user only creates domains with the function 'CreateDomain'. Therefore
no access macros are provided.

EXAMPLES:

The following code fragment shows the definition of a simple two-dimensional
domain. The domain is the unit circle defined by two boundary segments, the
upper half circle and the lower half circle. Therefore the domain has two
corners, two boundary segments and one subdomain (the domain itself).

The following two functions of type 'BndSegFuncPtr' define the
mapping for the upper and lower half circle respectively.

.vb
/* circleBoundary maps [0.0,1.0] to the upper half circle */
static INT circleBoundaryUpper (void *data, COORD *param, COORD *result)
{
    COORD lambda;

    // retrieve parameter value 
    lambda = param[0];

    // check range
    if ((lambda<0.0)||(lambda>1.0)) return(1);

    // fill result 
    result[0] = cos(PI*lambda); // x  PI defined in misc.h 
    result[1] = sin(PI*lambda); // y 

    // return ok 
    return(0);
}

/* circleBoundary maps [0.0,1.0] to the lower half circle */
static INT circleBoundaryLower (void *data, COORD *param, COORD *result)
{
    COORD lambda;

    // retrieve parameter value 
    lambda = param[0];

    // check range 
    if ((lambda<0.0)||(lambda>1.0)) return(1);

    // fill result 
    result[0] = cos(PI+PI*lambda); // x  PI defined in misc.h 
    result[1] = sin(PI+PI*lambda); // y 

    // return ok 
    return(0);
}
.ve

The following function 'InitUnitCircle' uses the functions
'CreateDomain' and 'CreateBoundarySegment2D' in order to create
a domain and the list of boundary segments for that domain.

.vb
static INT InitUnitCircle (void)
{
    COORD radius,MidPoint[2];

    // allocate new domain structure 
    MidPoint[0] = MidPoint[1] = 0.0;
    radius = 1.05;
    if (CreateDomain(
            "circle",               // name of the new domain               
            MidPoint,radius,        // circle containing the domain         
            2,                      // number of boundary segments          
            2,                      // number of corners                    
            YES                     // true if domain is convex             
       )==NULL) return(1);

    // allocate the boundary segments, segment allocation must              
    // immediately follow the domain definition.                            
    if (CreateBoundarySegment2D(
            "circle bnd upper",     // name of the boundary segment         
            1,                      // number of left subdomain             
            0,                      // number of right subdomain            
            0,                      // number of segment, starting with 0   
            0,                      // number of corner where segment starts
            1,                      // number of corner where segment ends  
            10,                     // resolution, use 1 for straight line  
            0.0,                    // begin of parameter interval          
            1.0,                    // end of parameter interval            
            circleBoundaryUpper,    // function mapping parameter to world  
            NULL                    // user defined pointer to be supplied  
       )==NULL) return(1);
    if (CreateBoundarySegment2D(
            "circle bnd lower",     // name of the boundary segment         
            1,                      // number of left subdomain             
            0,                      // number of right subdomain            
            1,                      // number of segment, starting with 0   
            1,                      // number of corner where segment starts
            0,                      // number of corner where segment ends  
            10,                     // resolution, use 1 for straight line  
            0.0,                    // begin of parameter interval          
            1.0,                    // end of parameter interval            
            circleBoundaryLower,    // function mapping parameter to world  
            NULL                    // user defined pointer to be supplied  
       )==NULL) return(1);

    // return ok 
    return(0);
}
.ve

For a 3D example see e.g. the application 'appl3d'.

SEE ALSO:

'BOUNDARY_SEGMENT', 'CreateDomain', 'CreateBoundarySegment2D', 'CreateBoundarySegment'.

D*/


/*D
BOUNDARY_SEGMENT - Data structure defining part of the boundary of a domain

STRUCTURES:

.vb
typedef INT (*BndSegFuncPtr) (void *,COORD *,COORD *);

struct boundary_segment {

    /* fields for environment directory */
    ENVVAR v;

    /* fields for boundary segment */
    INT left,right;                   // number of left and right subdomain 
    INT id;                           // unique id of that segment          
    INT segType;                      // segment type, see above            
    INT points[CORNERS_OF_BND_SEG];   // numbers of the vertices (ID)       
    INT resolution;                   // measure for the curvature          
    COORD alpha[DIM_OF_BND],beta[DIM_OF_BND]; // parameter interval used
    BndSegFuncPtr BndSegFunc;         // pointer to definition function     
    void *data;                       // can be used by applic to find data 
} ;

typedef struct boundary_segment BOUNDARY_SEGMENT;
.ve

DESCRIPTION:

A domain for UG is described as a set of boundary segments defined
by the 'BOUNDARY_SEGMENT' structure. Each boundary segment is a mapping
from `d`-1 dimensional parameter space to `d` dimensional eucledian space.
The parameter space is an interval [a,b] in two dimensions or a rectangle
[a,b]x[c,d] in three dimensional applications.

`2D boundary segments`
.vb
      0        1
      +--------+     maps [a,b] to R x R
      a        b
.ve

`3D boundary segments`
.vb
    d +--------+     maps [a,b]x[c,d] to R x R x R
      |2      3|
      |        |
      |        |
      |0      1|
    c +--------+
      a        b
.ve


For all boundary segments the points in `d` dimensional space corresponding to the parameters
a and b in two dimensions ((a,c),(a,d),(b,c),(b,d) in three dimensions)
are called `corners` of the domain. Locally for each boundary segment the
corners are numbered like shown in the figures above.
The corners are numbered `globally` in a consecutive way beginning with 0.
`CAUTION:` boundary segments must be defined in such a way that no two
corners are identical!

In two dimensions `internal boundary
segments` can be defined in order to divide the domain into `subdomains`
having different materials for example. The subdomains are numbered consecutively
beginning with 1. By default the exterior of the domain has number 0.

Boundary segments are created with the function 'CreateBoundarySegment2D'
and 'CreateBoundarySegment'.

. v - The 'BOUNDARY_SEGMENT' structure is an environment variable (see 'ENVIRONMENT'),
therefore it has the 'ENVVAR' 'v' as its first component. 'v' stores also the
name of the boundary segment.

. left,right - Numbers of left and right subdomain. The right subdomain is where the
normal vector of the curve points to in a right handed coordinate system. The TeX
version of this page contains two figures for clarification. 
In 2D it is simple: Walk along the curve in direction of increasing parameter
values and look to the right. There is the right subdomain. In 3D the rule
is as follows. Let the thumb point in direction of increasing values
of the first parameter, let the index finger point in direction of
increasing values of the second parameter, then the middle finger
points to the right subdomain.  

. id - Number of the boundary segment beginning with zero.

. segType - Type of boundary segment. Currently only 'NON_PERIODIC' is
allowed. Later periodic boundary segments will be implemented.

. points - Mapping of local numbers of corners to global numbers. Remember, all
global numbers of corners must be different. The local numbering scheme can
be seen from the figures above.

. resolution - Parameter indicating the curvature of the boundary segment. This is
used mainly by the graphics module in order plot a boundary segment. For
straight lines 1 is sufficient.

. alpha,beta - Defines the parameter space. In 2D this is the interval
[alpha[0],beta[0]], in 3D this is the rectangle 
[alpha[0],beta[0]] x [alpha[1],beta[1]] (or a=alpha[0], b=beta[0],
c=alpha[1], d=beta[1] in the figure above.
BndSegFunc - Pointer to a C function describing the mapping from parameter
space to the `d`-space. This function must be of type 'BndSegFuncPtr'.
(see below).

. data - User defined pointer. This pointer is passed as the first
argument to the 'BndSegFunc' of the segment. This pointer can be used
to construct an interface to geometry data files, e.g. from a CAD system.

. BndSegFuncPtr - Data type of the functions mapping parameter space to
`d`-space. The first argument of type 'void *' is the user data pointer from
the corresponding 'BOUNDARY_SEGMENT'. The second parameter of type 'COORD *'
provides an array containing the parameters where the boundary segment
function should be evaluated (one number in 2D, two numbers in 3D). The
third parameter of type 'COORD *' provides an array where the result can be placed
(x,y values in 2D, x,y,z values in 3D).

MACROS:

The components of the 'BOUNDARY_SEGMENT' structure are accessed through
the 'BNDSEGDESC' structure, see that man page.

EXAMPLES:

For an example how a domain is defined see the 'DOMAIN' page.

SEE ALSO:

'DOMAIN', 'CreateDomain', 'CreateBoundarySegment2D', 'CreateBoundarySegment'.


.p bndseg2d.eps
.cb
Boundary segments in 2D.
.ce

.p bndseg3d.eps
.cb
Boundary segments in 3D.
.ce
D*/

/*D
PROBLEM - Data type describing a problem.

STRUCTURES:

.vb
typedef INT (*CoeffProcPtr) (COORD *, DOUBLE *);
typedef INT (*UserProcPtr) (DOUBLE *, DOUBLE *);
typedef INT (*ConfigProcPtr) (INT argc, char **argv);

struct problem {

    // fields for environment directory */
    ENVDIR d;
   
    // fields for problem */
    INT problemID;              // used to identify problem type    
    ConfigProcPtr ConfigProblem;// procedure to reinitialize problem
    INT numOfCoeffFct;          // # of coefficient functions      
    INT numOfUserFct;           // # of User functions              
    void * CU_ProcPtr[1];       // coefficient functions      
};

typedef struct problem PROBLEM ;
.ve

DESCRIPTION:

The 'PROBLEM' data type is used to give a complete description
of the pde to be solved. Since this is a UG data type and UG is
independent of the pde to be solved it must be a very general mechanism.
The abstraction is that a problem is completely described by
(1) The domain, (2) the pde, (3) coefficient functions for the pde
and (4) boundary conditions. The first two items are handled easily.
When creating a 'PROBLEM' then the name of a 'DOMAIN' has to be passed
as a parameter (see example below). The pde to be solved is determined
by the problem class library that is linked to the UG library. In order
to be sure that a problem description and the problem class library
are intended for the same pde, each problem class library exports
in identification number that has to coincide with the
number given in the problem description. Problems are created by
the function 'CreateProblem'.

. d - The problem is an environment directory. This directory is a subdirectory
of the domain where this problem corresponds to. 'd' also contains the
name of the problem.

. problemID - Problem class identification number. This number is used to determine
that the problem description coincides with the pde solved by the
problem class library.

. ConfigProblem - Pointer to a user definable function that is executed when the 'reinit'
command is given in the UG shell.

. numOfCoeffFct,numOfUserFct - User definable coefficient functions come in two flavours.
They are either of type 'CoeffProcPtr' or of type 'UserProcPtr'.
'numOfCoeffFct' and 'numOfUserFct' give the number of functions of each type that
make up the problem description. 

. CU_ProcPtr - Array that stores the pointers to coefficient and user functions.
Since access to this array is provided through macros (see below) the layout
is not important. Note that this array is allocated dynamically to the desired length.

. CoeffProcPtr - This function gets a 'COORD' and a 'DOUBLE' array, which are usually
called 'in' and 'out'. These functions are only called by the problem class
libraries, therefore the length of these arrays and the use of their entries
is not determined by UG. UG only stores pointers to these user definable functions!

. UserProcPtr - Same as a 'CoeffProcPtr' but both arrays are of type 'DOUBLE *'.

. ConfigProcPtr - Problem configuration function which is called be the UG command
'reinit'. Parameters 'argc', 'argv' are those passed to the function implementing
the 'reinit' command. This function can be used to change a parameter in the
problem description from the shell. E.g. the Reynolds number is a parameter in a
Navier-Stokes calculation. One could write a configuration functions that reads
the Reynolds number from the command line of the 'reinit' command or from
a UG shell variable.


MACROS:

.vb
INT PROBLEMID (PROBLEM *p);
.ve
Extracts the problem identification number from a problem.

.vb
ConfigProcPtr CONFIGFUNC (PROBLEM *p);
.ve
Returns a pointer to the configuration function of the problem.

.vb
INT NUMCOEFF (PROBLEM *p); 
.ve
Returns the number of coefficient functions defined in the problem description.

.vb
INT NUMUSERFCT (PROBLEM *p);
.ve
Returns the number of user functions in the problem description.

.vb
CoeffProcPtr COEFFFUNC (PROBLEM *p,INT i); 
.ve
Returns a pointer to the 'i'-th coefficient function of the problem.
The meaning of coefficient function 'i' is determined by the problem class
library.

.vb
UserProcPtr USERFUNC (PROBLEM *p,INT i);
.ve
Returns a pointer to the 'i'-th user function of the problem.
The meaning of user function 'i' is determined by the problem class
library.

EXAMPLES:

For a detailed example see the 'diff2d' and 'cd3d' description.

SEE ALSO:
'BOUNDARY_CONDITION', 'CreateProblem', 'CreateBoundaryCondition'.

D*/

/*D
BOUNDARY_CONDITION - Data type defining a boundary condition.

STRUCTURES:

.vb
typedef INT (*BndCondProcPtr) (void *, void *, COORD *, DOUBLE *, INT *);

struct bndcond {

    // fields for environment variable
    ENVVAR v;

    // fields for boundary condition
    INT id;                // corresponds to boundary segment id ! 
    BndCondProcPtr BndCond;// function defining boundary condition 
    void *data;            // additional data for bnd cond 
} ;

typedef struct bndcond BOUNDARY_CONDITION ;
.ve

DESCRIPTION:

The data type BOUNDARY_CONDITION is used to specify boundary
conditions. This is done in the same way as a domain is defined.
For each boundary segment there must be a corresponding boundary
condition function that specifies the boundary conditions along that
segment. The same parametrization is used for the boundary segment function
and the boundary condition function. The 'BOUNDARY_CONDITION' data structure
stores a pointer to that function and some additional information.

Boundary conditions are created with the function 'CreateBoundaryCondition'.

. v - A 'BOUNDARY_CONDITION' is an environment variable which is stored
in the directory given by the corresponding 'PROBLEM' object. 'v' stores
also the name of the boundary condition.

. id - Number of the corresponding boundary segment. Boundary segments
and boundary conditions with the same id are accessible via a 'BNDSEGDESC'
structure.

. BndCond - Pointer to a function of type 'BndCondProcPtr' defining the
boundary condition for a segment.

. data - user definable pointer that is passed as first argument to 'BndCond'
when it is called.

MACROS:

The components of the 'BOUNDARY_CONDITION' structure are only accessible
through the 'BNDSEGDESC' structure during computations. See the MACROS
section there.

EXAMPLES:

For detailed examples see the 'appl2d' and 'appl3d' description.

SEE ALSO:
'PROBLEM', 'CreateBoundaryCondition'.

D*/

/*D
FORMAT - Data type that describes parameters of the UG data structure

STRUCTURES:

.vb
typedef INT (*ConversionProcPtr) (void *, const char *, char *);

struct format {

    // fields for enironment variable
    ENVDIR d;

    // variables of format
    INT sVertex;                        // size of vertex user data struc. in bytes 
    INT sMultiGrid;                     // size of mg user data structure in bytes 
    INT VectorSizes[MAXVECTORS];        // number of doubles in vectors          
    INT MatrixSizes[MAXMATRICES];       // number of doubles in matrices     
    INT ConnectionDepth[MAXMATRICES];   // depth of connection for matrices   
    INT MaxConnectionDepth;             // maximal connection depth    
    INT NeighborhoodDepth;              // geometrical depth corresponding  
                                        // algebraic con with depth 1    
    ConversionProcPtr PrintVertex;      // print user data to string  
    ConversionProcPtr PrintGrid;
    ConversionProcPtr PrintMultigrid;
    ConversionProcPtr PrintVector[MAXVECTORS];
    ConversionProcPtr PrintMatrix[MAXVECTORS][MAXVECTORS];
} ;
.ve

DESCRIPTION:

The 'FORMAT' data type is used to describe parameters of the UG data structure.
Several different formats can be defined at initialization time. Which format
is used for a 'MULTIGRID' can be specified when it is created or loaded from
file. Each problem class defines at least one format. 'FORMAT' objects
are created with the 'CreateFormat' function.

. d - The format is an environment directory. This directory will contain a list
of 'SYMBOL' objects. 'd' also stores the name of the format.

. sVertex - Size of user data space in each 'VERTEX' in bytes.

. sMultiGrid - Size of user data space in the 'MULTIGRID' structure in bytes.

. VectorSizes - Array giving the number of 'DOUBLE' values to be allocated
for the 'VECTOR' per geometric object. The number of 'DOUBLE's can be different
in nodes, edges, sides and elements. 'VERTEX[NODEVECTOR]' specifies
the number of 'DOUBLE's in a node of the grid. 'EDGEVECTOR', 'SIDEVECTOR'
and 'ELEMVECTOR' are used for the other geometric objects. If a number of 'DOUBLE's
is requested in a vector of a geometric object that is not allowed
to have degrees of freedom (determined by 'ug.conf' file during
compilation - see 'makefiles') an error is returned by the 'CreateFormat' function.

. MatrixSizes - Array determining the number of 'DOUBLE' values in a 'MATRIX' 
coupling of one 'VECTOR' with another. Since the number of degrees
of freedom in a 'VECTOR' depends on its geometric position, the 'MATRIX'
size depends on position of source and destination 'VECTOR'. The memory requirements
are assumed to be symmetric, that is a 'MATRIX' from a node vector to an edge
vector needs the same memory as that from an edge vector to a node vector.
Therefore in 2D there are 3 vector positions and 6 different matrix sizes and
in 3D there are 4 vector positions and 10 different matrix sizes.
A mapping of  source and destination vector position to an index in the 'MatrixSizes'
array is provided by the array 'MatrixType' exported by 'algebra.h'.
E. g. 'MatrixType[NODEVECTOR][EDGEVECTOR]' provides the index for node-edge
matrices.

. ConnectionDepth - Consider an element `e` of a mesh (in 2D or 3D). All neighbors of that
element are said to have distance 1 from `e` and these elements form a set called E(`e`,1).
All elements having distance 1 from any element in E(`e`,1) form the set E(`e`,2). Consequently
the set containing only the element `e` is called E(`e`,0). Therefore it makes sense
to call E(`e`,d) the `set of elements having distance d from e`.
UG generates the 'MATRIX' objects automatically from the mesh by coupling all
degrees of freedom in `e` with those of all elements up to distance `d` from `e`.
The distance `d` depends again on the position of source and destination vector as
in the 'MatrixSize' component.

. MaxConnectionDepth,NeighborhoodDepth - These numbers are computed internally
and need not be specified nor are they useful from outside.

. PrintVertex, PrintGrid, PrintMultigrid - Pointers to functions of type
ConversionProcPtr. These functions can be specified by the user in order to
print the contents of the user data fields in vertices, grids and multigrids.

. PrintVector - is used to print user data in vectors. There may be different
print functions for each vector position.

. PrintMatrix -  is used to print user data in matrices. There may be different
print functions according to position of source and destination vector.
There may be different
print functions according to position of source and destination vector.

. ConversionProcPtr - Data type for the print functions. First parameter
is a pointer to the user data space (this must be casted appropriately).
Second parameter is a character string containing a number of
spaces that can be used to indent the user output if it is to contain several
lines. The third parameter is a character array where the output should be placed.

MACROS:

The fields of this data structure are accessed only internally. The user
creates these data structures at initialization time with the function
'CreateFormat'.

EXAMPLES:

The following example defines a format where degrees of freedom are in the
nodes of the mesh and and all nodes within on element are coupled.
This format is suitable for standard conformin (bi-)linear basis
functions.

First we define 'DOUBLE' arrays with four and two entries which
will be allocated in each 'NODE' and 'MATRIX' respectively, i.e.
we can represent four finite element functions and we store
two global stiffness matrices.

.vb
// define data types in order to determine size in bytes
typedef DOUBLE FullScalarNodeData[4];
typedef DOUBLE FullScalarLinkData[2];
.ve

The following two functions of type 'ConversionProcPtr' are used
to print the contents of a 'VECTOR' and a 'MATRIX' on the screen.

.vb
// the print functions
static INT PrintFullScalarNodeData (void *data, const char *indent, char *s)
{
    DOUBLE *vector;
   
    vector = (DOUBLE *) data;
    sprintf(s,"  x=%11.4lE   b=%11.4lE   v=%11.4lE  t=%11.4lE",
              (double)vector[0],(double)vector[1],(double)vector[2],(double)vector[3]);
    return(0);
}

static INT PrintFullScalarLinkData (void *data, const char *indent, char *s)
{
    DOUBLE *vector;

    vector = (DOUBLE *) data;
    sprintf(s,"  A=%11.4lE  LU=%11.4lE",(double)vector[0],(double)vector[1]);
    return(0);
}
.ve

Fortunately creating a format is simplified by the two data structures
'VectorDescriptor' and 'MatrixDescriptor' which are explained in the page
for 'CreateFormat'.  The following function 'InitFullScalarFormat' now
creates a 'FORMAT' object in UGs environment.

.vb
// now enrol the format description in ug
INT InitFullScalarFormat (void)
{
    FORMAT *newFormat;
    VectorDescriptor vd[MAXVECTORS];
    MatrixDescriptor md[MAXMATRICES];
    SHORT nComp[2], Comp[1];

    // we need dofs only in nodes 
    vd[0].pos   = NODEVECTOR;
    vd[0].size  = sizeof(FullScalarNodeData);
    vd[0].print = PrintFullScalarNodeData;

    // and the following connection: node-node
    md[0].from  = NODEVECTOR;
    md[0].to    = NODEVECTOR;
    md[0].size  = sizeof(FullScalarLinkData);
    md[0].depth = 0; // only within one element !
    md[0].print = PrintFullScalarLinkData;

    // create format 'full scalar' 
    newFormat = CreateFormat("full scalar", // name of the format
                   0,0,                     // no user data in vertex and multigrid 
                   (ConversionProcPtr)NULL, // no print function for vertex data
                   (ConversionProcPtr)NULL, // no print function for grid data
                   (ConversionProcPtr)NULL, // no print function for multigrid data
                   1,vd,                    // 1 entry in vd array
                   1,md                     // 1 entry in md array
    );
    if (newFormat==NULL) return(__LINE__);

    return(0);
}
.ve

SEE ALSO: 
 
'CreateFormat'

D*/

/*D
VERTEX - Data type storing level-independent node information

STRUCTURES:

.vb
struct ivertex {               // inner vertex structure                
    
    // variables 
    unsigned INT control;      // object identification, various flags 
    INT id;                    // unique id used for load/store        
    COORD x[DIM];              // vertex position                        
    COORD xi[DIM];             // local coordinates in father element    
    
    // pointers 
    union vertex *pred,*succ;  // double linked list of vertices        
    void *data;                // associated user data structure        
    union element *father;     // father element                        
    struct node *topnode;      // highest node where defect is valid    
} ;

struct bvertex {               // boundary vertex structure            
    
    // variables 
    unsigned INT control;      // object identification, various flags 
    INT id;                    // unique id used for load/store        
    COORD x[DIM];              // vertex position                        
    COORD xi[DIM];             // local coordinates in father element    
    
    // pointers 
    union vertex *pred,*succ;  // double linked list of vertices        
    void *data;                // associated user data structure        
    union element *father;     // father element                        
    struct node *topnode;      // highest node where defect is valid    
    
    struct vsegment *vseg;     // pointer to chain of segments         
} ;

union vertex {                 // only used to define pointer to vertex
    struct ivertex iv;
    struct bvertex bv;
} ;

typedef union vertex VERTEX;
.ve

DESCRIPTION:

The 'VERTEX' structure stores the level independent information of
a 'NODE'. If several 'NODE's on different levels of the 'MULTIGRID' structure
are at the same position then they share a common 'VERTEX' object.
The 'VERTEX' is a union of inner vertex 'ivertex' and boundary vertex 'bvertex'.
The 'bvertex' has all of the 'ivertex' plus some extra information where
the vertex is on the boundary of the domain. In the code one always works with
pointers of type 'VERTEX *' and accesses the components through the macros described
below.

. control - As in almost all UG objects this word is used bitwise for various
purposes (see section below).

. id - Each vertex is given a unique identification number at creation.

. x - Vector with `global` coordinates.

. xi - Vector with `local` coordinates. This is used to represent the multigrid
hierarchy. The 'father' component points to an 'ELEMENT' of the next coarser
grid level and 'xi' gives the position of the 'VERTEX' within this element in
the local coordinate system of the 'ELEMENT'. In this way also loosely coupled
grids can be represented although the grid refinement algorithm is currently
not able to produce such grids. The solvers however would work
also on much more general multigrid hierarchies.

. pred,succ - Pointers realizing a double linked list of 'VERTEX' objects per level.
The beginning of this list is in the 'GRID' structure.

. data - pointer to a data space of user definable size. The size is defined in
the 'FORMAT' definition.

. father - Pointer to an 'ELEMENT' of the next coarser level. This component is
used for multigrid interpolation and restriction (see also 'xi' component above).
For the vertices in the coarsest grid (level 0) this pointer is 'NULL'.

. topnode - If several 'NODES' share this 'VERTEX' then this pointer refers
to the 'NODE' on the highest level. This pointer will probably `not` be supported
in the next version, its use is not recommended!

. vseg - (Boundary vertex only) Pointer to a list of 'VSEGMENT' structures, each
describing a position of the 'VERTEX' on a boundary segment (see also 'BOUNDARY_SEGMENT').

MACROS:

.vb
INT ID (VERTEX *p);
.ve
Returns 'VERTEX' id.

.vb
VERTEX *PREDV (VERTEX *p);
VERTEX *SUCCV (VERTEX *p);
.ve
Access to the double linked list. 'NULL' pointers indicate the end of the list
in both directions.

.vb
COORD *CVECT (VERTEX *p);
COORD XC (VERTEX *p);
COORD YC (VERTEX *p);
COORD ZC (VERTEX *p);
.ve
'CVECT' returns the array of global coordinates (i.e. a pointer) and 'XC', 'YC' and
'ZC' return the individual components. Accessing the `z`-coordinate in a 2D application
will not lead to an error message!

.vb
COORD *LCVECT (VERTEX *p);
COORD XI (VERTEX *p);
COORD ETA (VERTEX *p);
COORD NU (VERTEX *p);
.ve
'LCVECT' returns the array of local coordinates with the father element and the other
macros return the individual components called 'XI', 'ETA' and 'NU'.

.vb
void *VDATA (VERTEX *p);
.ve
Returns the pointer to user data space.

.vb
ELEMENT *VFATHER (VERTEX *p);
.ve
Returns the pointer an 'ELEMENT' of the next coarser grid level containing the 
given 'VERTEX'. A 'NULL' pointer indicates that the 'VERTEX' is on level 0, the
coarsest level.

.vb
NODE *TOPNODE (VERTEX *p);
.ve
Returns pointer to the highest 'NODE' using that 'VERTEX'. The use of this
component is not recommended since it will not be supported in the future.

`Macros for boundary vertices only`

.vb
VSEGMENT *VSEG (VERTEX *p);
.ve
Pointer to the first 'VSEGMENT' structure of the list.

.vb
BNDSEGDESC *FIRSTSEGDESC (VERTEX *p);
.ve
Returns a pointer to the 'BNDSEGDESC' structure used by the first 'VSEGMENT'
structure of the list. See the 'BNDSEGDESC' page for more information
on that structure.

.vb
COORD BVLAMBDA (VERTEX *p);
COORD FIRSTLAMBDA (VERTEX *p);
.ve
Returns the parameter for the first boundary segment this vertex lies on. Both
macros do the same thing and 'BVLAMBDA' is provided for compatibility reasons.

.vb
COORD *FIRSTPVECT (VERTEX *p);
.ve
Returns a pointer to the array containing the parameter for the first boundary
where this vertex lies on. The first boundary segment is accessible
via 'FIRSTSEGDESC'.

CONTROL WORDS:

The first word of many UG data structure is used bitwise for various purposes.

`General macros available for all objects`
.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (VERTEX *p);                 27  5   Object type IVOBJ for inner   
void SETOBJT (VERTEX *p, INT n);              and BVOBJ for boundary vertex

INT USED (VERTEX *p);                 23  1   used only temporarily
void SETUSED (VERTEX *p, INT n);

INT TAG (VERTEX *p);                  24  3   available for user
void SETTAG (VERTEX *p, INT n);

INT LEVEL (VERTEX *p);                17  5   level on which vertex is
void SETLEVEL (VERTEX *p, INT n);             defined

INT THEFLAG (VERTEX *p);              16  1   used only temporarily
void SETTHEFLAG (VERTEX *p, INT n);
-----------------------------------------------------------------------------
.ve

`Macros specific to the 'VERTEX' structure`
.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT MOVE (VERTEX *p);                 4   2   Number of dimensions in which
void SETMOVE (VERTEX *p, INT n);              a vertex can be moved:
                                                0: vertices at corners
                                                1: boundary vertex in 2D
                                                2: inner in 2D, boundary in 3D
                                                3: inner in 3D

INT MOVED (VERTEX *p);                0   1   TRUE if vertex has been moved
void SETMOVED (VERTEX *p, INT n);             away from initial position.

INT ONEDGE (VERTEX *p);               1   3   Edge in father element of vertex
void SETONEDGE (VERTEX *p, INT n);            on which this vertex resides.
                                              2D: only valid for boundary vertex!
-----------------------------------------------------------------------------
.ve

SEE ALSO:

'VSEGMENT', 'BNDSEGDESC'.

D*/

/*D
VSEGMENT - Data type storing position of vertex on boundary segment.

STRUCTURES:

.vb
struct vsegment {

    unsigned INT control;         // object identification, various flags 
    struct bndsegdesc *segdesc;   // pointer to boundary segment desc     
    COORD lambda[DIM_OF_BND];     // position of vertex on boundary segmen

    #ifdef __TWODIM__
    COORD zeta;                   // local coord. of vertex  in father edg
                                  // Def.: l = (1-z)*l0 + z*l1            
    #endif

    struct vsegment *next;
};

typedef struct vsegment VSEGMENT;
.ve

DESCRIPTION:

Each 'VERTEX' on the boundary has a list of 'VSEGMENT' structures, each
storing one possible position on a boundary segment. Most vertices are only
on one boundary segment. Only a vertex whose parameter is at the boundary
of the parameter interval can reside on more than one boundary segment.

. control - As in almost all UG objects this word is used bitwise for various
purposes.

. segdesc - Pointer to 'BNDSEGDESC' structure combining references to
'BOUNDARY_SEGMENT' and 'BOUNDARY_CONDITION'.

. lambda - Array containing parameter value. This parameter is with respect
to the boundary segment given by 'segdesc'.

. zeta - (2D only) This component is only provided for compatibility reasons.
Its use is not recommended.

. next - Pointer to next list element. A 'NULL' pointer indicates the
end of the list.

MACROS:

.vb
VSEGMENT *NEXTSEG (VSEGMENT *p);
.ve

Returns pointer to next vertex segment.

.vb
BNDSEGDESC *BSEG (VSEGMENT *p);
BNDSEGDESC *BSEGDESC (VSEGMENT *p);
.ve

Both return a pointer to the 'BNDSEGDESC' structure referenced by the vertex segment.
'BSEG' is the old version and should not be used anymore.

.vb
COORD *PVECT (VSEGMENT *p);
.ve 

Returns array of parameter values with respect to the segment given by 'BSEGDESC'.

.vb
COORD LAMBDA (VSEGMENT *p,INT i);
.ve

Provides access to the individual components of the parameter value.

.vb
COORD ZETA (VSEGMENT *p);
.ve

Access to 'zeta' component.


CONTROL WORDS:

`General macros available for all objects`
.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (VSEGMENT *p);               27  5   Object type value: VSOBJ   
void SETOBJT (VSEGMENT *p, INT n);    
-----------------------------------------------------------------------------
.ve

`Macros specific to the 'VSEGMENT' structure`

no entries.

SEE ALSO:

'VERTEX', 'BNDSEGDESC'.

D*/

/*D
BNDSEGDESC - Data type combining access to boundary segments and boundary conditions

STRUCTURES:

.vb
struct bndsegdesc {                         // descriptor for one boundary segment  
    unsigned INT control;                   // object identification, various flags 
    INT id;                                 // unique id used for load/store        
    struct boundary_segment *theSegment;    // (1) coordinate definition            
    struct bndcond *theBoundaryCondition;   // (2) boundary condition definition    
} ;

typedef struct bndsegdesc BNDSEGDESC;
.ve

DESCRIPTION:
The only purpose of this data structure is to combine the references to
the 'BOUNDARY_SEGMENT' structure and the 'BOUNDARY_CONDITION' structure with
the same id. When a new 'MULTIGRID' structure is created with
either 'CreateMultiGrid' or 'LoadMultiGrid' the list of boundary segments
and boundary conditions is combined and the 'BNDSEGDESC' structures are
created. The 'VSEGMENT' and 'ELEMENTSIDE' structures use the 'BNDSEGDESC'
to reference a boundary segment or boundary conditions. Therefore all access
to boundary information during computation is made over the 'BNDSEGDESC' structure.
There are macros (see below) providing immediate access to the components
of the 'BOUNDARY_SEGMENT' and 'BOUNDARY_CONDITION' structures through the 
'BNDSEGDESC' structure.

MACROS:

.vb
INT SEGID (BNDSEGDESC *p);
.ve

Get segment id.

.vb
INT LEFT (BNDSEGDESC *p);
INT RIGHT (BNDSEGDESC *p);
.ve

Get number of left and right subdomain.

.vb
INT SEGTYPE (BNDSEGDESC *p);
.ve 

Get number of subdomain.

.vb
INT POINT (BNDSEGDESC *p,i);
.ve

Return global numbers of the corners of the parameter space. 'i' is the
local number of the corner.

.vb
INT RES (BNDSEGDESC *p);
.ve

Return the resolution parameter of the boundary segment.

.vb
BndSegFuncPtr BNDSEGFUNC (BNDSEGDESC *p);
.ve

Returns a pointer to the C-function providing the mapping from parameter
space to `d`-dimensional space.

.vb
void *SEGDATA (BNDSEGDESC *p);
void *BNDDATA (BNDSEGDESC *p);
.ve

Returns the 'data' pointer  of the 'BOUNDARY_SEGMENT' structure. 'SEGDATA'
is provided for compatibility reasons.

.vb
BndCondProcPtr BNDCONDFUNC (BNDSEGDESC *p);
.ve

Returns a pointer to the C-function providing boundary conditions
for the selected problem.

.vb
void *CONDDATA (BNDSEGDESC *p);
.ve

Returns the 'data' pointer from the 'BOUNDARY_CONDITION' structure.

.vb
COORD ALPHA (BNDSEGDESC *p,i);
COORD BETA (BNDSEGDESC *p,i);
.ve

Returns the parameter interval that is used by the functions returned
by 'BNDSEGFUNC' and 'BNDCONDFUNC'.

CONTROL WORDS:

No control word entries are used by the 'BNDSEGDESC' structure.

SEE ALSO:

'BOUNDARY_SEGMENT', 'BOUNDARY_CONDITION', 'VSEGMENT', 'ELEMENTSIDE'.

D*/

/*D
NODE - Data type representing a node in the mesh

STRUCTURES:
.vb
struct node {                   // level dependent part of a vertex     

    // variables 
    unsigned INT control;       // object identification, various flags 
    INT id;                     // unique id used for load/store        
    INT index;                  // discrete coordinates for ordering    

    // pointers 
    struct node *pred,*succ;    // double linked list of nodes per level
    struct link *start;         // list of links                        
    struct node *father;        // node on coarser level (NULL if none) 
    struct node *son;           // node on finer level (NULL if none)   
    union vertex *myvertex;     // corresponding vertex structure       
    
    // associated vector if 
    #ifdef __NODEDATA__
    VECTOR *vector;             // associated vector                    
    #endif

} ;

typedef struct node NODE;
.ve

DESCRIPTION:

Each node of the mesh is represented by a 'NODE' structure. When a mesh is refined
then new 'NODE' objects are allocated on the new grid level
even at those positions where nodes were already in the coarse mesh. However, 'NODE's
at the same position share a common 'VERTEX' structure.
A node provides access to all neighboring nodes via the 'LINK' structure. There
is `no` access from a node to all the elements having the node as a corner!

. control - As in almost all UG objects this word is used bitwise for various
purposes.

. id - Each node is assigned a unique identification number when it is created.

. index - The 'index' indicates the position of the node in the node list. 
This component is provided mainly for compatibility reasons.

. pred,succ - All nodes of one grid level are in a double linked list.

. start - Points to the first element of the 'LINK' list. The 'LINK' list
provides access to all neighbors of the node.

. father,son - All nodes at the same position in the multigrid structure, i.e.
sharing a common 'VERTEX' are connected by a double linked list providing access to
the node on the next coarser ('father') and finer ('son') grid levels.

. myvertex - Pointer to the 'VERTEX' associated with the node.

. vector - Pointer to a 'VECTOR' containing degrees of freedom associated with the node.
Whether the 'NODE's are allowed to have degrees of freedom is selected at compile time
in the 'makefiles'. The setting of the makefile switches is reflected by the '__NODEDATA__'
define.

MACROS:

.vb
NODE *PREDN (NODE *p);
NODE *SUCCN (NODE *p);
.ve

Provides acces to the double linked list of nodes per level.

.vb
INT INDEX (NODE *p);
.ve

Returns the index of the node in the node list.

.vb
LINK *START (NODE *p);
.ve

Returns pointer to the first element of the 'LINK' list of a node.

.vb
NODE *NFATHER (NODE *p);
NODE *SONNODE (NODE *p);
.ve

.vb
VERTEX *MYVERTEX (NODE *p);
.ve

Returns a pointer to the 'VERTEX' of a node.

.vb
VECTOR *NVECTOR (NODE *p);
.ve

Returns a pointer to the 'VECTOR' associated with a node.

CONTROL WORDS:

`General macros available for all objects`
.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (NODE *p);                   27  5   Object type NDOBJ for a node. 
void SETOBJT (NODE *p, INT n); 

INT USED (NODE *p);                   23  1   used only temporarily
void SETUSED (NODE *p, INT n);

INT TAG (NODE *p);                    24  3   available for user
void SETTAG (NODE *p, INT n);

INT LEVEL (NODE *p);                  17  5   level on which node is
void SETLEVEL (NODE *p, INT n);               allocated

INT THEFLAG (NODE *p);                16  1   used only temporarily
void SETTHEFLAG (NODE *p, INT n);
-----------------------------------------------------------------------------
.ve

`Macros for the 'NODE' structure`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT CLASS (NODE *p);                  0   3   node class for local multigrid
void SETCLASS (NODE *p, INT n);               only for backward compatibility

INT NCLASS (NODE *p);                 3   3   node class for node on next level
void SETNCLASS (NODE *p, INT n);              only for backward compatibility

INT MODIFIED (NODE *p);               6   1   is true when node has been created
void SETMODIFIED (NODE *p, INT n);            or modified during last refinement 
                                              step. This in 2D only !

INT NPROP (NODE *p);                  7   8   node property derived from
void SETNPROP (NODE *p, INT n);               element property.
-----------------------------------------------------------------------------
.ve

SEE ALSO:

'VERTEX', 'LINK', 'VECTOR', 'GRID'.

D*/

/*D
LINK - Data type realizing a list of neighbors of a node

STRUCTURES:

.vb
struct link {

    // variables 
    unsigned INT control;       // object identification, various flags 
    struct link *next;          // ptr to next link                     
    struct node *nbnode;        // ptr to neighbor node                 
} ;

typedef struct link LINK;
.ve

DESCRIPTION:

The 'LINK' structures form a single linked list starting in each 'NODE'.
Two nodes are said to be neighbors if they are connected by an edge `in the mesh`.
Note that this is only the geometric neighborship, which can be different from the
algebraic neighborship derived from the non-zero structure of the global stiffness matrix.
Each 'LINK' provides a pointer to one neighbor of the 'NODE' where the list
starts. The neighbor relationship is symmetric, therefore if node `a` is a neighbor
of node `b` then `a` occurs in the list of `b` and vice versa. These two link structures
are then combined in an 'EDGE' structure.

. control - As in almost all UG objects this word is used bitwise for various
purposes.

. next - pointer to next 'LINK' object.

. nbnode - Pointer to neighboring node.

MACROS:

.vb
NODE *NBNODE (LINK *p);
.ve 

Returns pointer to a neighboring node that is stored in the 'LINK'.

.vb
LINK *NEXT (LINK *p);
.ve

Returns pointer to next 'LINK' in the list. As usual a 'NULL' pointer indicates
the end of the list.

.vb
EDGE *MYEDGE (LINK *p);
.ve

Provides access to the 'EDGE' where this given 'LINK' is part of. 

.vb
LINK *REVERSE (LINK *p);
.ve

Macro that provides fast access to the 'LINK' in the reverse direction.
If the given 'LINK' connects node `a` with node `b`, then 'REVERSE'
provides the 'LINK' in the list of node `b` pointing to `a`.

CONTROL WORDS:

`General macros available for all objects`
.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (LINK *p);                   27  5   Object type EDOBJ for first 
void SETOBJT (LINK *p, INT n);                LINK of an EDGE

INT USED (LINK *p);                   23  1   used only temporarily
void SETUSED (LINK *p, INT n);

INT THEFLAG (LINK *p);                16  1   used only temporarily
void SETTHEFLAG (LINK *p, INT n);
-----------------------------------------------------------------------------
.ve

`Macros for the 'LINK' structure`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT LOFFSET (LINK *p);                0   1   0 if first LINK of EDGE
void SETLOFFSET (LINK *p, INT n);             1 if second LINK of EDGE
-----------------------------------------------------------------------------
.ve

SEE ALSO:

'EDGE', 'NODE'.

D*/

/*D
EDGE - Data type realizing a directed connection of two nodes

STRUCTURES:

.vb
struct edge {                   // undirected edge of the grid graph    

    // variables 
    struct link links[2];       // two links                            
    
    #ifdef __MIDNODE__
    struct node *midnode;       // pointer to mid node on next finer grid
    #endif
    
    // associated vector if 
    #ifdef __EDGEDATA__
    VECTOR *vector;             // associated vector                    
    #endif
} ;

typedef struct edge EDGE;
.ve

DESCRIPTION:

The 'EDGE' data type combines 'LINK' structures to form an `undirected`
connection of two 'NODE's. An 'EDGE' represents an edge of the mesh.
Degrees of freedom can be associated with 'EDGE's as it is necessary in
quadratic, non-conforming or mixed finite elements.

. links - Array of two 'LINK's. In that way 'LINK's are always allocated pairwise
and in consecutive memory locations. This allows to switch easily from a given
'LINK' to the 'LINK' in reverse direction or to the 'EDGE'.

. midnode - In 3D a pointer to the node created on the midpoint of an edge is
needed during refinement (This is because many elements share an edge in 3D).

. vector - Pointer to a 'VECTOR' structure of appropriate size declared in the
'FORMAT'. '__EDGEDATA__' is defined if the appropriate makefile switches
have been set at compile time.

MACROS:

.vb
LINK *LINK0 (EDGE *p);
.ve

Pointer to first 'LINK' of an 'EDGE'.

.vb
LINK *LINK1 (EDGE *p);
.ve

Pointer to second 'LINK' of an 'EDGE'.

.vb
NODE *MIDNODE (EDGE *p);
.ve

Returns pointer to midnode (a node on the next finer grid level
that has been created on the given edge).

.vb
VECTOR *EDVECTOR (EDGE *p);
.ve

Returns pointer to the 'VECTOR' associated with the given 'EDGE'.

CONTROL WORDS:

`General macros available for all objects`
.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (EDGE *p);                   27  5   Object type EDOBJ for an edge
void SETOBJT (EDGE *p, INT n); 

INT USED (EDGE *p);                   23  1   used only temporarily
void SETUSED (EDGE *p, INT n);

INT LEVEL (EDGE *p);                  17  5   level on which edge is
void SETLEVEL (EDGE *p, INT n);               allocated

INT THEFLAG (EDGE *p);                16  1   used only temporarily
void SETTHEFLAG (EDGE *p, INT n);
-----------------------------------------------------------------------------
.ve

`Macros for the 'EDGE' structure`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT EOFFSET (EDGE *p);                0   1   Overlay with bit from LINK
void SETEOFFSET (EDGE *p, INT n); 

INT EXTRA (EDGE *p);                  1   1   True if additional edge is
void SETEXTRA (EDGE *p, INT n);               diagonal of quadrilateral. This is
                                              provided for backward compatibility

INT NO_OF_ELEM (EDGE *p);             2   7   Number of elements sharing the
void SET_NO_OF_ELEM (EDGE *p, INT n);         given edge. This is provided
void INC_NO_OF_ELEM (EDGE *p);                only in 3D version
void DEC_NO_OF_ELEM (EDGE *p); 

INT EDGENEW (EDGE *p);                16  1   True if edge has been created in
void SETEDGENEW (EDGE *p, INT n);             last refinement step. 3D only!
-----------------------------------------------------------------------------
.ve

SEE ALSO:

'LINK'

D*/


/*D
ELEMENT - Data type representing an element in the mesh

STRUCTURES:

.vb
struct generic_element {            // no difference between inner and bndel

    // variables 
    unsigned INT control;           // object identification, various flags 
    INT id;                         // unique id used for load/store        
    unsigned INT  flag;             // additional flags for elements        
    unsigned INT  property;         // we need more bits ...                
    
    // pointers 
	union element *pred, *succ;     // double linked list of elements
    void *refs[1];                  // variable length array managed by ug  
} ;

struct triangle {

    // variables 
    unsigned INT control;           // object identification, various flags 
    INT id;                         // unique id used for load/store        
    unsigned INT  flag;             // additional flags for elements        
    unsigned INT  property;         // we need more bits ...                
    
    // pointers 
    union element *pred, *succ;     // double linked list of elements       
    struct node *n[3];              // corners of that element              
    union element *father;          // father element on coarser grid       
    union element *sons[4];         // element tree                         
    union element *nb[3];           // dual graph                           
    
    // associated vector if 
    #ifdef __ELEMDATA__
    VECTOR *vector;                 // associated vector                    
    #endif

    struct elementside *side[3];    // only on bnd, NULL if interior side   
} ;

struct quadrilateral {

    // variables 
    unsigned INT control;           // object identification, various flags 
    INT id;                         // unique id used for load/store        
    unsigned INT  flag;             // additional flags for elements        
    unsigned INT  property;         // we need more bits ...                
    
    // pointers 
    union element *pred, *succ;     // double linked list of elements       
    struct node *n[4];              // corners of that element              
    union element *father;          // father element on coarser grid       
    union element *sons[4];         // element tree                         
    union element *nb[4];           // dual graph                           
    
    // associated vector if 
    #ifdef __ELEMDATA__
    VECTOR *vector;                 // associated vector                    
    #endif

    struct elementside *side[4];    // only on bnd, NULL if interior side   
} ;

struct tetrahedron {

    // variables 
    unsigned INT control;           // object identification, various flags 
    INT id;                         // unique id used for load/store        
    unsigned INT  flag;             // additional flags for elements        
    unsigned INT  property;         // we need more bits ...                
    
    // pointers 
    union element *pred, *succ;     // double linked list of elements       
    struct node *n[4];              // corners of that element              
    union element *father;          // father element on coarser grid       
    union element *sons[1];         // element tree                         
    union element *nb[4];           // dual graph                           
    
    // associated vector if 
    #ifdef __ELEMDATA__
    VECTOR *vector;                 // associated vector                    
    #endif

    // associated vector if 
    #ifdef __SIDEDATA__
    VECTOR *sidevector[4];          // associated vectors for sides         
    #endif

    struct elementside *side[4];    // only on bnd, NULL if interior side   
} ;

union element {
    struct generic_element ge;
    struct triangle        tr;
    struct quadrilateral   qu;
    struct tetrahedron     te;
} ;

typedef union element ELEMENT;
.ve

DESCRIPTION:

UG provides a flexible element concept, i.e. there may be different
types of elements in a mesh (currently 8). All element types are derived
from the 'generic_element' where the 'refs' array is allocated to the
appropriate length. Data types for the currently implemented three different
elements triangle, quadrilateral and tetrahedron are provided only
for illustration and debugging purposes. Internally only the 'generic_element'
is used. The 'TAG' field in the control word is used to identify the
element type at run-time, therefore the limitation to eight element types.
Memory requirements are also higher for elements having at least one
side on the boundary because additional pointers to boundary information (the
'ELEMENTSIDE' structure) is stored.
In 3D, degrees of freedom can be associated also with the sides of an element.
Since there is no data type to represent sides, the degrees of freedom associated
with a side of an element are accessed via the element (a side is shared by exactly
two elements, UG ensures the consistency of the pointers).

. control - As in almost all UG objects this word is used bitwise for various
purposes.

. id - Each element has a unique id.

. flag - A lot of information requiring only a small number of bits must be stored
for each element. Therefore a second control word, the 'flag', has been introduced.
The 'flag' is also used bitwise.

. property - Since 'control' and 'flag' were full, a third word had to be introduced that
can be used bitwise. A part of this word stores the element property, which is simple
a number per element. This number can be used to differentiate between different materials
for example.

. pred,succ - All elements of a grid level are connected by a double linked list.

. n - Array of pointers to the corner 'NODE's of an element.

. father - Pointer to element on the next coarser grid level that created 
the given element during refinement.

. sons - Array of pointers to elements on the next finer grid level that
have been created by refining the given element. In 2D all sons
are directly accessible, in 3D only one pointer is stored and a complete
list of sons is constructed by the function 'GetSons'.

. nb - Array of pointers to neighboring elements. There are as many neighbors
as the element has sides.

. vector - Pointer to 'VECTOR' that is associated with the element. Whether degrees
of freedom are allowed to be associated with elements is determined at compile-time
through appropriate makefile switches.

. sidevector - Array of pointers to 'VECTOR's associated with the sides of an element.
This option is available only in 3D. Whether 'VECTOR's are allowed in sides is determined
through switches in the makefiles at compile-time.

. side - Array of pointers to 'ELEMENTSIDE' structures. An 'ELEMENTSIDE' structure
is allocated for a side of an element that is part of a boundary segment (either
internal or external boundary). If no side of an element is on the boundary then
no 'side' array is available.

MACROS:

.vb
INT SIDES_OF_ELEM (ELEMENT *p);
.ve

Returns the number of sides of a given element. In 2D the number of sides and number
of edges of an element coincide. The 'nb', 'sidevector' and 'side'
arrays are of this size.

.vb
INT EDGES_OF_ELEM (ELEMENT *p);
.ve

Returns the number of edges of a given element. In 2D the number of sides and number
of edges of an element coincide.

.vb
INT CORNERS_OF_ELEM (ELEMENT *p);
.ve

Returns the number of corners of a given element. This is also the size of the 'n'
array.

.vb
INT SONS_OF_ELEM (ELEMENT *p);
.ve

Returns the maximum number of sons possible for a given element. This is the
size of the 'sons' array in 2D. The actual number of sons depends on the refinement
rule that has been applied to the element and is given by the 'NSONS' macro
(see CONTROL WORDS section below).

.vb
INT EDGES_OF_SIDE (ELEMENT *p,INT i);
.ve

Returns the number of edges of side 'i' of the given element. In 2D a side has always one
edge since edges and sides coincide.

.vb
INT CORNERS_OF_SIDE (ELEMENT *p,INT i);
.ve

Returns the number of corners of side 'i' of the given element.

.vb
#define CORNERS_OF_EDGE 2
.ve

This definition is provided only to make the description complete.

`The following macros determine the numbering scheme of an element. In each
element type the corners, edges and sides are numbered beginning with zero.
Each side again has a local numbering of its edges and corners and each edge
has a local numbering of its corners. We then need mappings of the numbering
scheme within edges and sides to the numbering schem within the element.`

.vb
INT EDGE_OF_SIDE (ELEMENT *p,INT s,INT e);
.ve

Returns the number of edge 'e' of side 's' within the element 'p'.

.vb
INT CORNER_OF_SIDE (ELEMENT *p,INT s,INT c);
.ve

Returns the number of corner 'c' of side 's' within the element 'p'.

.vb
INT CORNER_OF_EDGE (ELEMENT *p,INT e,INT c);
.ve

Returns the number of corner 'c' of edge 'e' within the element 'p'.

.vb
INT EDGE_WITH_CORNERS (ELEMENT *p,INT c0,INT c1);
.ve

Returns the number of the edge (with respect to numbering in the element 'p')
that connects corners with numbers 'c0' and 'c1' (with respect to numbering in
element 'p').

.vb
INT SIDE_WITH_EDGE (ELEMENT *p,INT e,INT k);
.ve

'SIDE_WITH_EDGE(p,e,0)' and 'SIDE_WITH_EDGE(p,e,1)' delivers the numbers
of the sides (with respect to numbering in 'p') that share edge number 'e'
(also with respect to the element).

.vb
INT CORNER_OF_SIDE_INV (ELEMENT *p,INT s,INT c);
.ve

When 'c' is the number of a corner and 's' is the number of a side
(both with respect to numbering in the element) then 
'CORNER_OF_SIDE_INV' returns the number of corner 'c' with respect
to the numbering in side 's' or '-1' if 's' does not contain corner 'c'.

.vb
INT EDGES_OF_CORNER (ELEMENT *p,INT c,INT k);
.ve

If 'c' is the number of a corner with respect to numbering within
the element then 'EDGES_OF_CORNER(p,c,k)' returns all numbers
of edges (with respect to 'p') that are connected to corner 'c'.
Since this number is variable a value of '-1' identifies an invalid entry.
The edges are numbered consecutively, i.e. if a '-1' is encountered
larger values of 'k' (less than 'EDGES_OF_ELEM(p)') will lead also to '-1').

.vb
INT SUCCE (ELEMENT *p);
INT PREDE (ELEMENT *p);
.ve

Return pointers to next and previous element of the double linked list of elements per level.

.vb
NODE *CORNER (ELEMENT *p,INT i);
.ve

Returns a pointer to corner 'i' of element 'p'. 'i' should be less than
'CORNERS_OF_ELEM(p)'.

.vb
ELEMENT *EFATHER (ELEMENT *p);
.ve

Returns a pointer to the father element.

.vb
ELEMENT *SON (ELEMENT *p,INT i);
.ve

Returns a pointer to son 'i' of 'p' in the element hierarchy. In 3D only 'i'=0 is
allowed and the function 'GetSons' should be used instead. 'i' should be
smaller than 'NSONS(p)'.

.vb
ELEMENT *NBELEM (ELEMENT *p,INT i);
.ve

Returns a pointer to neighboring element over side 'i'. 'i' should be less
than 'SIDES_OF_ELEM(p)'.

.vb
ELEMENTSIDE *SIDE (ELEMENT *p,INT i);
.ve

Returns a pointer to an 'ELEMENTSIDE' structure which describes the position of
side 'i' of 'p' with respect to a boundary segment. 'i' should be less
than 'SIDES_OF_ELEM(p)'. If no side of 'p' is part of the boundary (determined by
the 'OBJT', see below) then the 'SIDE' macro should not be used. If 'p' has
at least one side on a boundary then 'SIDE(p,i)' returns a 'NULL' pointer, if
side 'i' is not part of the boundary.

.vb
VECTOR *EVECTOR (ELEMENT *p);
.ve

Returns a pointer to the 'VECTOR' associated with the element. This
pointer is only available if the appropriate switches in the makefiles
have been set for element vectors.

.vb
VECTOR *SVECTOR (ELEMENT *p,INT i);
.ve

Returns a pointer to the 'VECTOR' associated with the side 'i'
of element 'p'. 'i' must be less than 'SIDES_OF_ELEM(p)'. This
pointer is only available if the appropriate switches in the makefiles
have been set for side vectors.


CONTROL WORDS:

`General macros available for all objects`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (ELEMENT *p);                27  5   Object type BEOBJ for an element
void SETOBJT (ELEMENT *p, INT n);             with at least one side on a
                                              boundary and IEOBJ else

INT USED (ELEMENT *p);                23  1   used only temporarily
void SETUSED (ELEMENT *p, INT n);

INT TAG (ELEMENT *p);                 24  3   identifies element type. E.g.
void SETTAG (ELEMENT *p, INT n);              3=triangle, 4=quadrilateral.
                                              should not be used anymore!

INT LEVEL (ELEMENT *p);               17  5   level on which element is
void SETLEVEL (ELEMENT *p, INT n);            allocated

INT THEFLAG (ELEMENT *p);             16  1   True if elements refinement rule
void SETTHEFLAG (ELEMENT *p, INT n);          changed during last refinement
                                              step. 3D only !
-----------------------------------------------------------------------------
.ve

`Macros for the 'ELEMENT' structure in 'control'`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT ECLASS (ELEMENT *p);              8   2   stores element class which is 
void SETECLASS (ELEMENT *p,INT n);            out of COPY_CLASS, 
                                              IRREGULAR_CLASS or REGULAR_CLASS

INT NSONS (ELEMENT *p);               10  4   number of sons of an element.
void SETNSONS (ELEMENT *p,INT n);

INT NEWEL (ELEMENT *p);               14  1   Set at creation time but never
void SETNEWEL (ELEMENT *p,INT n);             reset. Do not use it!
-----------------------------------------------------------------------------
.ve

`Macros for the 'ELEMENT' structure in 'flag' are all for internal use only`



`Macros for the 'ELEMENT' structure in 'property'`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT PROP (ELEMENT *p);                0   32  Stores element property number.
void SETPROP (ELEMENT *p,INT n);
-----------------------------------------------------------------------------
.ve

SEE ALSO:

'ELEMENT SIDE', 'NODE', 'VECTOR'.

D*/

/*D
ELEMENTSIDE - Data type for side of an element on the boundary

STRUCTURES:

.vb
struct elementside {

    // variables 
    unsigned INT control;               // object identification, various flags 
    struct bndsegdesc *segdesc;         // pointer to boundary segment desc     
    COORD lambda[MAX_CORNERS_OF_SIDE]   // parameter of side corners            
                        [DIM_OF_BND];
    // pointers 
	struct elementside *pred,*succ;     // double linked list
} ;

typedef struct elementside ELEMENTSIDE;
.ve

DESCRIPTION:

If an element has a side on the boundary an 'ELEMENTSIDE' structure
is allocated for that side, that stores the exact position of that
side with respect to a boundary segment.

. control - As in almost all UG objects this word is used bitwise for various
purposes.

. segdesc - Pointer to a 'BNDSEGDESC' structure giving access to the
boundary segment and boundary conditions.

. lambda - Array with parameter values for each corner of the side. The index
of the corner is with respect to the numbering within the side.

. pred,succ - Double linked list of 'ELEMENTSIDE' structures.

MACROS:

.vb
ELEMENTSIDE *SUCCS (ELEMENTSIDE *p);
ELEMENTSIDE *PREDS (ELEMENTSIDE *p);
.ve

Returns pointer to next and previos 'ELEMENTSIDE' structures.

.vb
BNDSEGDESC *SEGDESC (ELEMENTSIDE *p);
.ve

Returns a pointer to a 'BNDSEGDESC' structure giving access to 
boundary segment and boundary condition information.

.vb
COORD PARAM (ELEMENTSIDE *p,INT i,INT j);
.ve

Returns component 'j' of parameter of corner 'i' with respect to the boundary segment given by 
'SEGDESC(p)'.

CONTROL WORDS:

`General macros available for all objects`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (ELEMENTSIDE *p);            27  5   Object type ESOBJ for an element
void SETOBJT (ELEMENTSIDE *p, INT n);         with at least one side on a
-----------------------------------------------------------------------------
.ve

`no private control word entries are used`

SEE ALSO:

'ELEMENT', 'BNDSEGDESC'.

D*/

/*D
VECTOR - Data type for unknowns in sparse matrix structure

STRUCTURES:
.vb
struct vector {
    unsigned INT control;       // object identification, various flags 
    union geom_object *object;  // associated object                    
    
    struct vector *pred,*succ;  // double linked list of vectors        
    
    unsigned INT index;         // ordering of unknowns                 
    unsigned INT skip;          // used bitwise to skip unknowns        
    struct matrix *start;       // implements matrix                    
    
	BV_DESC block_descr;		// membership to the blockvector levels
	
    // user data 
    DOUBLE value[1];            // array of doubles                     
};

typedef struct vector VECTOR;
.ve

DESCRIPTION:

The 'VECTOR' data type is part of the sparse matrix vector data structure.
A 'VECTOR' stores a user definable number of 'DOUBLE' values (see 'FORMAT') and
is associated with a geometric object of the mesh (nodes, edges, sides and elements).
The size of the 'VECTOR' can be specified differently for each type of
geometric object, but not (yet) for each individual 'VECTOR' object.
Since there are four different geometric objects that can have degrees
of freedom, there are four different `vector types`. The vector type
is stored in the control word (see 'VTYPE' macro) and can have the
following values

.vb
    NODEVECTOR 
    EDGEVECTOR 
    SIDEVECTOR
    ELEMVECTOR
.ve

The 'VECTOR' provides access to the rows of the sparse matrix belonging to
all degrees of freedom stored in the vector.

. control - Used bitwise (see below).

. object - Pointer to the geometric object associated with the vector.

. pred,succ - Realizes double linked list.

. index - Reflects position of the 'VECTOR' in the double linked list.

. skip - Used bitwise to identify components of a 'VECTOR' that have Dirichlet boundary 
conditions. These components have to be treated differently in some parts of the solver.

. start - Points to first element of the 'MATRIX' list of a 'VECTOR'. This
list represents the rows of the matrix belonging to degrees of freedom in
the given 'VECTOR'.

. block_descr - Describes the position of this vector in the hierarchy of
'BLOCKVECTOR's. Only used for 'BLOCKVECTOR' mechanism.
	
. value - Array of double values. This array is allocated dynamically with the
size specified in the 'FORMAT' structure.

MACROS:

.vb
void *VOBJECT (VECTOR *v);
.ve

Returns a pointer to the object to which the 'VECTOR' belongs.

.vb
VECTOR *PREDVC (VECTOR *v);
VECTOR *SUCCVC (VECTOR *v);
.ve

Access to next and previous 'VECTOR' in the double linked list.

.vb
INT VINDEX (VECTOR *v);
.ve

Position of the 'VECTOR' in the doubl linked list. This is useful for
the implementation of some iterative schemes.

.vb
INT VSKIPME (VECTOR *v,INT n);
INT VVECSKIP (VECTOR *v,INT n);
INT VFULLSKIP (VECTOR *v,INT n);
void SETVSKIPME (VECTOR *v,INT n);
INT VECSKIP (VECTOR *v);
INT VECSKIPBIT (VECTOR *v,INT n);
void SETVECSKIPBIT (VECTOR *v,INT n);
.ve

????
Macros to modify the skip flags. 'VECSKIP' returns value of the skip word. Since it is
a macro it can also be used for assigning a value to the skip word, e.g.
'VECSKIP(v)=0' will reset all bits in the skip word. 'VECSKIPBIT' returns true
if the 'n' th bit of the skip word is set. 'SETVECSKIPBIT' sets the 'n'th
bit of the skip word to 1.

.vb
MATRIX *VSTART (VECTOR *v);
.ve

Returns a pointer to the first element of the 'MATRIX' list. The first
'MATRIX' in the list is the diagonal matrix block coupling degrees
of freedom in 'v' with itself.

.vb
DOUBLE VVALUE (VECTOR *v,INT n);
.ve

'VVALUE' returns the 'n'th component of the value field. 'VVALUE' is a macro and can
also be used for assignment, i.e. 'VVALUE(v,1)=0.0' is a valid statement.

.vb
DOUBLE *VVALUEPTR (VECTOR *v,INT n);
.ve

Returns a pointer to the 'n'th component of the value array.

.vb
NODE *VMYNODE (VECTOR *v);
EDGE *VMYEDGE (VECTOR *v);
ELEMENT *VMYELEMENT (VECTOR *v);
.ve

These macros return pointers the objects the vector belongs to with
appropriate type casts.

.vb
INT VUP(VECTOR *p);
void SETVUP(VECTOR *p,INT n);
INT VDOWN(VECTOR *p);
void SETVDOWN(VECTOR *p,INT n);
.ve

????

.vb
BV_DESC VBVD (VECTOR *v);
.ve

Returns the whole information about the position of this 'VECTOR' in the
hierarchy of 'BLOCKVECTOR's. This macro should only be applied if the
'BLOCKVECTOR' mechanism is in use.

.vb
INT VMATCH (VECTOR *v, BV_DESC *bvd, BV_DESC_FORMAT *bvdf);
.ve

Returns true if the 'VECTOR' belongs to the 'BLOCKVECTOR' given in the
blockvector description ('BV_DESC').

.vb
CAST_NVECTOR (VECTOR *p);
CAST_EDVECTOR (VECTOR *p);
CAST_SVECTOR (VECTOR *p,INT i);
CAST_EVECTOR (VECTOR *p);
.ve

????

CONTROL WORDS:

`General macros in 'control' word`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (VECTOR *p);                 27  5   Object type VEOBJ 
void SETOBJT (VECTOR *p, INT n);              

INT USED (VECTOR *p);                 23  1   used only temporarily
void SETUSED (VECTOR *p, INT n);

INT TAG (VECTOR *p);                  24  3   not used
void SETTAG (VECTOR *p, INT n);            

INT THEFLAG (VECTOR *p);              16  1   used only temporarily
void SETTHEFLAG (VECTOR *p, INT n);        
-----------------------------------------------------------------------------
.ve

`Macros for the 'VECTOR' structure in 'control'`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
VTYPE (VECTOR *v);                    0   2   Type of geometric object the
SETVTYPE (VECTOR *v, INT n);                  vector belongs to. Values:
                                              NODEVECTOR, EDGEVECTOR, SIDEVECTOR
                                              or ELEMVECTOR.

VCUSED (VECTOR *v);                   4   1   For internal use in ordering
SETVCUSED (VECTOR *v, INT n);                 routines.

VCOUNT (VECTOR *v);                   5   2   internal use
SETVCOUNT (VECTOR *v, INT n);

VECTORSIDE (VECTOR *v);               7   2   Side in VOBJECT where VECTOR
SETVECTORSIDE (VECTOR *v, INT n);             belongs to (SIDEVECTOR only)

VCLASS (VECTOR *v);                   11  2   Vector class for local multigrid
SETVCLASS (VECTOR *v, INT n);                 between 0 and 3.

VDATATYPE (VECTOR *v);                13  4   This is 2^VTYPE(v)
SETVDATATYPE (VECTOR *v, INT n);  

VNCLASS (VECTOR *v);                  17  2   Vector class of vector at same
SETVNCLASS (VECTOR *v, INT n);                position on finer level

VNEW (VECTOR *v);                     19  1   True if VECTOR has been created
SETVNEW (VECTOR *v, INT n);                   in last refinement step.

VCNEW (VECTOR *v);                    20  1   True if VECTOR got a new 
SETVCNEW (VECTOR *v, INT n);                  connection in refinement
-----------------------------------------------------------------------------
.ve

SEE ALSO:

'MATRIX', 'NODE', 'EDGE', 'ELEMENT', 'BLOCKVECTOR'.

D*/

/*D
MATRIX - Data type realizing sparse matrix structure

STRUCTURES:

.vb
struct matrix {
    unsigned INT control;   // object identification, various flags 
    
    struct matrix *next;    // row list                             
    struct vector *vect;    // destination vector                   
    
    // user data 
    DOUBLE value[1];        // array of doubles                     
};

typedef struct matrix MATRIX;
.ve

DESCRIPTION:

The 'MATRIX' data type is part of UGs sparse matrix vector data structure.
A 'MATRIX' stores all the matrix entries coupling two 'VECTOR's.
The number of entries in a 'MATRIX' depends on the geometric position
of the source and destination 'VECTOR', i.e. a 'MATRIX' coupling
a 'VECTOR' in 'NODE' with a 'VECTOR' in another 'NODE' can have a different
size than a 'MATRIX' coupling a 'VECTOR' in a 'NODE' with a
'VECTOR' in an 'EDGE'.
The 'MATRIX' structure forms a single linked list that contains all
couplings of the 'VECTOR' where the list starts (see the 'VSTART' macro
there).
Two 'MATRIX' objects are combined to build a 'CONNECTION' object.

MACROS:

.vb
MATRIX *MINC (MATRIX *m);
.ve

Adds 'sizeof(MATRIX)' to 'm' (of course the dynamic size of 'm').

.vb
MATRIX *MDEC (MATRIX *m);
.ve

Subtracts 'sizeof(MATRIX)' to 'm' (of course the dynamic size of 'm').

.vb
MATRIX *MNEXT (MATRIX *m);
.ve

Returns pointer to next 'MATRIX' in the list.

.vb
VECTOR *MDEST (MATRIX *m);
.ve

Returns pointer to destination 'VECTOR', i.e. the column 'VECTOR'. If 'm' is an element
of the 'MATRIX' list of some 'VECTOR' `a` and 'MDEST(m)='`b`, then 'm' contains
all the matrix entries of rows belonging `a` and columns belonging to `b`.
 
.vb
MATRIX *MADJ (MATRIX *m);
.ve

Returns a pointer to the transposed 'MATRIX', i.e. if 'm' couples 'VECTOR'
`a` with 'VECTOR' `b`, then 'MADJ(m)' couples `b` with `a`.

.vb
CONNECTION *MMYCON (MATRIX *m);
.ve

Returns a pointer to the 'CONNECTION' where 'm' is part of.

.vb
DOUBLE MVALUE (MATRIX *m,INT n);
.ve

Returns the 'n'th entry of the 'MATRIX' 'm'. The number of entries is
defined in the 'FORMAT' structure. 'MVALUE' is a macro and can also
be used for assignment, i.e. 'MVALUE(m,n)=0.0' is a valid
statement.

.vb
DOUBLE *MVALUEPTR (MATRIX *m,INT n);
.ve

Returns a pointer to the 'n'th entry of the 'MATRIX' 'm'.

.vb
MDESTINDEX (MATRIX *m);
.ve

Returns the 'index' component of the destination 'VECTOR'.


CONTROL WORDS:

`General macros in 'control' word`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (MATRIX *p);                 27  5   Object type MAOBJ 
void SETOBJT (MATRIX *p, INT n);              

INT USED (MATRIX *p);                 23  1   used only temporarily
void SETUSED (MATRIX *p, INT n);

INT TAG (MATRIX *p);                  24  3   not used
void SETTAG (MATRIX *p, INT n);            

INT THEFLAG (MATRIX *p);              16  1   used only temporarily
void SETTHEFLAG (MATRIX *p, INT n);        
-----------------------------------------------------------------------------
.ve

`Macros for the 'MATRIX' structure in 'control'`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
MOFFSET (MATRIX *p);                  0   1   Position of MATRIX in
SETMOFFSET (MATRIX *p,INT n);                 CONNECTION (0 or 1)

MROOTTYPE (MATRIX *p);                1   2   Position of source
SETMROOTTYPE (MATRIX *p,INT n);               VECTOR

MDESTTYPE (MATRIX *p);                3   2   Position of destination
SETMDESTTYPE (MATRIX *p,INT n);               VECTOR

MDIAG (MATRIX *p);                    5   1   True if MATRIX is the diagonal
SETMDIAG (MATRIX *p,INT n);                   entry. This is the first in
                                              the 'MATRIX' list of a 'VECTOR'.

MTYPE (MATRIX *p);                    6   6   Number identifying source and
SETMTYPE (MATRIX *p,INT n);                   dest position in a compact form

MUSED (MATRIX *p);                    12  1   currently not used
SETMUSED (MATRIX *p,INT n);

MSIZE (MATRIX *p);                    13  15  Size of the MATRIX in bytes
SETMSIZE (MATRIX *p,INT n);

MNEW (MATRIX *p);                     28  1   True if MATRIX has been 
SETMNEW (MATRIX *p,INT n);                    allocated in last refinement

CEXTRA (MATRIX *p);                   29  1   Returns value of EXTRA flag
SETCEXTRA (MATRIX *p,INT n);                  only valid for first matrix
                                              of a connection.

MDOWN (MATRIX *p);                    30  1   Input for ordering algorithm
SETMDOWN (MATRIX *p,INT n);

MUP (MATRIX *p);                      31  1   Input for ordering algorithm
SETMUP (MATRIX *p,INT n);
-----------------------------------------------------------------------------
.ve

SEE ALSO:

'VECTOR', 'CONNECTION'.

D*/

/*D
CONNECTION - Data type combing two 'MATRIX' structures

STRUCTURES:

.vb
typedef struct matrix CONNECTION;
.ve

DESCRIPTION:

The 'CONNECTION' data type consists of two 'MATRIX' objects stored consecutively
in memory. Since the 'MATRIX' objects size is determined at run-time the
'CONNECTION' is defined as a 'MATRIX'.

MACROS:

.vb
MATRIX *CMATRIX0 (CONNECTION *c);
MATRIX *CMATRIX1 (CONNECTION *c);
.ve

Pointer to first and second matrix of a 'CONNECTION'.

.vb
void SETCUSED (CONNECTION *c, INT n);
.ve

Executes 'MUSED' macro for both 'MATRIX' objects of a 'CONNECTION'. 

SEE ALSO:

'MATRIX', 'VECTOR'.

D*/


/*D
BLOCKVECTOR - Data type for substructuring a 'VECTOR' list

STRUCTURES:
.vb
struct blockvector
{
    unsigned INT control;           // object identification, various flags

    BLOCKNUMBER number;	            // logical blockvectornumber
    struct blockvector *pred,*succ; // double linked list of blockvectors
    VECTOR *first_vec;              // start vector of this blockvector
    VECTOR *end_vec;                // succ. of the last vector of this blockvector

    struct blockvector *first_son;  // start of blockvector list on next level
    struct blockvector *last_son;   // end of blockvector list on next level
};

typedef struct blockvector BLOCKVECTOR;
.ve

DESCRIPTION:

The 'BLOCKVECTOR' data structure realizes a mechanism to substructure a
'VECTOR' list as it is part of the sparse matrix vector data structure.
A 'BLOCKVECTOR' gives access to a sublist of the 'VECTOR' list, i.e. all
members of a 'BLOCKVECTOR' must be placed consecutively in the 'VECTOR' list.
A further consequence of this fact is that in most cases the 'VECTOR' list
must be reordered such that all 'VECTOR's forming a block are consecutive
before the 'BLOCKVECTOR' structure can be built. But apart from reordering
the 'VECTOR' list is not influenced by the 'BLOCKVECTOR' structure thus all
existing functions can be used furthermore without any changes.

To represent a sequence of sublists the 'BLOCKVECTOR's form a double
linked list that is anchored in a 'GRID' structure. It is not necessary
(but recommended) that all 'VECTOR's of a grid belong to a 'BLOCKVECTOR'.

The 'VECTOR' list represented by a 'BLOCKVECTOR' can be substructured further.
The corresponding 'BLOCKVECTOR' list is anchored in the parent 'BLOCKVECTOR'.
In this way a `tree-like hierarchical data structure` is realized representing
a natural parent-child relationship. All technical terms concerning tree-like
data structures can easily be translated. 

Furthermore a blockmatrix structure is induced by the 'BLOCKVECTOR' structure
without any additional amount of memory: 2 'BLOCKVECTOR's, considered as
row- and column-blockvector, determine a blockmatrix in the natural way.
Such a blockmatrix describes consequently how the column-blockvector
influences the row-blockvector. Notice: some macros for the
data structure 'MATRIX' are not useful or have a different semantic for a 
blockmatrix; this are the macros 'MNEXT' (provides not the next matrix element
of the blockmatrix but of the whole matrix), 'MADJ' (the returned matrix
element belongs not necessary to the blockmatrix; it holds only if the
blockmatrix lies on the diagonal).

. control - Used bitwise (see below).

. number - Number describing the position in a 'BLOCKVECTOR' list. Should be
unique within each list.

. pred,succ - Realizes double linked list.

. first_vec - Pointer in the 'VECTOR' list to the first 'VECTOR' belonging the this 'BLOCKVECTOR'.

. end_vec - Pointer to the first 'VECTOR' `after` the 'VECTOR' sublist
represented by this 'BLOCKVECTOR'. Is 'NULL' if the 'BLOCKVECTOR' represents
the tail of the 'VECTOR' list.

. first_son,last_son - Start and end of blockvector list on next level

CONSTANTS:

.vb
BVDOWNTYPEVECTOR = 0
BVDOWNTYPEBV = 1
.ve

Symbolic values for BVDOWNTYPE. See MACROS.


MACROS:

.vb
INT BVDOWNTYPE ( BLOCKVECTOR *bv );
void SETBVDOWNTYPE ( BLOCKVECTOR *bv, INT n );
.ve

Reads resp. sets the 'BLOCKVECTOR' type: is BVDOWNTYPEBV if there is a further
level of 'BLOCKVECTOR's else is BVDOWNTYPEVECTOR, i.e. the 'BLOCKVECTOR' is
the last one in the hierarchy and the next "level" is the 'VECTOR' sublist itself.

.vb
BLOCKNUMBER BVNUMBER ( BLOCKVECTOR *bv );
.ve

Number of the 'BLOCKVECTOR'.

.vb
BLOCKVECTOR *BVPRED ( BLOCKVECTOR *bv );
BLOCKVECTOR *BVSUCC ( BLOCKVECTOR *bv );
.ve

Access to next and previous 'BLOCKVECTOR' in the double linked list.

.vb
VECTOR *BVFIRSTVECTOR ( BLOCKVECTOR *bv );
VECTOR *BVENDVECTOR ( BLOCKVECTOR *bv );
.ve

Access to the first and the successor of the last 'VECTOR' in the sublist
represented by this 'BLOCKVECTOR'.

.vb
VECTOR *BVDOWNVECTOR ( BLOCKVECTOR *bv );
.ve

Use only if BV_IS_LEAF_BV(bv)==TRUE! Equivalent to BVFIRSTVECTOR(bv).

.vb
BLOCKVECTOR *BVDOWNBV ( BLOCKVECTOR *bv );
BLOCKVECTOR *BVDOWNBVEND ( BLOCKVECTOR *bv );
.ve

Use only if BV_IS_LEAF_BV(bv)==FALSE! Returns the first resp. last member
of the 'BLOCKVECTOR' list on the next level (down the tree).

.vb
INT BV_IS_LEAF_BV ( BLOCKVECTOR *bv );
.ve

Returns true if the 'BLOCKVECTOR' is a leaf in the tree-like 'BLOCKVECTOR'
hierarchy, i.e. if BVDOWNTYPE(bv)==BVDOWNTYPEVECTOR.


CONTROL WORDS:

`General macros in 'control' word`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
INT OBJT (BLOCKVECTOR *p);            27  5   Object type BLOCKVOBJ
void SETOBJT (BLOCKVECTOR *p, INT n);

INT USED (BLOCKVECTOR *p);            23  1   not used
void SETUSED (BLOCKVECTOR *p, INT n);

INT TAG (BLOCKVECTOR *p);             24  3   not used
void SETTAG (BLOCKVECTOR *p, INT n);

INT THEFLAG (BLOCKVECTOR *p);         16  1   not used
void SETTHEFLAG (BLOCKVECTOR *p, INT n);
-----------------------------------------------------------------------------
.ve

`Macros for the 'BLOCKVECTOR' structure in 'control'`

.vb
Macro name                            Pos Len Purpose
-----------------------------------------------------------------------------
BVDOWNTYPE ( BLOCKVECTOR *bv );       0   1   Type of BLOCKVECTOR:
SETBVDOWNTYPE ( BLOCKVECTOR *bv, INT n );     BVDOWNTYPEVECTOR if object is 
                                              a leaf in the tree-like 
                                              'BLOCKVECTOR' hierarchy,
                                              BVDOWNTYPEBV else.
-----------------------------------------------------------------------------
.ve

RELATED~FUNCTIONS:

. CreateBlockvector - Allocates a new 'BLOCKVECTOR' (from the multigrids memory).

. DisposeBlockvector - Returns an unused 'BLOCKVECTOR' to the multigrids memory.

. FreeAllBV - Disposes all 'BLOCKVECTOR's related to one grid.

. FreeBVList - Disposes blockvector-list and all its sons.

. FindBV - Find the described blockvector in the grid.

. CreateBVStripe - Creates a stripewise domain decomposition.

. CreateBVDomainHalfening - Creates a recursive domain halfening decomposition.

. blas~routines~for~'BLOCKVECTOR' - ~

EXAMPLES:

Let a stripewise decomposition be given and the 'BLOCKVECTOR's ordered
ascendend resp. their numbers. Then the following code fragments
set the 'IND' component of the 'VECTOR's of all 'BLOCKVECTOR's the the
number of their 'BLOCKVECTOR'. The result is a 'VECTOR' list containing
in the IND component the sequence "0,0,...0,1,1,...1,2,2,...,2,3,3,..., ...".

First using the direct access to the 'BLOCKVECTOR' list of the grid:~
.vb
    BLOCKVECTOR *bv;

    for ( bv = GFIRSTBV( grid ); bv != NULL; bv = BVSUCC( bv ) )
        dsetBS( bv, IND, (DOUBLE)BVNUMBER( bv ) );
.ve

The second variant uses a 'BV_DESC' instead of the pointer:~
.vb
    BV_DESC my_bvd;
    INT i, found;

    BVD_INIT( &my_bvd );

    for ( i = 0, found = GM_OK; found == GM_OK; i++ )
    {
        (void)BVD_PUSH_ENTRY( &my_bvd, i, &one_level_bvdf );
        found = dsetGS( grid, &my_bvd, &one_level_bvdf, IND, (DOUBLE)i );
        BVD_DISCARD_LAST_ENTRY( &my_bvd );
    }
.ve

SEE ALSO:

'VECTOR', 'MATRIX', 'BV_DESC', 'BV_DESC_FORMAT', 'BLOCKNUMBER', 'BLOCKLEVEL',
'CreateBlockvector', 'DisposeBlockvector', 'FreeAllBV', 'FreeBVList', 'FindBV',
'CreateBVStripe', 'CreateBVDomainHalfening ', 'blas_routines'.

D*/


/*D
BLOCKLEVEL - Data type for a level number in a 'BLOCKVECTOR' hierarchy

STRUCTURES:

.vb
typedef unsigned char BLOCKLEVEL;	
.ve

DESCRIPTION:

To handle a levelnumber in a 'BLOCKVECTOR' hierarchy use this data type.
To save memory this type is designed to be as small as possible: more
than a few dozens of levels will never occure.

Valid levels are in the range 0..MAX_BV_LEVEL.

CONSTANTS:

.vb
MAX_BV_LEVEL = UCHAR_MAX
.ve

Largest admissible 'BLOCKVECTOR' level number.

SEE ALSO:

'BLOCKVECTOR', 'BV_DESC', 'BV_DESC_FORMAT', 'BLOCKNUMBER'.

D*/


/*D
BLOCKNUMBER - Data type for the position of 'BLOCKVECTOR' in a 'BLOCKVECTOR' list

STRUCTURES:

.vb
typedef unsigned SHORT BLOCKNUMBER;
.ve

DESCRIPTION:

To handle a number of a 'BLOCKVECTOR' in a 'BLOCKVECTOR' list use this
data type. To save memory this type is designed to be small, since more
than MAX_BV_NUMBER will never occure.

Valid numbers are in the range 0..MAX_BV_NUMBER.

CONSTANTS:

.vb
NO_BLOCKVECTOR = ((BLOCKNUMBER)~0)
.ve

Number to indicate "there is no blockvector";
largest number of type 'BLOCKNUMBER'.

.vb
MAX_BV_NUMBER = (NO_BLOCKVECTOR - 1)
.ve

Largest admissible 'BLOCKVECTOR' number.

SEE ALSO:

'BLOCKVECTOR', 'BV_DESC', 'BV_DESC_FORMAT', 'BLOCKLEVEL'.

D*/


/*D
BVD_ENTRY_TYPE - Data type for storing a sequence of blockvector numbers bitwise

STRUCTURES:

.vb
typedef unsigned INT BVD_ENTRY_TYPE 
.ve

DESCRIPTION:

A component of this type in the 'BV_DESC' struct-type stores a sequence
of blockvector numbers bitwise. For details refer to 'BV_DESC'.

If you need more memory than 'BVD_ENTRY_TYPE' offers enlarge the type to
'unsigned long'. But remember: Every 'VECTOR' contains such a
'BVD_ENTRY_TYPE'. So choose this type as small as possible.
 
SEE ALSO:

'BLOCKVECTOR', 'BV_DESC', 'BV_DESC_FORMAT', 'BLOCKNUMBER'.

D*/


/*D
BV_DESC - Data type for handling a sequence of blockvector numbers

STRUCTURES:
.vb
struct blockvector_description
{
    BVD_ENTRY_TYPE entry;    // sequence of block levels according to
                             // a certain blockvector_description_format
    BLOCKLEVEL current;      // levels 0..'current'-1 currently valid
    BLOCKLEVEL read;         // level 'read' is next to be read
};

typedef struct blockvector_description BV_DESC;
.ve

DESCRIPTION:

To specify a 'BLOCKVECTOR' you can describe the "path" through the hierarchy
of 'BLOCKVECTOR's from the root to the certain 'BLOCKVECTOR'. Since each
'BLOCKVECTOR' has a unique number within the list in which it is stored
you can describe the path in terms of the blockvector number beeing traversed
during the walk. And such a sequence of blocknumbers is managed by 'BV_DESC'.

Since each 'VECTOR' contains a 'BV_DESC' this data structure should be as
small as possible. To achieve this goal, the blockvector numbers are not
stored as an array of BLOCKNUMBER (which would be the simpliest way to do
the task) but they are stored bitwise: the bits of the storage 'entry' are
broken up into packets each containing one blockvector number. The size
of all packets must be equal and is given in a 'BV_DESC_FORMAT' structure
(see there for more information). The aim is to have packets as small as
possible but large enough to hold the largest occuring number; this gives you
the maximum possible number of packets and thus of blockvector levels you can
process.

The "packets" are stored beginning from the lowest bits. The next "packet"
in which a number can be stored is given by 'current'. The masks necessary
to access the different "packets" are provided by a 'BV_DESC_FORMAT'
structure. Thus each function working on a 'BV_DESC' needs also a
'BV_DESC_FORMAT'. Be sure to use always the same format for a certain
'BV_DESC' after the first use.

. entry - Contains the pure information about the sequence of blockvector numbers.

. current - Number of levels currently stored in 'entry'. The levels
are counted 0..'current'-1.

. read - Number of level next to be read. Used for a sequential reading of
the level numbers.

CONSTANTS:

.vb
BVD_MAX_ENTRIES = (sizeof(BVD_ENTRY_TYPE)*CHAR_BIT)
.ve

Maximum number of entries in a BVD; NOTE: the actual available
number of entries depends on the range of each entry given in a
'BV_DESC_FORMAT'.


MACROS:

.vb
BLOCKLEVEL BVD_NR_ENTRIES ( BV_DESC *bvd );
.ve

The number of stored 'BLOCKVECTOR' numbers. 0 means no entry stored.

.vb
void BVD_INIT ( BV_DESC *bvd );
.ve

Initializes a 'BV_DESC'. Be sure to call this macro before the first use.

.vb
INT BVD_PUSH_ENTRY ( BV_DESC *bvd, BLOCKNUMBER bnr, BV_DESC_FORMAT *bvdf );
void BVD_DISCARD_LAST_ENTRY ( BV_DESC *bvd );
.ve

Use the macro 'BVD_PUSH_ENTRY' to add a further number to the already stored sequence
of blockvector numbers. The return value of this macro is the value of the
corresponding call to the internal function 'PushEntry'.

The macro 'BVD_DISCARD_LAST_ENTRY' removes the latest blockvector number from
the stored sequence.

With this 2 macros a "stack" mechanism is realized, where the
number of the root-blockvector is at the bottom of the stack and the number
for the next level is pushed at the top of stack. Note: the traditionally
"pop" corresponds to 'BVD_DISCARD_LAST_ENTRY' but the value is thrown away
because you usually do not need the previous "pushed" value.

.vb
void BVD_INIT_SEQ_READ ( BV_DESC *bvd );
BLOCKNUMBER BVD_READ_NEXT_ENTRY ( BV_DESC *bvd, BV_DESC_FORMAT *bvdf );
.ve

This 2 macros allow a sequential reading of the stored 'BLOCKNUMBER's.
'BVD_INIT_SEQ_READ' must be called before the first reading access. After
this each call to 'BVD_READ_NEXT_ENTRY' returns the next 'BLOCKNUMBER'
starting with the first stored number. You can call this macro as often
as you want; after the last stored number everytime 'NO_BLOCKVECTOR'
is returned.

.vb
void BVD_SET_ENTRY ( BV_DESC *bvd, BLOCKLEVEL level, BLOCKNUMBER bnr, 
                     BV_DESC_FORMAT *bvdf );
void BVD_GET_ENTRY ( BV_DESC *bvd, BLOCKLEVEL level, BV_DESC_FORMAT *bvdf );
.ve

This 2 macros give you random access to the single "packets"
(i.e. blocknumbers). The 'level' must be within the range described in 'bvdf'.

.vb
INT BVD_IS_SUB_BLOCK ( BV_DESC *bvd_a, BV_DESC *bvd_b, BV_DESC_FORMAT *bvdf );
.ve

Returns true if 'bvd_a' is a subblock of 'bvd_b', i.e. all the entries in
'bvd_b' must be same as in 'bvd_a'.

EXAMPLES:

Let always a pointer 'my_bvdf' to a 'BV_DESC_FORMAT' be given.

To store a sequence of numbers use:~
.vb
    BV_DESC my_bvd;
    INT error = GM_OK;

    BVD_INIT( &my_bvd );
    error = BVD_PUSH_ENTRY( &my_bvd, number0, my_bvdf );
    error |= BVD_PUSH_ENTRY( &my_bvd, number1, my_bvdf );
    error |= BVD_PUSH_ENTRY( &my_bvd, number2, my_bvdf );
    if ( error != GM_OK )
        // there was not enough capacity to store 3 numbers in the given format
.ve

To read this sequence again use:~
.vb
    BVD_INIT_SEQ_READ( &my_bvd );
    number0 = BVD_READ_NEXT_ENTRY( &my_bvd, my_bvdf );
    number1 = BVD_READ_NEXT_ENTRY( &my_bvd, my_bvdf );
    number2 = BVD_READ_NEXT_ENTRY( &my_bvd, my_bvdf );
    if ( number2 == NO_BLOCKVECTOR )
        // there were stored less than 3 numbers
.ve

SEE ALSO:

'BLOCKVECTOR', 'BV_DESC_FORMAT', 'BLOCKNUMBER', 'BLOCKLEVEL', 'BVD_ENTRY_TYPE'.

D*/


/*D
BV_DESC_FORMAT - Data type for defining the storage pattern used in 'BV_DESC'

STRUCTURES:
.vb
struct blockvector_description_format
{
    INT bits;                                       // bits per blocknumberentry
    BLOCKLEVEL max_level;                           // max. number of entries
    BVD_ENTRY_TYPE level_mask[BVD_MAX_ENTRIES];     // see below
    BVD_ENTRY_TYPE neg_digit_mask[BVD_MAX_ENTRIES]; // see below
};

typedef struct blockvector_description_format BV_DESC_FORMAT;
.ve

DESCRIPTION:

As in the description of 'BV_DESC' explained a sequence of 'BLOCKNUMBER's
is stored bitwise in 'BV_DESC'. For each number a certain number of bits
is reserved forming one "packet". This "packets" are stored consecutively
in the memory.

Every function working with a 'BV_DESC' needs the corresponding
'BV_DESC_FORMAT' to interpret the memory correctly. Be sure to use for
a certain 'BV_DESC' always the same format; otherwise the consistency
of the data will be corrupted. Sure, it would be more safe to store
the format with the 'BV_DESC' together, but the memory demand would be too
big.

The following variables are used to manage the handling of the "packets".
They are used internally by 'BV_DESC', a user has not to care about them.

. bits - The number of bits to be used for each blocknumber entry.

. max_level - The maximum number of entries that can be stored. This quantity
depends on the constant 'BVD_MAX_ENTRIES' defined with 'BV_DESC'.

. level_mask - This array contains the masks to isolate the entry for
a certain level; count 0..'max_level'-1.

. neg_digit_mask - This array contains the masks to clear the entry for
a certain level; count 0..'max_level'-1. This masks are the precomputed
complements of 'level_mask'.

PREDEFINED VARIABLES:

Often used formats are predefined. You can give their adresses directly to
the called function working with a 'BV_DESC' without any initialization.

.  DH_bvdf  - Useful for domain halfening methods (up to 4 blocks per level).

.  one_level_bvdf - Maximum number of blocks in a level but only 1 level.

EXAMPLES:

If your desires are fulfilled by one of the predefined variables, simple use
it. For example if you want to have only one blockvector level (e.g. for
stripewise domain decomposition) use 'one_level_bvdf' for setting up a
'BV_DESC':~
.vb
    BV_DESC my_bvd;

    BVD_INIT( &my_bvd );
    if ( BVD_PUSH_ENTRY( &my_bvd, blocknumber, &one_level_bvdf ) != GM_OK )
        // unexpected error; one number can always be stored.
    // work on with my_bvd
.ve

To create a customized format use 'InitBVDF'. For example to create
a format for managing a octree-like structure (that is subdividing a
3D cube into 8 subcubes) you can use the following command:~
.vb
   BV_DESC_FORMAT my_bvdf;

   InitBVDF( &my_bvdf, 8 );
.ve

SEE ALSO:

'BLOCKVECTOR', 'BV_DESC', 'BVD_ENTRY_TYPE', 'InitBVDF'.

D*/


/*D
GRID - Data type giving access to all objects on a grid level

STRUCTURES:

.vb
struct grid {

    // variables 
    unsigned INT control;           // object identification, various flags 
    INT status;                     // possible values see defines above    
    INT level;                      // level of that grid                   
    INT nVert;                      // number of vertices                   
    INT nNode;                      // number of nodes                      
    INT nElem;                      // number of elements                   
    INT nEdge;                      // number of edges                      
    INT nVector;                    // number of vectors                    
    INT nCon;                       // number of Connections                
    INT nSide;                      // number of element sides              
    
    // pointers 
    union  element *elements;       // pointer to first element             
    union  element *lastelement;    // pointer to last element              
    union  vertex *vertices;        // pointer to first vertex              
    union  vertex *lastvertex;      // pointer to last vertex               
    struct elementside *sides;      // pointer to first boundary side       
    struct node *firstNode;         // pointer to first node                
    struct node *lastNode;          // pointer to last node                 
    VECTOR *firstVector;            // pointer to first vector              
    VECTOR *lastVector;             // pointer to last vector               
	BLOCKVECTOR *firstblockvector;	// pointer to the first blockvector
	BLOCKVECTOR *lastblockvector;	// pointer to the last blockvector
    struct grid *coarser, *finer;   // coarser and finer grids              
    struct multigrid *mg;           // corresponding multigrid structure    
} ;

typedef struct grid GRID;
.ve

DESCRIPTION:

The 'GRID' data type provides access to all objects defined on a grid level.
All the pointers to the first list elements are there.

. control - used bitwise as usual.

. status - A word storing status information. This can be used also by the
problem class, e.g. to store whether the grid level is assmbled or not.

. level - Level within the 'MULTIGRID' structure.

. nVert - Number of 'VERTEX' objects used on that grid level.

. nNode - Number of 'NODE' objects used on that grid level.

. nElem - Number of 'ELEMENT' objects used on that grid level.

. nEdge - Number of 'EDGE' objects used on that grid level.

. nVector - Number of 'VECTOR' objects used on that grid level.

. nCon - Number of 'CONNECTION' objects used on that grid level.

. nSide - Number of 'ELEMENTSIDE' objects used on that grid level.

. elements,lastelement - Pointers to first and last element of the
'ELEMENT' list.

. vertices,lastvertex - Pointers to first and last 'VERTEX' of that grid level.

. sides - Pointer to first element of the 'ELEMENTSIDE' list.

. firstNode,lastNode - Pointers to first and last 'NODE' on that level.

. firstVector,lastVector - Pointers to first and last 'VECTOR'
on that grid level.

. firstblockvector,lastblockvector - Pointer to the first and last
'BLOCKVECTOR' on the first level. Valid only if the 'BLOCKVECTOR'
mechanism is used, otherwise they are 'NULL'.

. coarser,finer - Pointers to finer and coarser grid levels within
the 'MULTIGRID' structure. A 'NULL' pointer indicates that
a grid level does not exist.

. mg - Pointer to corresponding 'MULTIGRID' structure.

MACROS:

.vb
INT GLEVEL (GRID *p);
.ve

Returns the level of the 'GRID' within the 'MULTIGRID' structure.

.vb
INT GSTATUS (GRID *p);
.ve

Returns grid status field. Bit 0 of the grid status is set to 1 if this
grid level has been manipulated in the last refinement step.

.vb
void SETGSTATUS (GRID *p,n);
void RESETGSTATUS (GRID *p,n);
.ve

Set or reset all bits that are 1 in the mask 'n'.

.vb
ELEMENT *FIRSTELEMENT (GRID *p);
ELEMENT *LASTELEMENT (GRID *p);
.ve

Return pointers to first and last 'ELEMENT'.

.vb
VERTEX *FIRSTVERTEX (GRID *p);
VERTEX *LASTVERTEX (GRID *p);
.ve

Return pointers to first and last 'VERTEX' of the 'GRID'.

.vb
ELEMSIDE *FIRSTELEMSIDE (GRID *p);
.ve

Return pointer to first element of the 'ELEMENTSIDE' list.

.vb
NODE *FIRSTNODE (GRID *p);
NODE *LASTNODE (GRID *p);
.ve

Return pointer to first and last 'NODE' on that grid level.

.vb
VECTOR *FIRSTVECTOR (GRID *p);
VECTOR *LASTVECTOR (GRID *p);
.ve

Return pointer to first and last 'VECTOR' of that grid level.

.vb
BLOCKVECTOR *GFIRSTBV(GRID *p);
BLOCKVECTOR *GLASTBV(GRID *p);
.ve

Return pointer to first and last 'BLOCKVECTOR' of that grid level.

.vb
GRID *UPGRID (GRID *p);
GRID *DOWNGRID (GRID *p);
.ve

Return pointer to finer and coarser grid levels.

.vb
MULTIGRID *MYMG (GRID *p);
.ve

Return pointer to associated 'MULTIGRID' structure.

.vb
INT NV (GRID *p);
INT NN (GRID *p);
INT NT (GRID *p);
INT NE (GRID *p);
INT NS (GRID *p);
INT NVEC (GRID *p);
INT NC (GRID *p);
.ve

Return number of 'VERTEX' ('NV'), 'NODE' ('NN'), 'ELEMENT' ('NT'), 'EDGE' ('NE'), 'ELEMENTSIDE'
('NS'), 'VECTOR' ('NVEC') and 'CONNECTION' ('NC') objects allocated on that grid level.

CONTROL WORDS:

No entries of the control word are currently used.

SEE ALSO:

'MULTIGRID', 'ELEMENT', 'NODE', 'VERTEX', 'ELEMENTSIDE', 'VECTOR', 'MATRIX'.

D*/

/*D
MULTIGRID - Data type representing a complete multigrid structure

STRUCTURES:

.vb
struct multigrid {

    // env item 
    ENVVAR v;
    
    // variables 
    INT status;                     // possible values, see above           
    INT vertIdCounter;              // count objects in that multigrid      
    INT nodeIdCounter;              // count objects in that multigrid      
    INT elemIdCounter;              // count objects in that multigrid      
    INT topLevel;                   // depth of the element tree            
    INT currentLevel;               // level we are working on              
    struct domain *theDomain;       // pointer to domain definition         
    struct format *theFormat;       // pointer to format definition         
    struct problem *theProblem;     // pointer to problem definition        
    struct bndsegdesc *segments;    // array of combined boundary descriptio
    INT numOfSegments;              // number of entries in the array above 
	INT numOfSubdomains;			// number of subdomains
    union vertex **corners;         // pointer to array of pointers to corne
    INT numOfCorners;               // number of entries in the array above 
    HEAP *theHeap;                  // associated heap structure            

    // pointers 
    struct grid *grids[MAXLEVEL];   // pointers to the grids                
    void *freeObjects[MAXOBJECTS];  // pointer to allocated but unused objs 
    void *freeVectors[MAXVECTORS];  // pointer to allocated but unused objs 
    void *freeConnections[MAXCONNECTIONS];// ptr to alloc. but unused objs  

    // selection 
    INT NbOfSelections;             // number of selected objects           
    INT SelectionMode;              // selectionmode (see above)            
    union geom_object *Selection[MAXSELECTION]; // pointer to selec. objects
    
    // user data 
	void *GenData;					// general user data space
	HEAP *UserHeap;					// user heap
} ;

typedef struct multigrid MULTIGRID;
.ve

DESCRIPTION: 

Data type providing access to all information about the complete
multigrid hierarchy, problem description and memory management information.
This is the root of all.

. v - The 'MULTIGRID' is an environment item, i.e. it resides in the environment
tree. 'v' stores also the name of the 'MULTIGRID' as it is declared in the 'new'
and 'open' commands.

. status - Multigrid status word.

. vertIdCounter,nodeIdCounter,elemIdCounter - Counters used to assign unique
identification numbers to 'VERTEX', 'NODE' and 'ELEMENT' objects. The counter
wraps around after 2^32 objects have been allocated !

. topLevel - Finest grid level currently allocated in the 'MULTIGRID'.

. currentLevel - Any number between 0 and 'topLevel'. The 'currentLevel'
is used by many commands that work on a grid level as default value. It can
be changed with the 'level' command from the UG shell. 

. theDomain - Pointer to a 'DOMAIN' structure that is to be used for the
mesh described by the 'MULTIGRID'.

. theFormat - Pointer to a 'FORMAT' structure describing all parameters
of the UG data structure that can be selected at run-time.  Especially
there are a lot of user definable data spaces in the basic objects.

. theProblem - Pointer to a 'PROBLEM' structure giving access to the
user defined coefficient functions and boundary conditions that are
appropriate for the selected problem class.

. numOfSegments - Number of 'BNDSEGDESC' structures accessible in the 'segments'
array. This corresponds to the number of boundary segments in 'theDomain'.

. numOfSegments - Number of subdomains, used for the grid generator.

. segments - Array of 'BNDSEGDESC' structures. Index `i` in that array corresponds
to boundary segment `i`.

. corners - Array of Pointers to 'VERTEX' structures that are allocated at the
`corners` of 'theDomain'. 

. numOfCorners - Number of corners of 'theDomain'. This is also the size of the
'corners' array.

. theHeap - Pointer to a 'HEAP' structure allocated for that 'MULTIGRID'. The size
of this heap is selected with the 'open' and 'new' commands.

. grids - Array of pointers to 'GRID' structures representing the individual
levels of the multigrid hierarchy.

. freeObjects - List of free objects sorted by object number. Memory management in
UG is such that new memory for an object is only allocated when no free object of the requested type
is available. If an object is no longer needed (e.g. when coarsening a mesh) it is
inserted in the appropriate list of free objects.

. freeVectors,freeConnections - List of free 'VECTOR' and 'CONNECTION'
objects sorted by type. Same comment as for 'freeObjects' applies.

. Selection - Array of pointers to geometric objects that have been selected
with the mouse in the graphical user interface.

. NbOfSelections - Number of objects in the selection buffer ('Selection').

. SelectionMode - Indicates type of objects in the selection buffer. Currently
'nodeSelection'  and 'elementSelection' is possible.

. GenData - Management of general user data space in multigrid. At initialisation time
different modules can (pre)allocate storage which will (actually) be allocated in
each multigrid when it is opened. Storage is allocated and addressed by calls of
'DefineMGUDBlock' and 'GetMGUDBlockDescriptor' resp. See also the macros below.

MACROS:

.vb
INT MGSTATUS (MULTIGRID *mg);
.ve 

Return multigrid status. This is a macro, so assignment 'MGSTATUS(mg)=0' is
also allowed.

.vb
INT VIDCNT (MULTIGRID *mg);
INT NIDCNT (MULTIGRID *mg);
INT EIDCNT (MULTIGRID *mg);
.ve

Access to values of the vertex, node and element id counters.

.vb
INT TOPLEVEL (MULTIGRID *mg);
INT CURRENTLEVEL (MULTIGRID *mg);
.ve

Access to top and current level.

.vb
DOMAIN *MGDOMAIN (MULTIGRID *mg);
FORMAT *MGFORMAT (MULTIGRID *mg);
PROBLEM *MGPROBLEM (MULTIGRID *mg);
.ve
Returns pointer to 'DOMAIN', 'FORMAT' and 'PROBLEM' associated with the 'MULTIGRID'.

.vb
BOUNDARY_SEGMENT *MG_GEOM_SEGMENT (MULTIGRID *mg,INT i);
.ve

Returns a pointer to the 'i'th boundary segment of the domain.

.vb
BNDSEGDESC *MGBNDSEGDESC (MULTIGRID *mg,INT i);
.ve

Returns a pointer to the 'i'th 'BNDSEGDESC' structure of the 'segments' array.

.vb
INT MGNOOFSEG (MULTIGRID *mg);
.ve

Returns number of boundary segments of the domain associated with the 'MULTIGRID'.

.vb
VERTEX *MGVERTEX (MULTIGRID *mg,k);
.ve
Returns a pointer to the 'k'th corner 'VERTEX' of the domain.

.vb
INT MGNOOFCORNERS (MULTIGRID *mg);
.ve
Returns the number of corners of the domain associated with the 'MULTIGRID'.

.vb
HEAP *MGHEAP (MULTIGRID *mg);
.ve
Returns a pointer to the multigrids 'HEAP'.

.vb
GRID *GRID_ON_LEVEL (MULTIGRID *mg,INT i);
.ve
Returns a pointer to the 'i'th grid level of the 'MULTIGRID'.

.vb
INT SELECTIONSIZE (MULTIGRID *mg);
INT SELECTIONMODE (MULTIGRID *mg);
.ve
Returns number of objects in the selection buffer and type of these objects.

.vb
GEOM_OBJECT *SELECTIONOBJECT (MULTIGRID *mg,INT i);
.ve
Returns a pointer to the 'i'th object in the selection buffer.

.vb
char *MGNAME (MULTIGRID *mg);
.ve
Returns the name of the multigrid from the environment item.

.vb
HEAP *MG_USER_HEAP(MULTIGRID *mg);
.ve
Returns the multigrid user data heap pointer. The heapsize is determined by the
'FORMAT' definition.

.vb
void *GEN_MGUD(MULTIGRID *mg);
.ve
Returns the address of the general multigrid user data.

.vb
void *GEN_MGUD_ADR(MULTIGRID *mg, MEM offset);
.ve
Returns the address of a block with a certain offset (in bytes)
in the general multigrid user data. To be used in conjunction with

.vb
MEM OFFSET_IN_MGUD(INT BlockID);
.ve
Returns the offset of a previously allocated block in the general multigrid
user data.

Example':'
.n  'GEN_MGUD_ADR(myMG,OFFSET_IN_MGUD(myBlock))' will yield the desired memory address

SEE ALSO:

'DOMAIN', 'PROBLEM', 'FORMAT', 'GRID', 'HEAP', 'GEOM_OBJECT'.

D*/

/*D
GEOM_OBJECT - Union of all geometric objects

STRUCTURES:

.vb
union geom_object {    // objects that can hold a vector
    struct node nd;
    struct edge ed;
    union element el;
} ;

typedef union geom_object GEOM_OBJECT;
.ve

DESCRIPTION:

This data type unifies all data types that can have references to a 'VECTOR'
structure. This type is never used for allocation.

MACROS:

No macros are provided to for that data type.

D*/

/*D
LIMITS - Constants defining limitations of the data structure

DESCRIPTION:

There are some constants defining limitations of the data structure.
They are explained here. The actual value of the definition should
be extracted from the source code via the 'uggrep' shell script
provided with UG.

`In file 'gm.h'`

. MAXLEVEL - Maximum number of grid levels allowed in 'MULTIGRID'.

. MAXOBJECTS - Maximum number of different objects in free list.

. MAXSELECTION - Size of the selection buffer in 'MULTIGRID'.

. MAX_SIDES_OF_ELEM - Maximum number of sides of an element (of any type).

. MAX_EDGES_OF_ELEM - Maximum number of edges of an element (of any type).

. MAX_CORNERS_OF_ELEM - Maximum number of corners of an element (of any type).

. MAX_EDGES_OF_SIDE - Maximum number of edges per side.

. MAX_CORNERS_OF_SIDE - Maximum number of corners per side.

. MAX_CORNERS_OF_EDGE - Maximum number of corners per edge (is always 2).

. MAX_SIDES_OF_EDGE - In 3D two sides always have on edge in common.

. MAX_SONS - Maximum number of sons per element.

. MAX_SIDES_TOUCHING - Maximum number of sides on the next finer mesh that make up
a side on the coarser mesh.

. MAXMATRICES - Maximum number of 'MATRIX' types with different size.

. MAXCONNECTIONS - Maximum number of different 'CONNECTION' types.

. MSIZEMAX - Maximum size of a 'MATRIX' object in bytes.

. NO_OF_ELEM_MAX - Maximum number of elements touching the same edge.

`In file 'switch.h'`

. DIM_MAX - Maximum space dimension (is 3).

. DIM_OF_BND_MAX - Maximum dimension of boundary (is 'DIM_MAX-1').

. MAXVECTORS - Maximum number of different 'VECTOR' types.

D*/

/*D
REFINEMENT - Describes the interface to the grid refinement module

DESCRIPTION:

The interface to the grid refinement will change in the near future.
Therefore only a rudimentary documentation is provided.

UGs local refinement capability is element oriented, i.e. the
error estimator (part of the problem class) selects all or
part of the elements for refinement. To that end the error
estimator calls the function

.vb
INT MarkForRefinement (ELEMENT *theElement, INT rule, INT side);
.ve

where 'rule' is one of the following rules

.vb
NO_REFINEMENT
COPY     
RED    
BLUE  
BISECTION_1 
BISECTION_2_Q 
BISECTION_2_T1
BISECTION_2_T2
BISECTION_3 
UNREFINE 
.ve

and 'side' is some orientation necessary for those rules
that are not invariant under rotation (e.g. the edge to bisect).
The 'RED' rule selects standard isotropic refinement independent
of the element type. Triangles are subdivided in four triangles
by connecting the edge midpoints, quadrilaterals are subdivided
by connecting edge midpoints with the centroid and tetrahedral
elements are subdivided using the refinement strategy of J. Bey.
For 'RED' refinement the side information is arbitrary.

The 'MarkForRefinement' function may only be called for those elements
where 

.vb
INT EstimateHere (ELEMENT *theElement);
.ve

returns true. 'EstimateHere' is true for the leave elements of the element
hierarchy, i.e. those elements that are not further refined. Care
must be taken when the estimator for an element needs also information
on the solution in neighboring elements (see e.g. the implementation
of the error estimator in the 'diff2d' package). 

After the desired elements have been tagged for refinement the 'refine'
of the UG command language is used to actually refine the elements.

EXAMPLE:

The following function selects all (possible) elements in a 'MULTIGRID' for refinement and
returns the number of elements selected for refinement.

.vb
static INT MarkAll (MULTIGRID *theMG)
{
    GRID *theGrid;
    ELEMENT *theElement;
    int k,j;
    INT cnt;

    // get number of levels
    j = TOPLEVEL(theMG);

    // cnt will hold the number elements to be refined 
    cnt = 0;

    // mark elements
    for (k=0; k<=j; k++)
    {
        theGrid = GRID_ON_LEVEL(theMG,k);
        for (theElement=FIRSTELEMENT(theGrid); theElement!=NULL; theElement=SUCCE(theElement))
            if (EstimateHere(theElement))
            {
                cnt++;
                MarkForRefinement(theElement,RED,0);
            }
    }

    // return cnt
    return(cnt);
}
.ve

SEE ALSO:

'MarkForRefinement', 'EstimateHere', 'refine'.

REFERENCES:

[1] J. Bey: Tetrahedral Grid Refinement. To be published in Computing.

[2] J. Bey: AGM^3D Manual. Technical Report, Universitaet Tuebingen, 1994.

[3] R.E. Bank, A.H. Sherman, A. Weiser: Refinement Algorithms and Data
Structures for Regular Local Mesh Refinement. In: Scientific Computing,
IMACS, North-Holland, Amsterdam, 1983.

D*/

