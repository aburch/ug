-
*****************************************************************************************
*                                                                                       *
*                         ug.help: built-in commands                                    *
*                                                                                       *
*****************************************************************************************

-
############################## general commands #########################################

-quit > all end bye exit
quit            # end the application without saving open multigrids

-help > all ?
help            # get online help for commands etc.
help [[<helpitem>] $k]
    no option               # this is  equivalent to 'help help'
    <helpitem>              # print help for <helpitem> (string)
    $k                      # search for keyword <helpitem>

-checkhelp
checkhelp       # prints all commands and num proc types for which help does NOT exist

-resetclock > all time clock
resetclock      # reset the execution time clock to zero

-readclock > all time clock
readclock       # prints the execution time since the last 'resetclock' to
                # string variable ':CLOCK'

-mute > all output verbose
mute            # set a certain verbose level for the command interpreter (and for user commands)
mute <mutelevel>
    <mutelevel>             # <mutelevel> has to signed integer
                            # 0 means full (regular) output
                            # 1 or > mean supressing output more and more
                            # -1 or < mean verbosing more and more

-date > datum time year month
date            # print current date and time
date [$s] [$S]
    $s                      # print date to string variable :date rather than to shell
    $S                      # print short version of date (format: yy.mm.dd)

-
############################## list environment #########################################

-cd > all environment change directory
cd              # change environment directory to specified path
cd [<path>]
    <path>                  # <path> contains the relative or absolute path in UNIX-style
                            # if <path> is omitted: cd to root (cd /)

-ls > all environment list directory
ls              # list environment directory
ls [<path>]
    <path>                  # <path> contains the relative or absolute path in UNIX-style
                            # if <path> is omitted: ls <the current directory>

-pwd > all environment working directory
pwd             # print environment working directory
pwd

-structpath
<structdir> := [:]{<dirname>:}*
<struct>    := [<structdir>]<structname>

-ms > all environment struct string variable
ms              # create a new string variable struct
ms <structdir>
    <structdir>             # the <structdir> consists of a complete path related to the
                            # current struct dir or the string variable root in the environment
                            # (see also: help structpath)

-cs > all environment struct string variable
cs      # change to a struct
cs <structdir>
   <structdir>             # the <structdir> consists of a complete path related to the

-pws > all environment struct string variable
pws     # prints the path of a struct 

-ds > all environment struct string variable
ds              # delete an existing struct directory
ds <structdir>
    <structdir>             # the <structdir> consists of a complete path related to the
                            # current struct dir or the string variable root in the environment
                            # (see also: help structpath)

-set > all environment struct string variable
set             # set or print the contents of a struct or struct directory
set {<struct> <value>} | {[<structdir> | <struct>] [$r]}
    <struct> <value>        # assign <value> (just a string of arbitraray length) to <struct>
    [<structdir> | <struct>] [$r]
                            # display contents of <struct> or <structdir> (default: current struct dir
                            # if $r is specified the directory contents is listed recursively
                            # (see also: help structpath)

-
################################ protocol and log #######################################

-protoon > all file output format open
protoOn         # open a protocol file for specially formatted output to file
protoOn <filename> [$r[!] | $a]
    $r!                     # if a file named <filename> exist already, rename it to <filename>.saved
                            # break if the renaming fails
    $r                      # like above but proceed even if renaming fails
    $a                      # append to existing file named <filename>

-protooff > all file output format close
protoOff        # close the protocol file (see the 'protoOn' command)

-protocol > file output format write
protocol        # write formatted ouput to the open protocol file
protocol {{$\i[ ]<verbatim text> | $\n[ ]<verbatim text> | $\t[ ]<verbatim text> | $\f} {[$ text]}*}*
    $\i                    # append <verbatim text> to protocol file
    $\n                    # write a line feed and append <verbatim text> to protocol file
    $\t                    # write a tab and append <verbatim text> to protocol file
                           # NOTE: the first space (if there) following the option character is skipped
    $\f                    # flush the file buffer
    [$ text]               # this means an option char followed by any text where the first char is NOT \
                           # those texts are appended in the order they are given including the $s
                           # options where the $ is not followed by a \ are appended to the
                           # example: 'protocol $\i using: $\t mark $a' --> 'using:\tmark $a' will be appended

-logon > all file output write
logon           # direct total shell output also to a logfile
logon <logfilename> [$p]
    $p                     # append to already open protocol file (write 'beginlog' mark)

-logoff > file output write
logoff          # switch off the logging mechanism
    $p                     # quit appending to already open protocol file (write 'endlog' mark)

-
################################ grid management ########################################

-new > grid multigrid
new              # allocate heap and new multigrid structure
new [<mgname>] $d <domain> $p <problem> $f <format> $h <heapsize>
    <mgname>               # the name of the multigrid (default is 'untitled-<nb>')
    $b <BVP name>          # one of the enroled boundary value problems
    $f <format>            # one of the enroled formats matching with <problem>
    $h <heapsize>          # the heapsize to be allocated in byte or use suffix
                           # "K" or "k" for kilobyte
                           # "M" or "m" for megabyte
                           # "G" or "g" for gigabyte

-open > grid multigrid
open             # allocate heap and new multigrid structure
open <mgname> [$d <domain> [$p <problem>]] [$f <format>] $h <heapsize>
    <mgname>               # the name of the multigrid
    $b <BVP name>          # one of the enroled boundary value problems
    $f <format>            # one of the enroled formats matching with <problem>
    $h <heapsize>          # the heapsize to be allocated

-envinfo > all environment struct string variable
envinfo # prints the used and size of the environment heap on the shell.

-close > grid multigrid
close            # close the current (or all) open multigrid(s) and free their heaps
close [$a]
    $a                     # close all multigrids

-save > grid multigrid saveas
save             # save the current multigrid
save [<name>] [$c <comment>]
   <name>                  # name to save with (default is the mgname)
   $c <comment>            # optionally specify a comment string

-refine > grid multigrid mark
refine           # refine the multigrid according to the refinement marks set in the elements
refine [$g]                # copy non refined regions to new level

-mark > grid multigrid refine
mark             # mark one (or several) elements for refinement
mark [$h | {[<rule> [<side>]] [$a | $i <Id> | $s]} | $c]
    <rule>                 # specify a refinement rule ("red" is default)
    <side>                 # has to be specified if the corresponding rule can be
                           # applied in several orientations
    $a                     # refine all (leave) elements
    $i <Id>                # refine the element with <Id>
    $s                     # refine all elements from the current selection
    $h                     # show available rules

-extracon > connections extra grid delete
extracon         # display number of extra connections (and delete them)
                 # stringvar :extraconratio is set to (# extra/# connections)
extracon [$d]
    $d                     # delete extra connections on the current level

-check > grid multigrid algebra vector matrix
check            # check consistency of grid (and algebraic) datastrcuture
check [$c]
   $c                      # additionally to grid check algebra

-quality > grid multigrid element angle
quality          # check the min and max angles of the elements in the grid
quality $a | $s | {$i <fromID> [<toID>]} [$< <angle>] [$> <angle>]
    $a                     # check angles of all elements in the multigrid
    $s                     # check angles of the selected elements
    $i                     # check angles of elements with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the element with <fromID> is listed
    $< <angle>             # print info for all elements the minangle of which is < <angle>
    $> <angle>             # print info for all elements the maxangle of which is > <angle>

-smooth > node grid multigrid shift vertex
smooth           # hierarchical grid smoothing
smooth <nIt> [$b]
    <nIt>                  # number of iterations
    $b                     # also smooth boundary nodes

-lexorderv > vectors grid order sort
lexorderv         # reorder the vectors on each mg-level lexicographically
lexorderv <directions> [$l <level>] [$m] [$s <|>|0]
2D: <directions>           # 2 letters, one for each coordinate direction; the 
                           # order of the letters determine the order of the
                           # lexicographical ordering. The letters out of [rlud]:
                           # x-axis: r=right (ascending), l=left  (descending)
                           # y-axis: u=up    (ascending), d=down  (descending)
3D: <directions>           # 3 letters, one for each coordinate direction; the 
                           # order of the letters determine the order of the
                           # lexicographical ordering. The letters out of [rlbfud]:
                           # x-axis: r=right (ascending), l=left  (descending)
                           # y-axis: b=back  (ascending), f=front (descending)
                           # z-axis: u=up    (ascending), d=down  (descending)
    $l <level>             # order only level
    $m                     # also order the MATRIXs of each node in the same way
    $s <|>|0               # treatment of vectors with skip>0: put at begin, put at end
                           # or treat them like others (default)
    $w [s][n]              # consider vectors with skipflag set (s) or not set (n) and append
                           # the remaining ones to the lexicographically ordered list

-orderv > vector matrix order sort
orderv           # algebraically order the vectors of the current multigrid
orderv $m FFCCLL | FCFCLL [$s <skip pattern>] $d <dep-proc> $o dep-proc options> [$c <cut proc>] [$a]
    $m FFCCLL | FCFCLL     # possible modes are FFCCLL or FCFCLL
    $s <skip pattern>      # if specified put vectors with skip pattern containing
                           # <skip pattern> to the begin of the list
    $d <dep-proc>          # the ordering algorithm uses this dependency procedure...
    $o <dep-proc options>  # ...and passes these options to it
    $c <cut proc>          # user specified proc for cuts
    $a                     # order all levels of the current multigrid

-lineorderv > vector matrix order sort
lineorderv       # algebraically order the vectors of the current multigrid
lineorderv $d <dep-proc> $o dep-proc options> [$c <cut proc>] [$a] [$v 0|1|2]
    $d <dep-proc>          # the ordering algorithm uses this dependency procedure...
    $o <dep-proc options>  # ...and passes these options to it
    $c <cut proc>          # user specified proc for cuts
    $a                     # order all levels of the current multigrid
	$v 0|1|2               # verbose level (default 0, quiet mode)

-shellorderv > vector matrix order sort
shellorderv      # order vectors of the current level starting from a seed shell by shell
shellorderv f | l | s
    f                      # seed = FIRSTVECTOR
    l                      # seed = LASTVECTOR
    s                      # seed = selection

-setindex > vector index
setindex         # set vector indices of the current level in ascending order beginning with 1

-ordernodes > nodes grid order sort
ordernodes       # reorder nodes lexicographically
ordernodes ur|ul|dr|dl|ru|rd|lu|ld [$l <level>] [$L]
                          # where u=up, d=down, r=right, l=left
    $l <level>            # only order the specified level
    $L                    # also order links

                          # CAUTION: node-ids of the whole mg will change in any case

-setcurrmg > grid multigrid current
setcurrmg        # change the current multigrid
setcurrmg <mgname>
    <mgname>               # mgname of the open multigrid which will be the current one

-level > grid multigrid level
level           # change the working (current) level of the current multigrid
level <level> | + | -

-renumber > grid multigrid level
renumber        # assign consecutive id's to all objects

-mglist > grid multigrid info list
mglist          # list all open multigrids
mglist [$l]
    $l                     # list long format

-glist
glist           # print grid statistics for the current multigrid
glist 

-nlist > node grid multigrid info list
nlist           # print info for the specified nodes
nlist $s | {$i <fromID> [<toID>]} [$d] [$b] [$n] [$v] [$a]
    $s                     # list info for the selected nodes
    $i                     # list info for nodes with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the node with <fromID> is listed
    $d                     # up to version 2.3 ONLY: list also user data space
    $b                     # print additional info for boundary nodes
    $n                     # list also neighbours of each node
    $v                     # print extended info (verbose mode)
    $a                     # list all nodes

-elist > element grid multigrid info list
elist           # print info for the specified elements
elist $s | {$i <fromID> [<toID>]} [$d] [$b] [$n] [$v] [$a]
    $s                     # list info for the selected elements
    $i                     # list info for elements with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the element with <fromID> is listed
    $d                     # up to version 2.3 ONLY: list also user data space
    $b                     # print additional info for boundary elements
    $n                     # list also neighbours of each element
    $v                     # print extended info (verbose mode)
    $l                     # list only elements of current level
    $a                     # list all elements

-slist > element grid multigrid info list
slist          # list the contents of the selction buffer (elist/nlist format resp.)
slist [$d] [$b] [$n] [$v]
    $d                     # up to version 2.3 ONLY: list also user data space
    $b                     # print additional info for boundary nodes/elements
    $n                     # list also neighbours of each node/element
    $v                     # print extended info (verbose mode)

-symlist > symbol user data vector matrix
symlist        # list SYMBOL-contents
symlist $s <sym-name> [<fmt>|*] $V [<fmt>|*] $M [<fmt>|*]
    $s <sym-name> ...      # list SYMBOL with name ...
    $V ...                 # list all VECTOR-SYMBOLs ...
    $M ...                 # list all MATRIX-SYMBOLs ...
    [<fmt>|*]              # ... of format <fmt>
                           #     or of current multigrid (*)
                           #     or of all formats (default)
-vmlist > vector matrix grid multigrid info list
vmlist           # print info for the specified vectors (possibly including associated matrix entries)
vmlist $s | {$i <fromID> [<toID>]} [$m] [$d] [$a] [$l <f> <t>]
    $s                     # list info for the selected vectors
    $i                     # list info for vectors with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the vector with <fromID> is listed
    $m                     # list also the associated matrix entries
    $d                     # list also the user data
    $a                     # list all vectors
    $l <f> <t>             # process levels f <= l <= t

-in > node insert grid multigrid
in               # insert an inner node into a multigrid with only level 0
in <x> <y> <z>
     <x> <y> <z>            # specify as much coordinates as the space has dimensions

-bn > node insert grid multigrid
bn               # insert a boundary node into a multigrid with only level 0
bn <Id> <s> <t>
    <Id>                   # insert a boundary node on the boundary segment with <Id>
    <s> <t>                # specify as much boundary segment coordinates as the boundary has dimensions

-deln > node delete grid multigrid
deln             # delete a node from the multigrid
deln <Id> | $s
    <Id>                   # ID of the node to be deleted
    $s                     # delete ALL nodes from the selection

-move > node grid multigrid shift
move             # move a node of the multigrid to a new postion
move {<Id> | $s} {$i <x> <y> <z> | $b <SegId> <s> <t>} [$r]
    <Id>                   # Id of the node to be moved
    $i <x> <y> <z>         # specify as much coordinates as the space has dimensions
    $b <Id> <s> <t>        # specify as much boundary segment coordinates as the boundary has dimensions
    $r                     # move relative to old position (inner nodes only)


-ie > element insert grid multigrid
ie               # insert an element for specified corner nodes
ie {<Id>}+ | $s
    {<Id>}+                # specify at least three corner nodes, the coresponding (unique) element will
                           # be created

-dele > element delete grid multigrid
dele             # delete an element from the multigrid including edges not deeded anymore
dele <Id> | $s
    <Id>                   # ID of the element to be deleted
    $s                     # delete ALL elements from the selection

-find > node element grid multigrid selection
find             # find a node (element) on the current level of the current multigrid
find <x> <y> <z> {$n <tol> | $v <tol> | $e} [$s]
    <x> <y> <z>            # specify as much coordinates as the space has dimensions
    $n <tol>               # find a node maching the position with tolerance <tol>
    $v <tol>               # find a vector maching the position with tolerance <tol>
    $e                     # find an element maching the position
    $s                     # add the selected node (element) to the selection buffer
                           # (if not specified the node is just listed)

-select > node element grid multigrid selection
select           # add/remove nodes/elements from the selction buffer of the current multigrid
select $c | $n {+|-} <Id> | $e {+|-} <Id>
    $c                     # clear the selection buffer
    $n {+|-} <Id>          # add (+) or remove (-) the node with <Id> to (from) the selection buffer
    $e {+|-} <Id>          # add (+) or remove (-) the element with <Id> to (from) the selection buffer

-
################################ view management ########################################

-standardrefsys
The standardRefSys has pos x-axis extending rightward and pos y-axis extending upward.
For the monitor screen the origin is located in the lower left corner and the maximum
size you will be told by the --> screensize command

-viewrefsys
The viewRefSys in 3D is defined by the x-axis in the viewplane and the z-axis in the
direction target-observer.
The viewRefSys in 2D is defined by the x-axis.

-screensize > screen monitor window
screensize       # print the size in pixels of the screen (if there) ==> max window size

-openwindow > window picture plot graphics
openwindow       # open an ug-window on an outputdevice (this will be the current window then)
openwindow <h> <v> <dh> <dv> [$d <output device>] [$n <window name>]
    <h> <v>                # the lower left corner of the plotting region in the --> standardRefSys
    <dh> <dv>              # the width and height resp. of the plotting region of the window
    $d <output device>     # specify the name of an output device (default: screen)
    $n <window name>       # optionally you can specify the window's name

-closewindow > window picture plot graphics
closewindow      # close one (or all) ug-window(s) (including the pictures residing there, of course)
closewindow [$n <window name> | $a]
    $n <window name>       # close the window with the specified name
                           # (default: the current window)
    $a                     # close all open windows

-setcurrwindow > window picture plot graphics
setcurrwindow    # make a window the current window
setcurrwindow <window name>

-drawtext > text plot window
drawtext         # draw text into a ug window
drawtext <xpos> <ypos> <text> [$w <window name>] [$c] [$m reg[ular]|inv[erse]|ind[exed]] [$s <size>]
   <xpos>                  # x-coordinate in pixels (origin is the lower left corner)
   <ypos>                  # y-coordinate in pixels (origin is the lower left corner)
   <text>                  # text to draw
   $w <window name>        # draw text into this window (default: current window)
   $c                      # center text at <xpos> <ypos>
   $s <size>               # text size
   $m ...                  # draw text
                           #   reg: regular (default)
						   #   inv: inverse
						   #   ind: allow for indexing (sub- and superscripts)
						   #        formatting by
						   #          /N: regular
						   #          /T: subscript
						   #          /H: superscript
						   #   example: 'ex/Tsub/Hsuper/Nnormal' will result in something like
						   #                  super
						   #            'ex        normal
						   #               sub

-openpicture > window picture plot graphics
openpicture      # open a picture on a window (these will be the current window and picture then)
openpicture [$w <window name>] [$s <h> <v> <dh> <dv>] [$n <picture name>]
    $w <window name>       # open a picture on this window (default: current window)
    $s <h> <v> <dh> <dv>   # specify the location and size in the --> standardRefSys with the
                           # origin located in the lower left corner of the parent window
                           # (default: picture size = parent window size)
    $n <picture name>      # optionally you can specify the picture's name

-closepicture > window picture plot graphics
closepicture     # close one (or all) picture(s) on a window
closepicture [$a | {$w <window name> {<picture name> | $a}}]
                           # default: the current picture
    $a                     # close all pictures of the current window
    $w <window name>       # close a picture of this window
    {<picture name> | $a}  # close the picture with the specified name or all pictures of that window

-setcurrpicture > window picture plot graphics
setcurrpicture   # make a picture the current picture
setcurrpicture <picture name> [$w <window name>]
    $w <window name>       # picture resides in this window (default: current window)

-picwin > window picture plot graphics
picwin           # create a new window for the current picture
                 # (to seperate multiple pictures of one window)

-wplist > window picture plot graphics
wplist           # list all windows with their pictures

-clearpicture > window picture plot graphics
clearpicture     # clear current picture

-picframe > window picture plot graphics
picframe         # toggle framing od pictures
picframe 0|1
    0                      # frame pictures
    1                      # don't frame pictures

-setview > window picture plot graphics
setview          # specify or change the observer's view of the object of the current picture
    2D: setview [$i] [$t <x> <y>] [$x  <x> <y>]
    3D: setview [$i] [$o <x> <y> <z> $t <x> <y> <z>] [$x <x> <y> [<z>]] [$p < | =]
                           # all coordinates have to be given in physical coordinates

    $i                     # first initialize view with default settings
    $o <x> <y> <z>         # 3D objects ONLY: specify the observer's stand
    $p < | =               # 3D objects ONLY: choose central (<) or parallel (=) perspective
    $t <x> <y> [<z>]       # specify the target point in the viewplane
                           # (NB: the viewplane is then defined to be normal to the line observer-target)

    $x <x> <y> [<z>]       # define an x-axis in the viewplane (which will be to the right in the picture)

-walk > window picture plot graphics
walk             # let the observer walk relative to the --> viewRefSys in the current picture
walk <x> <y> [<z>]

-walkaround > window picture plot graphics
walkaround       # 3D ONLY: let the observer walk on a sphere around the target point in the current picture
walkaround <viewplane angle> <rotation angle>    # angles in degree
    <viewplane angle>      # this angle runs in the view plane math pos from the x-axis and defines
                           # together with the target-observer direction a plane
    <rotation angle>       # the observer will be rotated around the target point in the above plane

-zoom > window picture plot graphics
zoom             # zoom the current picture
zoom <factor>              # values < 1 magnify picture !

-drag > window picture plot graphics
drag             # drag the projection plane of the current picture relative to its x-axis
drag <dx> <dy>

-rotate > window picture plot graphics
rotate           # rotate the projection plane of the current picture around the target point
rotate <angle>
    <angle>                # <angle> runs in the view plane math pos from the x-axis

-textfac > text size window graphics
textfac          # set a zoom factor for textsizes in graphical windows
textfac <factor>

-setplotobject > window picture plot graphics
setplotobject    # specify the object which will be plotted in the current picture and associate
                 # the current multigrid with it (if not done yet)
setplotobject [<object type name>] ...
    <object type name>     # possible are: Grid, EScalar, EVector
                           # see seperate help for these.
    ...                    # the remaining options depend on which object you specified

-polist > window picture plot graphics
polist           # print the specifications of the object defined in the current picture

-plot > window picture plot graphics
plot             # plot the object of the current picture according to its specifications

-vdisplay >
vdisplay # display view of current picture

-cmfn > meta plot
cmfn     #  creates a string containing the name of a metafile name for animation by xugv.
cmfn <name> <var>
  <name> # first part of the metafile names
  <var>  # the contents of var will be appended to the name

-findrange > window picture plot graphics
findrange        # find the range of values to be plotted for the object in the current picture
                 # the result will be printed and stored into :findrange:min and :findrange:max
findrange [$z <zoom factor>] [$s] [$p]
    $z <zoom factor>       # zoom the range by this factor
    $s                     # symmetrize the range (min=max)
    $p                     # store range in plot object

-updatedoc > window picture plot graphics
updateDoc        # redraw all pictures of the current multigrid

-
################################# miscellaneous #########################################

-defaults
in the file 'defaults' in the application directory the user can specify the following
values (format: the name at the beginning of the line in arbitrary order, then following the value string;
the example values are taken from the nsa defaults file, omit the comments of course):

envmemory 		128000                                               # environment memory in bytes

helpfiles 		../../ug/doc/ug.help ../../ug/doc/ug2d.help ../pclib/ns.help  # help files to search for help

guimemory 		32000                                                # MAC only: for window management
scrollback 		500                                                  # MAC only: line buffer for shell
charsperline 	256                                                  # MAC only: max number of chars per line
font 			Monaco                                               # MAC only: font name
size 			9                                                    # MAC only: font size
TermWinH 		400                                                  # MAC only: horizontal position of shell window
TermWinV 		0                                                    # MAC only: vertical position of shell window
TermWinDH 		1000                                                 # MAC only: width of shell window
TermWinDV 		1000                                                 # MAC only: height of shell window

scriptpathes	./paramruns/ ./ ./plotscripts/                       # search scripts in these pathes
gridpathes		./grids/                                             # search grids in these pathes
protocoldir		../../../ug31results/ns/paramruns/results/           # write protocols into this dir
logfilesdir		../../../ug31results/ns/paramruns/results/           # write logfiles into this dir
metafilesdir	../../../ug31results/ns/paramruns/results/           # write metafiles into this dir
arraypaths      ./paramruns

-clear > vector matrix userdata
clear            # clear or assign a constant value to a user defined symbol
clear <symbol name> [$a] [$s] [$v <value>]
    $a                     # from level 0 through current level (default: current level only)
    $s                     # consider the skip fields
    $v <value>             # assign this value (instead of 0.0)

-copy > solution symbol
copy            # copy symbol to symbol on current level
copy $f <from-symbol> $t <to-symbol>

-interpolate > solution symbol
interpolate     # interpolate to current level from level below
interpolate <symbol>

-reinit > problem multigrid
reinit           # reinitialize a problem
reinit [$d <domain> $p <problem>]
    $d <domain>            # domain to initialize (default is the domain of the current mg)
    $p <problem>           # problem to initialize (default is the problem of the current mg)

-setkey > command delkey
setkey           # create a command key and assign executable statements to it
setkey $<command char> $" <command sequence>"
    $k <command char>      # specifiy a single character which will be the command key
    $" <command sequence>" # give an arbitrary sequence of statements which is to be
                           # executed when the command key is pressed
                           # NOTICE: when executed string varibales preceeded by a ?
                           # will be expanded with the CURRENT contents of this variable
                           # If they are preceeded by a @ as usual, the string vars will be
                           # evaluated instantaneously when the cmd key is created

-delkey > command setkey
delkey           # remove a command key allocated before
delkey $all | $<command char>
    $all                   # delete all command keys allocated before
    $<command char>        # delete only the command key associated with <command char>

-keylist > command setkey list
keylist          # list all command keys defined together with their contents

-refreshon > view multigrid refreshoff
refreshon        # pictures on the screen device will be updated instantaneously

-refreshoff > view multigrid refreshon
refreshoff       # pictures on the screen device will be updated ONLY explicitely

-newformat > format multigrid user data symbols
newformat        # create a user data format
newformat <format_name> [$V <vec_size>: {<vec_sym_name>}+ [$comp <comp_names> {$sub <sub_sym_name> <comps>}*]]
                        [$M <mat_size>: {<mat_sym_name>}+ [$comp <comp_names> {$sub <sub_sym_name> <matsizes+comps>}*]
                        [$d <mtype> <depth>]
  
  $V            # enrol storage for vector data: the specified size per type is multiplied
                # by the number of <vec_sym_name> specified. SYMBOLs are allocated with the
                # specified names, also scalar SYMBOLs are allocated
                
     <vec_size> := {<tp><size> }+, where <tp> is a char of
                                           n for NODE
                                           k for EDGE
                                           e for ELEM
                                           s for SIDE (3D only)
                   and <size> is a integer
 
 
  $comp         # optionally specify names for the components
     <comp_names> := one char per component of the symbol (without spaces)
  
  
  $sub          # if comp names have been specified optionally specify sub symbols for
                # each of the previously allocated symbols by sppecifying their comps
  
     <comps> := list of comps as specified in <comp_names>
  
  
  $M            # enrol storage for matrix data: the specified size per type is multiplied
                # by the number of <mat_sym_name> specified. SYMBOLs are allocated with the
                # specified names, also scalar SYMBOLs are allocated
                
     <mat_size> := {<rtp><rsize>x<ctp><csize> }+, where r and c refer to rows and columns of the matrix
 
 
  $comp         # optionally specify names for the components
     <comp_names> := TWO chars per component of the symbol (without spaces)
     
     
     <matsizes+comps> := {<rsize>x<csize> <comp_names>}+
  
  
  $d <mtype> <depth>  # set connection depth (default 0)
     
     <mtype> := <rtp>x<ctp>

-setpf > symbols format vmlist
setpf            # set printing format in context with vmlist command
setpf <format_name> [$V{0 | {+|-} {<vecsym_name>}+}]+ [$M{0 | {+|-} {<matsym_name>}+}]+

-showpf > symbols format vmlist
showpf           # show current printing format settings

-
##############################  PlotObjectTypes  #########################################

-matrix > setplotobject setview plot matrix blockmatrix blockvector block
Matrix         # name of PlotObjType for plot Matrix where entries are indicated by colors
Matrix [$e <matrix eval proc> | $M <scalar matrix symbol>] [$f <fromValue>] [$t <toValue>] [$l 0|1]
    $f <fromValue> $t <toValue>     # range [fromValue,toValue]
    $e <matrix eval proc>           # plot entries of a symbol
    $M <scalar matrix symbol>       # plot entries of a evalproc
    $C 0|1                          # plot regular connections
    $E 0|1                          # plot extra connections
    $l 0|1                          # choose logarithmic coloring (ln |A_ij|)
    $T <threshold>                  # supress entries with |A_ij| < threshold
    $BV 0|1 [<dash> <space>]        # disabel|enabel plotting of blockmatrixstructure
                                    # optional you can enabel dotted lines up to
                                    #     the border of the matrix
                                    #     <dash> gives the length of one small linesegment,
                                    #     <space> the space between such segments
-
############################### numerical procedures #####################################

-npcreate > numproc
npcreate         # create a num proc from a num proc type
npcreate <num proc name> $t <num proc type> $f <format>

-npinit > numproc
npinit           # initialise current numproc
npinit <argument list to be passed>

-npexecute > numproc
npexecute        # execute a num proc
npexecute [<num proc name>] <argument list to be passed>

-npdisplay > numproc
npdisplay        # display current num proc

-scnp > numproc
scnp             # set current num proc
scnp <num proc name>

-nplist > numproc
nplist   # list numprocs

-pbjac > smoother numproc jacobi
for initialisation of the damped point-block Jacobi use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $damp <sc double list>

-pbgs > smoother numproc gauss-seidel
for initialisation of the damped point-block Gauss-Seidel use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $damp <sc double list>

-sympbgs > smoother numproc gauss-seidel
for initialisation of the symmertic damped point-block Gauss-Seidel use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $damp <sc double list>

-pbsor > smoother numproc sor
for initialisation of the damped point-block sor (successive overrelaxation) use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $damp <sc double list>

-pbilu > smoother numproc ilu-beta
for initialisation of the damped point-block ilu with beta modification use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $damp <sc double list> $L <lu mat sym> $beta <sc double list>
       [$rest <rest vector symbol> [$ort <sc double list>]]

-pbilubt > smoother numproc ilu-beta threshold
for initialisation of the damped point-block ilu with beta modification and threshold use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $damp <sc double list> $thresh <sc double list> $L <lu mat sym> $beta <sc double list>
       $rest <rest vector symbol>

-pbilusp > smoother numproc ilu-beta spectrally shifted
for initialisation of the damped point-block spectrally shifted ilu use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $damp <sc double list> $L <lu mat sym> $beta <sc double list> $mode local|global
       [$rest <rest vector symbol> [$ort <sc double list>]]

-pblu > smoother numproc lu lr
for initialisation of the point-block lu (with threshold and damping) use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $L <lu mat sym>

-ebgs > smoother numproc gauss-seidel
for initialisation of the equation-block Gauss-Seidel use:
npinit $n <n-iter> $A <mat sym> $r <rhs sym> $x <sol sym> $t <temp sym> $D {no|red|full}
       $Blocking <sc int list> $BlockOrder <ord list> $BlockIter <sc numproc list> $n 1 $D full;

-sc > typevecdesc scalar tvd numproc
<sc double list>  := [nd <double  list>] | [ed <double  list>] | [el <double  list>] | [si <double  list>]
<sc int list>     := [nd <int     list>] | [ed <int     list>] | [el <int     list>] | [si <int     list>]
<sc numproc list> := [nd <numproc list>] | [ed <numproc list>] | [el <numproc list>] | [si <numproc list>]
<ord list>        := nd|ed|el|sd<number>{ nd|ed|el|sd<number>}+

<<item> list>     := <item>{:<item>}*
<item>            := <double>|<int>|<numproc>

-cv > numproc tvd
cv  # clear vector
cv <vec sym>

-cm > numproc 
cm  # clear matrix
cm <Mat sym>

-eu > numproc 
eu  # compute Eucilian norm
eu <vec sym>

-lmgc > numproc 
lmgc # linear multigrid cycle
for initialisation use:
npinit $x <sol sym> $b <rhs sym> $c <cor sym> $t <temp sym> $A <mat sym> 
       $m <maxit> $l <baselevel> $g <gamma> $s <sm1 sm2 basesm> $D{no|red|full}
       $red <sc double list> [$p <cg sym>] [$abslimit <sc double list>]

-nl > numproc 
nl # nonlinear solver
for initialisation use:
npinit $n <new sym> $o <old sym> $t <temp sym> $d {NO|RED|FULL} $m <maxit> 
       $l <linear solver> $r <assemble> $Rel_Limit <sc double list> $Damp <sc double list>

-tnl > numproc
tnl                  # time solver
npinit $n <new sym> $o <old sym> $t <temp sym> $d {NO|RED|FULL} $m <maxit> 
       $l <linear solver> $r <assemble> $Rel_Limit <sc double list> $Damp <sc double list> ??????

-array > crar wrar rear saar loar clar
array: family of commands to handle arrays of double. The commands are:
  crar $n <name> {$n_i}+ # create array of specified size
  dear $n <name>         # delete array
  wrar $n <name> {$n_i}+ $v <value> # write array[n_1][n_2]...[n_k] := <value>
  rear $n <name> {$n_i}+ # read array[n_1][n_2]...[n_k] to ':ARRAY_VALUE'
  clar $n <name>         # clear array, all entries := 0.0
  saar $n <name>         # save array to file '<name>.array'
  loar $n <name>         # load array from file '<name>.array'

-crar > array create dear saar loar wrar rear clar
crar             # create a new array structure
crar $n <name> {$<n_i>}+

  $n <name> # name of the array structure
  {$<n_i>}+ # list of extension in the i.th dimension
            # 1 <= i <= 'AR_NVAR_MAX'

-dear > array delete free dispose crar saar loar wrar rear clar
dear             # delete an array structure
dear $n <name>
  $n <name> # name of the array structure

-saar > array save store file defaults crar dear loar wrar rear clar
saar             # save array to file <name>.array
                 # path in the defaults file under 'arraypaths'
saar $n <name>
  $n <name> # name of the array structure

-loar > array load restore file defaults crar dear saar wrar rear clar
loar             # load array from file <name>.array
                 # path in the defaults file under 'arraypaths'
loar $n <name>
  $n <name> # name of the array structure

-wrar > array write store crar dear saar loar rear clar
wrar             # write value to a single array entry
wrar $n <name> {$<n_i>}+ $v <value>

  $n <name> # name of the array structure
  {$<n_i>}+ # list of the coordinates of the array entry;
            # dimension of the array as created;
            # index 0 <= n_i < allocated extension
  <value>   # double value to be stored

-rear > array read restore crar dear saar loar wrar clar
rear             # read value of a single array entry and
                 # store it in the environment variable :ARRAY_VALUE
rear $n <name> {$<n_i>}+

  $n <name> # name of the array structure
  {$<n_i>}+ # list of the coordinates of the array entry;
            # dimension of the array as created;
            # index 0 <= n_i < allocated extension

-clar > array clear reset init crar dear saar loar wrar rear
clar             # clear array; set all entries to 0.0
clar $n <name>
  $n <name> # name of the array structure

-ptest > parallel
ptest {$0|$1} # grid distribution (will replace later)
$0            # transfer complete grid
$1            # do load balancing

-pstat > parallel
pstat {$c|$i|$l|$s|$b}  # parallel status information
$c                      # call ddd consistency check  
$i                      # display ddd interfaces
$s                      # show ddd status
$l                      # show list of local objects
$b                      # enter interactive debugger

-context > parallel
context {$a|$e|<n>}  # set context for plotting and printing
$a                   # all processors
$e                   # empty
<n>                  # toggle processor n
  
