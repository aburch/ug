-
****************************************************************************  
*                                                                          *
*                         ug.help: built-in commands                       *
*                                                                          *
****************************************************************************

-
################# general commands #########################################

-quit > all end bye exit
quit            # end the application without saving open multigrids

-help > all ?
help            # get online help for commands etc.
help [[<helpitem>] $k]
    no option               # this is  equivalent to 'help help'
    <helpitem>              # print help for <helpitem> (string)
    $k                      # search for keyword <helpitem>

-checkhelp
checkhelp       # prints all commands and num proc types for which help does NOT exist

-resetclock > all time clock
resetclock      # reset the execution time clock to zero

-readclock > all time clock
readclock       # prints the execution time since the last 'resetclock' to
                # string variable ':CLOCK'

-mute > all output verbose
mute            # set a certain verbose level for the command interpreter (and for user commands)
mute <mutelevel>
    <mutelevel>             # <mutelevel> has to signed integer
                            # 0 means full (regular) output
                            # 1 or > mean supressing output more and more
                            # -1 or < mean verbosing more and more

-date > datum time year month
date            # print current date and time
date [$s] [$S]
    $s                      # print date to string variable :date rather than to shell
    $S                      # print short version of date (format: yy.mm.dd)

-
#################### list environment #########################################

-cd > all environment change directory
cd              # change environment directory to specified path
cd [<path>]
    <path>                  # <path> contains the relative or absolute path in UNIX-style
                            # if <path> is omitted: cd to root (cd /)

-ls > all environment list directory
ls              # list environment directory
ls [<path>]
    <path>                  # <path> contains the relative or absolute path in UNIX-style
                            # if <path> is omitted: ls <the current directory>

-pwd > all environment working directory
pwd             # print environment working directory
pwd

-structpath
<structdir> := [:]{<dirname>:}*
<struct>    := [<structdir>]<structname>

-ms > all environment struct string variable
ms              # create a new string variable struct
ms <structdir>
    <structdir>             # the <structdir> consists of a complete path related to the
                            # current struct dir or the string variable root in the environment
                            # (see also: help structpath)

-cs > all environment struct string variable
cs      # change to a struct
cs <structdir>
   <structdir>             # the <structdir> consists of a complete path related to the

-pws > all environment struct string variable
pws     # prints the path of a struct 

-ds > all environment struct string variable
ds              # delete an existing struct directory
ds <structdir>
    <structdir>             # the <structdir> consists of a complete path related to the
                            # current struct dir or the string variable root in the environment
                            # (see also: help structpath)

-set > all environment struct string variable
set             # set or print the contents of a struct or struct directory
set {<struct> <value>} | {[<structdir> | <struct>] [$r]}
    <struct> <value>        # assign <value> (just a string of arbitraray length) to <struct>
    [<structdir> | <struct>] [$r]
                            # display contents of <struct> or <structdir> (default: current struct dir
                            # if $r is specified the directory contents is listed recursively
                            # (see also: help structpath)

-
##################### protocol and log #######################################

-protoon > all file output format open
protoOn         # open a protocol file for specially formatted output to file
protoOn <filename> [$r[!] | $a]
    $r!                     # if a file named <filename> exist already, rename it to <filename>.saved
                            # break if the renaming fails
    $r                      # like above but proceed even if renaming fails
    $a                      # append to existing file named <filename>

-protooff > all file output format close
protoOff        # close the protocol file (see the 'protoOn' command)

-protocol > file output format write
protocol        # write formatted ouput to the open protocol file
protocol {{$\i[ ]<verbatim text> | $\n[ ]<verbatim text> | $\t[ ]<verbatim text> | $\f} {[$ text]}*}*
    $\i                    # append <verbatim text> to protocol file
    $\n                    # write a line feed and append <verbatim text> to protocol file
    $\t                    # write a tab and append <verbatim text> to protocol file
                           # NOTE: the first space (if there) following the option character is skipped
    $\f                    # flush the file buffer
    [$ text]               # this means an option char followed by any text where the first char is NOT \
                           # those texts are appended in the order they are given including the $s
                           # options where the $ is not followed by a \ are appended to the
                           # example: 'protocol $\i using: $\t mark $a' --> 'using:\tmark $a' will be appended

-logon > all file output write
logon           # direct total shell output also to a logfile
logon <logfilename> [$p]
    $p                     # append to already open protocol file (write 'beginlog' mark)

-logoff > file output write
logoff          # switch off the logging mechanism
    $p                     # quit appending to already open protocol file (write 'endlog' mark)

-
###################### grid management ########################################

-new > grid multigrid
new              # allocate heap and new multigrid structure
new [<mgname>] $d <domain> $p <problem> $f <format> $h <heapsize>
    <mgname>               # the name of the multigrid (default is 'untitled-<nb>')
    $b <BVP name>          # one of the enroled boundary value problems
    $f <format>            # one of the enroled formats matching with <problem>
    $h <heapsize>          # the heapsize to be allocated in byte or use suffix
                           # "K" or "k" for kilobyte
                           # "M" or "m" for megabyte
                           # "G" or "g" for gigabyte

-open > grid multigrid
open             # allocate heap and new multigrid structure
open <mgname> [$d <domain> [$p <problem>]] [$f <format>] $h <heapsize>
    <mgname>               # the name of the multigrid
    $b <BVP name>          # one of the enroled boundary value problems
    $f <format>            # one of the enroled formats matching with <problem>
    $h <heapsize>          # the heapsize to be allocated

-envinfo > all environment struct string variable
envinfo # prints the used and size of the environment heap on the shell.

-close > grid multigrid
close            # close the current (or all) open multigrid(s) and free their heaps
close [$a]
    $a                     # close all multigrids

-save > grid multigrid saveas
save             # save the current multigrid
save [<name>] [$c <comment>]
   <name>                  # name to save with (default is the mgname)
   $c <comment>            # optionally specify a comment string

-refine > grid multigrid mark
refine           # refine the multigrid according to the refinement marks set in the elements
refine [$g]                # copy non refined regions to new level

-mark > grid multigrid refine
mark             # mark one (or several) elements for refinement
mark [$h | {[<rule> [<side>]] [$a | $i <Id> | $s]} | $c]
    <rule>                 # specify a refinement rule ("red" is default)
    <side>                 # has to be specified if the corresponding rule can be
                           # applied in several orientations
    $a                     # refine all (leave) elements
    $i <Id>                # refine the element with <Id>
    $s                     # refine all elements from the current selection
    $h                     # show available rules

-extracon > connections extra grid delete
extracon         # display number of extra connections (and delete them)
                 # stringvar :extraconratio is set to (# extra/# connections)
extracon [$d]
    $d                     # delete extra connections on the current level

-check > grid multigrid algebra vector matrix
check            # check consistency of grid (and algebraic) datastrcuture
check [$c]
   $c                      # additionally to grid check algebra

-quality > grid multigrid element angle
quality          # check the min and max angles of the elements in the grid
quality $a | $s | {$i <fromID> [<toID>]} [$< <angle>] [$> <angle>]
    $a                     # check angles of all elements in the multigrid
    $s                     # check angles of the selected elements
    $i                     # check angles of elements with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the element with <fromID> is listed
    $< <angle>             # print info for all elements the minangle of which is < <angle>
    $> <angle>             # print info for all elements the maxangle of which is > <angle>

-smooth > node grid multigrid shift vertex
smooth           # hierarchical grid smoothing
smooth <nIt> [$b]
    <nIt>                  # number of iterations
    $b                     # also smooth boundary nodes

-lexorderv > vectors grid order sort
lexorderv         # reorder the vectors on each mg-level lexicographically
lexorderv <directions> [$l <level>] [$m] [$s <|>|0]
2D: <directions>           # 2 letters, one for each coordinate direction; the 
                           # order of the letters determine the order of the
                           # lexicographical ordering. The letters out of [rlud]:
                           # x-axis: r=right (ascending), l=left  (descending)
                           # y-axis: u=up    (ascending), d=down  (descending)
3D: <directions>           # 3 letters, one for each coordinate direction; the 
                           # order of the letters determine the order of the
                           # lexicographical ordering. The letters out of [rlbfud]:
                           # x-axis: r=right (ascending), l=left  (descending)
                           # y-axis: b=back  (ascending), f=front (descending)
                           # z-axis: u=up    (ascending), d=down  (descending)
    $l <level>             # order only level
    $m                     # also order the MATRIXs of each node in the same way
    $s <|>|0               # treatment of vectors with skip>0: put at begin, put at end
                           # or treat them like others (default)
    $w [s][n]              # consider vectors with skipflag set (s) or not set (n) and append
                           # the remaining ones to the lexicographically ordered list

-orderv > vector matrix order sort
orderv           # algebraically order the vectors of the current multigrid
orderv $m FFCCLL | FCFCLL [$s <skip pattern>] $d <dep-proc> $o dep-proc options> [$c <cut proc>] [$a]
    $m FFCCLL | FCFCLL     # possible modes are FFCCLL or FCFCLL
    $s <skip pattern>      # if specified put vectors with skip pattern containing
                           # <skip pattern> to the begin of the list
    $d <dep-proc>          # the ordering algorithm uses this dependency procedure...
    $o <dep-proc options>  # ...and passes these options to it
    $c <cut proc>          # user specified proc for cuts
    $a                     # order all levels of the current multigrid

-lineorderv > vector matrix order sort
lineorderv       # algebraically order the vectors of the current multigrid
lineorderv $d <dep-proc> $o dep-proc options> [$c <cut proc>] [$a] [$v 0|1|2]
    $d <dep-proc>          # the ordering algorithm uses this dependency procedure...
    $o <dep-proc options>  # ...and passes these options to it
    $c <cut proc>          # user specified proc for cuts
    $a                     # order all levels of the current multigrid
	$v 0|1|2               # verbose level (default 0, quiet mode)

-shellorderv > vector matrix order sort
shellorderv      # order vectors of the current level starting from a seed shell by shell
shellorderv f | l | s
    f                      # seed = FIRSTVECTOR
    l                      # seed = LASTVECTOR
    s                      # seed = selection

-setindex > vector index
setindex         # set vector indices of the current level in ascending order beginning with 1

-ordernodes > nodes grid order sort
ordernodes       # reorder nodes lexicographically
ordernodes ur|ul|dr|dl|ru|rd|lu|ld [$l <level>] [$L]
                          # where u=up, d=down, r=right, l=left
    $l <level>            # only order the specified level
    $L                    # also order links

                          # CAUTION: node-ids of the whole mg will change in any case

-setcurrmg > grid multigrid current
setcurrmg        # change the current multigrid
setcurrmg <mgname>
    <mgname>               # mgname of the open multigrid which will be the current one

-level > grid multigrid level
level           # change the working (current) level of the current multigrid
level <level> | + | -

-renumber > grid multigrid level
renumber        # assign consecutive id's to all objects

-mglist > grid multigrid info list
mglist          # list all open multigrids
mglist [$l]
    $l                     # list long format

-glist
glist           # print grid statistics for the current multigrid
glist 

-nlist > node grid multigrid info list
nlist           # print info for the specified nodes
nlist $s | {$i <fromID> [<toID>]} [$d] [$b] [$n] [$v] [$a]
    $s                     # list info for the selected nodes
    $i                     # list info for nodes with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the node with <fromID> is listed
    $d                     # up to version 2.3 ONLY: list also user data space
    $b                     # print additional info for boundary nodes
    $n                     # list also neighbours of each node
    $v                     # print extended info (verbose mode)
    $a                     # list all nodes

-elist > element grid multigrid info list
elist           # print info for the specified elements
elist $s | {$i <fromID> [<toID>]} [$d] [$b] [$n] [$v] [$a]
    $s                     # list info for the selected elements
    $i                     # list info for elements with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the element with <fromID> is listed
    $d                     # up to version 2.3 ONLY: list also user data space
    $b                     # print additional info for boundary elements
    $n                     # list also neighbours of each element
    $v                     # print extended info (verbose mode)
    $l                     # list only elements of current level
    $a                     # list all elements

-slist > element grid multigrid info list
slist          # list the contents of the selction buffer (elist/nlist format resp.)
slist [$d] [$b] [$n] [$v]
    $d                     # up to version 2.3 ONLY: list also user data space
    $b                     # print additional info for boundary nodes/elements
    $n                     # list also neighbours of each node/element
    $v                     # print extended info (verbose mode)

-symlist > symbol user data vector matrix
symlist        # list SYMBOL-contents
symlist $s <sym-name> [<fmt>|*] $V [<fmt>|*] $M [<fmt>|*]
    $s <sym-name> ...      # list SYMBOL with name ...
    $V ...                 # list all VECTOR-SYMBOLs ...
    $M ...                 # list all MATRIX-SYMBOLs ...
    [<fmt>|*]              # ... of format <fmt>
                           #     or of current multigrid (*)
                           #     or of all formats (default)
-vmlist > vector matrix grid multigrid info list
vmlist           # print info for the specified vectors (possibly including associated matrix entries)
vmlist $s | {$i <fromID> [<toID>]} [$m] [$d] [$a] [$l <f> <t>]
    $s                     # list info for the selected vectors
    $i                     # list info for vectors with an ID in the range <fromID> through <toID>
                           # if <fromID> is omitted only the vector with <fromID> is listed
    $m                     # list also the associated matrix entries
    $d                     # list also the user data
    $a                     # list all vectors
    $l <f> <t>             # process levels f <= l <= t

-in > node insert grid multigrid
in               # insert an inner node into a multigrid with only level 0
in <x> <y> <z>
     <x> <y> <z>            # specify as much coordinates as the space has dimensions

-bn > node insert grid multigrid
bn               # insert a boundary node into a multigrid with only level 0
bn <Id> <s> <t>
    <Id>                   # insert a boundary node on the boundary segment with <Id>
    <s> <t>                # specify as much boundary segment coordinates as the boundary has dimensions

-deln > node delete grid multigrid
deln             # delete a node from the multigrid
deln <Id> | $s
    <Id>                   # ID of the node to be deleted
    $s                     # delete ALL nodes from the selection

-move > node grid multigrid shift
move             # move a node of the multigrid to a new postion
move {<Id> | $s} {$i <x> <y> <z> | $b <SegId> <s> <t>} [$r]
    <Id>                   # Id of the node to be moved
    $i <x> <y> <z>         # specify as much coordinates as the space has dimensions
    $b <Id> <s> <t>        # specify as much boundary segment coordinates as the boundary has dimensions
    $r                     # move relative to old position (inner nodes only)


-ie > element insert grid multigrid
ie               # insert an element for specified corner nodes
ie {<Id>}+ | $s
    {<Id>}+                # specify at least three corner nodes, the coresponding (unique) element will
                           # be created

-dele > element delete grid multigrid
dele             # delete an element from the multigrid including edges not deeded anymore
dele <Id> | $s
    <Id>                   # ID of the element to be deleted
    $s                     # delete ALL elements from the selection

-find > node element grid multigrid selection
find             # find a node (element) on the current level of the current multigrid
find <x> <y> <z> {$n <tol> | $v <tol> | $e} [$s]
    <x> <y> <z>            # specify as much coordinates as the space has dimensions
    $n <tol>               # find a node maching the position with tolerance <tol>
    $v <tol>               # find a vector maching the position with tolerance <tol>
    $e                     # find an element maching the position
    $s                     # add the selected node (element) to the selection buffer
                           # (if not specified the node is just listed)

-select > node element grid multigrid selection
select           # add/remove nodes/elements from the selction buffer of the current multigrid
select $c | $n {+|-} <Id> | $e {+|-} <Id>
    $c                     # clear the selection buffer
    $n {+|-} <Id>          # add (+) or remove (-) the node with <Id> to (from) the selection buffer
    $e {+|-} <Id>          # add (+) or remove (-) the element with <Id> to (from) the selection buffer

-
###################### view management ########################################

-standardrefsys
The standardRefSys has pos x-axis extending rightward and pos y-axis extending upward.
For the monitor screen the origin is located in the lower left corner and the maximum
size you will be told by the --> screensize command

-viewrefsys
The viewRefSys in 3D is defined by the x-axis in the viewplane and the z-axis in the
direction target-observer.
The viewRefSys in 2D is defined by the x-axis.

-screensize > screen monitor window
screensize       # print the size in pixels of the screen (if there) ==> max window size

-openwindow > window picture plot graphics
openwindow       # open an ug-window on an outputdevice (this will be the current window then)
openwindow <h> <v> <dh> <dv> [$d <output device>] [$n <window name>]
    <h> <v>                # the lower left corner of the plotting region in the --> standardRefSys
    <dh> <dv>              # the width and height resp. of the plotting region of the window
    $d <output device>     # specify the name of an output device (default: screen)
    $n <window name>       # optionally you can specify the window's name

-closewindow > window picture plot graphics
closewindow      # close one (or all) ug-window(s) (including the pictures residing there, of course)
closewindow [$n <window name> | $a]
    $n <window name>       # close the window with the specified name
                           # (default: the current window)
    $a                     # close all open windows

-setcurrwindow > window picture plot graphics
setcurrwindow    # make a window the current window
setcurrwindow <window name>

-drawtext > text plot window
drawtext         # draw text into a ug window
drawtext <xpos> <ypos> <text> [$w <window name>] [$c] [$m reg[ular]|inv[erse]|ind[exed]] [$s <size>]
   <xpos>                  # x-coordinate in pixels (origin is the lower left corner)
   <ypos>                  # y-coordinate in pixels (origin is the lower left corner)
   <text>                  # text to draw
   $w <window name>        # draw text into this window (default: current window)
   $c                      # center text at <xpos> <ypos>
   $s <size>               # text size
   $m ...                  # draw text
                           #   reg: regular (default)
						   #   inv: inverse
						   #   ind: allow for indexing (sub- and superscripts)
						   #        formatting by
						   #          /N: regular
						   #          /T: subscript
						   #          /H: superscript
						   #   example: 'ex/Tsub/Hsuper/Nnormal' will result in something like
						   #                  super
						   #            'ex        normal
						   #               sub

-openpicture > window picture plot graphics
openpicture      # open a picture on a window (these will be the current window and picture then)
openpicture [$w <window name>] [$s <h> <v> <dh> <dv>] [$n <picture name>]
    $w <window name>       # open a picture on this window (default: current window)
    $s <h> <v> <dh> <dv>   # specify the location and size in the --> standardRefSys with the
                           # origin located in the lower left corner of the parent window
                           # (default: picture size = parent window size)
    $n <picture name>      # optionally you can specify the picture's name

-closepicture > window picture plot graphics
closepicture     # close one (or all) picture(s) on a window
closepicture [$a | {$w <window name> {<picture name> | $a}}]
                           # default: the current picture
    $a                     # close all pictures of the current window
    $w <window name>       # close a picture of this window
    {<picture name> | $a}  # close the picture with the specified name or all pictures of that window

-setcurrpicture > window picture plot graphics
setcurrpicture   # make a picture the current picture
setcurrpicture <picture name> [$w <window name>]
    $w <window name>       # picture resides in this window (default: current window)

-picwin > window picture plot graphics
picwin           # create a new window for the current picture
                 # (to seperate multiple pictures of one window)

-wplist > window picture plot graphics
wplist           # list all windows with their pictures

-clearpicture > window picture plot graphics
clearpicture     # clear current picture

-picframe > window picture plot graphics
picframe         # toggle framing od pictures
picframe 0|1
    0                      # frame pictures
    1                      # don't frame pictures

-setview > window picture plot graphics
setview          # specify or change the observer's view of the object of the current picture
    2D: setview [$i] [$t <x> <y>] [$x  <x> <y>]
    3D: setview [$i] [$o <x> <y> <z> $t <x> <y> <z>] [$x <x> <y> [<z>]] [$p < | =]
                           # all coordinates have to be given in physical coordinates

    $i                     # first initialize view with default settings
    $o <x> <y> <z>         # 3D objects ONLY: specify the observer's stand
    $p < | =               # 3D objects ONLY: choose central (<) or parallel (=) perspective
    $t <x> <y> [<z>]       # specify the target point in the viewplane
                           # (NB: the viewplane is then defined to be normal to the line observer-target)

    $x <x> <y> [<z>]       # define an x-axis in the viewplane (which will be to the right in the picture)

-walk > window picture plot graphics
walk             # let the observer walk relative to the --> viewRefSys in the current picture
walk <x> <y> [<z>]

-walkaround > window picture plot graphics
walkaround       # 3D ONLY: let the observer walk on a sphere around the target point in the current picture
walkaround <viewplane angle> <rotation angle>    # angles in degree
    <viewplane angle>      # this angle runs in the view plane math pos from the x-axis and defines
                           # together with the target-observer direction a plane
    <rotation angle>       # the observer will be rotated around the target point in the above plane

-zoom > window picture plot graphics
zoom             # zoom the current picture
zoom <factor>              # values < 1 magnify picture !

-drag > window picture plot graphics
drag             # drag the projection plane of the current picture relative to its x-axis
drag <dx> <dy>

-rotate > window picture plot graphics
rotate           # rotate the projection plane of the current picture around the target point
rotate <angle>
    <angle>                # <angle> runs in the view plane math pos from the x-axis

-textfac > text size window graphics
textfac          # set a zoom factor for textsizes in graphical windows
textfac <factor>

-setplotobject > window picture plot graphics
setplotobject    # specify the object which will be plotted in the current picture and associate
                 # the current multigrid with it (if not done yet)
setplotobject [<object type name>] ...
    <object type name>     # possible are: Grid, EScalar, EVector
                           # see seperate help for these.
    ...                    # the remaining options depend on which object you specified

-polist > window picture plot graphics
polist           # print the specifications of the object defined in the current picture

-plot > window picture plot graphics
plot             # plot the object of the current picture according to its specifications

-vdisplay >
vdisplay # display view of current picture

-cmfn > meta plot
cmfn     #  creates a string containing the name of a metafile name for animation by xugv.
cmfn <name> <var>
  <name> # first part of the metafile names
  <var>  # the contents of var will be appended to the name

-findrange > window picture plot graphics
findrange        # find the range of values to be plotted for the object in the current picture
                 # the result will be printed and stored into :findrange:min and :findrange:max
findrange [$z <zoom factor>] [$s] [$p]
    $z <zoom factor>       # zoom the range by this factor
    $s                     # symmetrize the range (min=max)
    $p                     # store range in plot object

-updatedoc > window picture plot graphics
updateDoc        # redraw all pictures of the current multigrid


-
################### numerical procedures #####################################

-npcreate > numproc
npcreate         # create a num proc from a num proc type
npcreate <num proc name> $c <constructor>

-npinit > numproc
npinit           # initialise current numproc
npinit <num proc name> <argument list to be passed>

-npexecute > numproc
npexecute        # execute a num proc
npexecute <num proc name> <argument list to be passed>

-npdisplay > numproc
npdisplay [<num proc name>  # display current num proc

-scnp > numproc
scnp [<num proc name>  # set current numproc

-sc > typevecdesc scalar tvd numproc
<sc double list>  := [nd <double  list>] | [ed <double  list>] | [el <double  list>] | [si <double  list>]
<sc int list>     := [nd <int     list>] | [ed <int     list>] | [el <int     list>] | [si <int     list>]
<sc numproc list> := [nd <numproc list>] | [ed <numproc list>] | [el <numproc list>] | [si <numproc list>]
<ord list>        := nd|ed|el|sd<number>{ nd|ed|el|sd<number>}*
<<item> list>     := <item>{:<item>}*
<item>            := <double>|<int>|<numproc>

-cv > numproc
cv  # clear vector
npinit <name> $x <vec sym>;
$x <vec sym>  # vector descriptor
npexecute <name>

-cm > numproc 
cm  # clear matrix
npinit <name> $A <mat sym>;
$A <mat sym>  # matrix descriptor
npexecute <name>

-eu > numproc 
eu  # compute Eucilian norm
npinit <name>  $x <vec sym>;
$x <vec sym>  # vector descriptor
npexecute <name>

-copyv > numproc
copyv  # copy vector
npinit <name>  $f <from sym> $t <to sym>;
$f <vec sym>  # vector descriptor
$t <vec sym>  # vector descriptor
npexecute <name>

-bdf > numproc
bdf  # back Euler scheme of first and second order
npinit <name> $y <sol> $A <tnlass> $S <nlsolver>
          $T <transfer> [$baselevel <bl>] $order {1|2} 
		  $predictorder {0|1} $nested {0|1}
          $tstart <time> $dtstart <step> $dtmin <min step> $dtmax <max step> 
          $dtscale <fac> $rhogood <rho> [$J <mat>];
$y <sol>            # solution vector
$A <tnlass>         # assemble numproc of type 'NP_T_ASSEMBLE'
$S <nlsolver>       # nonlinear solver numproc of type 'NP_NL_SOLVER'
$T <transfer>       # transfer numproc
$baselevel <bl>     # baselevel for nested iteration
$order {1|2}        # order of the time stepping scheme
$predictorder {0|1} # order of the predictor for the next start vector
$nested {0|1}       # flag nested nonlinear solver in every time step 
$tstart <time>      # start time
$dtstart <step>     # time step to begin with
$dtmin <min step>   # smallest time step allowed	
$dtmax <max step>   # largest time step allowed
$dtscale <fac>      # scaling factor applied after step
$rhogood <rho>      # threshold for step doubling 
npexecute <name> [$pre] [$init] [$bdf1|$bdf1n|$bdf2|$bdf2n] [$post];
$pre # preprocess
$init # initialization
$bdf1 # backward Euler of first order
$bdf1n # nested backward Euler of first order
$bdf1 # backward Euler of second order
$bdf1n # nested backward Euler of second order
$post # postprocess

-indicator > numproc
indicator  # error indicator
npinit <name> $x <vec sym> [$coarse <val>] [$refine <val>];
$x <vec sym>  # symbol for the (solution) vector
$coarse <val> # bound for coarsening
$refine <val> # bound for refinement
npexecute <name> [$p] [$r] [$i];
$p # calls StandardProject
$r # calls RefineMultigrid
$i # calls StandardInterpolateNewVectors

-ew > numproc
ew  # eigenvalue computation
npinit <name> $e <sym list> [$t <tmp sym>] [$r <rhs sym>] [$M <mat sym>] 
              [$d {no|red|full}] $m <maxit> [$O] [$N]
	          $red <sc double list> [$damp <sc double list>]
	          $L <linear solver> $A <assemble> $T <transfer>;
$L <linear solver> # linear solver num proc
$A <assemble> # assemble num proc
$T <transfer> # transfer num proc
$e <sym list> # list of symbols for the eigenvectors
$r <rhs sym> # symbol for the right hnd side vector
$t <tmp sym> # symbol for a tempory vector
$m <maxit> # maximal number of multigrid cylces  
$O # orthogonalize using right hand side
$N # set the first eigenvector = 1 for Neumann problems
$d # no, reduced or full display
$red <sc double list> # reduction factors for each component
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$a] [$r];
$r # reset solution 
$i # interpolate by the standard interpolation
$a # assemble the matrix

-jac > numproc
jac  # jacobi smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>];
       $damp <sc double list> 
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-gs > numproc
gs  # Gauss-Seidel-Smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] 
       $damp <sc double list>;
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-bcgss > numproc
bcgss  # bi-cg-stab as smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$I iter]
       $m <it> $damp <sc double list> [$I <iteration>] [$R <restart>];
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$m <it> # number of iterations
$damp <sc double list> # damping factors for each component
       $m <maxit>  [$w <sc double list>];
$I <iteration> # iteration numproc
$R <restart> # restart index
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-sgs > numproc
sgs  # symmetric Gauss-Seidel smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] 
       $damp <sc double list>;
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-sor > numproc
sor  # SOR smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] 
       $damp <sc double list>;
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-sbgs > numproc
sbgs  # block Gauss-Seidel smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] 
               $damp <sc double list> 
               $Blocking <sc int list> $BlockOrder <ord list> 
               $BlockIter <sc numproc list>; 
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$Blocking <sc int list> # describes the block structure (in ascending order starting always with 0)
$BlockOrder <ord list> # describes the order of the blocks
$BlockIter <numproc list> # smoother per block
<sc double list>  # [nd <double list>] | [ed <double list>] | [el <double list>] | [si <double list>]
<sc int list>     # [nd <int list>] | [ed <int list>] | [el <int list>] | [si <int list>]
. <sc numproc list>  # [nd <numproc list>] | [ed <numproc list>] | [el <numproc list>] | [si <numproc list>]
. <ord list>         # nd|ed|el|sd<number>{ nd|ed|el|sd<number>}+
<double list>  # <double> {: <double>}*
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-gbgs > numproc
gbgs  # Grid block Gauss-Seidel smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>]
              [$damp <sc double list>] [$L <mat>]
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$L <mat> # decomposition matrix
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-ilu > numproc
ilu  # ILU smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$L <mat>] 
       [$damp <sc double list>] [$beta <sc double list>]
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$L <mat> # decomposition matrix
$damp <sc double list> # damping factors for each component
$beta <sc double list> # parameter for modification of the diagonal
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-filu > numproc
filu  # ILU smoother on fine grid nodes only
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$L <mat>] 
       $damp <sc double list> $beta <sc double list>
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$L <mat> # decomposition matrix
$damp <sc double list> # damping factors for each component
$beta <sc double list> # parameter for modification of the diagonal
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-thilu > numproc
thilu  # ILU smoother with threshold
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$L <mat>] 
       [$damp <sc double list>] [$beta <sc double list>] 
	   [$thresh <sc double list>];
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$L <mat> # decomposition matrix
$damp <sc double list> # damping factors for each component
$beta <sc double list> # parameter for modification of the diagonal
$thresh <sc double list> # parameter for the threshold
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-spilu > numproc
spilu  # spectral shifted ILU smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$L <mat>] 
       [$damp <sc double list>] [$beta <sc double list>]
	   $mode {local|global};
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$L <mat> # decomposition matrix
$damp <sc double list> # damping factors for each component
$beta <sc double list> # parameter for modification of the diagonal
$mode {local|global} # global or local shift
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-ic > numproc
ic  # incomlete Cholesky smoother
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$L <mat>] 
       [$damp <sc double list>];
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$L <mat> # decomposition matrix
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-ff > numproc
ff  # frequency filter
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$damp <sc double list>]
       [$FF <FF-mat sym>] [$FF3D <3D FF-mat sym>] [$L <LU mat sym>] 
       [$aux <temp sym>] [$tv <testvector sym>] [$tv2 <2. testvector sym>] 
	   [$aux3D <3D temp sym>] [$aux2_3D <2. 3D temp sym>] [
       $t <update for correction sym>]
	   $display {no|red|full} $wr <"all"|number> $wr3D <number> $type <FF|TFF>
	   [$aux2 <temp2 sym>] [$aux3 <temp3 sym>] [$aux4 <temp4 sym>]
	   [$aux5 <temp5 sym>] [$aux6 <temp6 sym>];
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$damp <sc double list> # damping factors for each component
$FF <FF-mat sym> # symbol for the frequency filtered matrix
$FF3D <3D FF-mat sym> # symbol for an additional frequency filtered matrix for 3D
$L <LU-mat sym> # symbol for the LU decomposed matrix
$tv <testvector sym> # symbol for the testvector
$tv2 <2. testvector sym> # symbol for the second testvector if neccessary
$aux <temp sym> # symbol for a temporary vector
$aux3D <3D temp sym> # additional temporary symbol for the testvector for 3D
$aux2_3D <2. 3D temp sym> # additional temporary symbol for the 2. testvector for 3D and FF
$t <update for correction sym> # temp. vector
$type <type of frequency filter> # "TFF" for Wagners or "FF" for Wittums
$aux2 <temp2 sym> # symbol for a further temporary vector (neccessary for FF)
$aux3 <temp3 sym> # symbol for a further temporary vector
$aux4 <temp4 sym> # symbol for a further temporary vector
$aux5 <temp5 sym> # symbol for a further temporary vector
$aux6 <temp6 sym> # symbol for a further temporary vector
$display # display mode: 'no', 'red'uced or 'full'
$wr # relative frequency [0..1] for 2D OR 'all' for the whole logarithmic sequence of frequencies
$wr3D # relative frequency [0..1] for 3D 
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-lu > numproc
lu  # LU decomposition
npinit <name> [$c <cor>] [$b <rhs>] [$A <mat>] [$L <mat>] 
       [$damp <sc double list>];
$c <cor> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$L <mat> # decomposition matrix
$damp <sc double list> # damping factors for each component
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-lmgc > numproc
lmgc  # linear multigrid cycle
npinit <name> [$c <cor>] [$r <rhs>] [$A <mat>] 
       $S <pre post base> $T <transfer>
       [$b <baselevel>] [$g <gamma>] [$n1 <it>] [$n2 <it>]
$c <cor> # correction vector
$r <rhs> # right hand side vector
$A <mat> # stiffness matrix
$T <transfer> # transfer numproc
$S <pre post base> # numprocs for pre- and postsmoother, base solver 
$b <baselevel> # baselevel where the base solver is called 
$g <gamma> # number of iterations of Lmgc per level (default gamma = 1)
$n1 <it> # number of iterations of the presmoother (default n1 = 1)
$n2 <it> # number of iteration of the postsmoother (default n2 = 1)

npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # smooth
$p # postprocess

-ls > numproc
ls  # linear solver
npinit <name> [$x <sol>] [$b <rhs>] [$A <mat sym>] 
       [$red <sc double list>] [$abslimit <sc double list>]
       $m <maxit> $I <iteration> [$d {full|red|no}];
$x <sol> # solution vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$red <sc double list> # reduction factor
$abslimit <sc double list> # absolute limit for the defect (default 1E-10) 
$m <maxit> # maximal number of iterations
$I <iteration> # iteration numproc
$d {full|red|no} # display modus
npexecute <name> [$i] [$d] [$r] [$s] [$p];
$i # preprocess
$d # replace right hand side by the defect
$r # compute the residuum of the defect
$s # solve
$p # postprocess

-cg > numproc
cg  # conjugate gradient
npinit <name> [$x <sol>] [$b <rhs>] [$A <mat sym>] 
       [$red <sc double list>] [$abslimit <sc double list>]
       $m <maxit> $I <iteration> [$d {full|red|no}] 
       [$p <con>] [$t <tmp>];
$x <sol> # solution vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$red <sc double list> # reduction factor
$abslimit <sc double list> # absolute limit for the defect (default 1E-10) 
$m <maxit> # maximal number of iterations
$I <iteration> # iteration numproc
$d {full|red|no} # display modus
$p <con> # conjugate vector
$t <tmp> # temporaty vector
npexecute <name> [$i] [$d] [$r] [$s] [$p];
$i # preprocess
$d # replace right hand side by the defect
$r # compute the residuum of the defect
$s # solve
$p # postprocess

-cr > numproc
cr  # conjugate residual
npinit <name> [$x <sol>] [$b <rhs>] [$A <mat sym>] 
       [$red <sc double list>] [$abslimit <sc double list>]
       $m <maxit> $I <iteration> [$d {full|red|no}] 
       [$p <con>] [$t <tmp>]
	   [$r <restart>] [$w <sc double list>];
$x <sol> # solution vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$red <sc double list> # reduction factor
$abslimit <sc double list> # absolute limit for the defect (default 1E-10) 
$m <maxit> # maximal number of iterations
$I <iteration> # iteration numproc
$d {full|red|no} # display modus
$p <con> # conjugate vector
$t <tmp> # temporaty vector
$r <restart> # restart index
$w <sc double list> # weighting factor
npexecute <name> [$i] [$d] [$r] [$s] [$p];
$i # preprocess
$d # replace right hand side by the defect
$r # compute the residuum of the defect
$s # solve
$p # postprocess

-bgc > numproc
bcg  # bi-cg method
npinit <name> [$x <sol>] [$b <rhs>] [$A <mat sym>] 
       [$red <sc double list>] [$abslimit <sc double list>]
       $m <maxit> $I <iteration> [$d {full|red|no}] 
       [$p <con>] [$pb <p-bar>] [$rb <r-bar>] [$h <tmp>]
	   [$r <restart>];
$x <sol> # solution vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$red <sc double list> # reduction factor
$abslimit <sc double list> # absolute limit for the defect (default 1E-10) 
$m <maxit> # maximal number of iterations
$I <iteration> # iteration numproc
$d {full|red|no} # display modus
$p <con> # conjugate vector
$pb <p-bar> # temporaty vector
$rb <r-bar> # temporaty vector
$h <tmp> # temporaty vector
$r <restart> # restart index
npexecute <name> [$i] [$d] [$r] [$s] [$p];
$i # preprocess
$d # replace right hand side by the defect
$r # compute the residuum of the defect
$s # solve
$p # postprocess

-bcgs > numproc
bcgs  # bi-cg-stab
npinit <name> [$x <sol>] [$b <rhs>] [$A <mat sym>] 
       [$red <sc double list>] [$abslimit <sc double list>]
       $m <maxit> $I <iteration> [$d {full|red|no}] 
       [$p <con>] [$t <tmp>]
	   [$R <restart>] [$w <sc double list>];
$x <sol> # solution vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$red <sc double list> # reduction factor
$abslimit <sc double list> # absolute limit for the defect (default 1E-10) 
$m <maxit> # maximal number of iterations
$I <iteration> # iteration numproc
$d {full|red|no} # display modus
$p <con> # conjugate vector
$t <tmp> # temporaty vector
$R <restart> # restart index
$w <sc double list> # weighting factor
npexecute <name> [$i] [$d] [$r] [$s] [$p];
$i # preprocess
$d # replace right hand side by the defect
$r # compute the residuum of the defect
$s # solve
$p # postprocess

-sqcg > numproc
sqcg  # square cg method
npinit <name> [$x <sol>] [$b <rhs>] [$A <mat sym>] 
       [$red <sc double list>] [$abslimit <sc double list>]
       $m <maxit> $I <iteration> [$d {full|red|no}] 
       [$p <con>] [$h <tmp>]
	   [$R <restart>];
$x <sol> # solution vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$red <sc double list> # reduction factor
$abslimit <sc double list> # absolute limit for the defect (default 1E-10) 
$m <maxit> # maximal number of iterations
$I <iteration> # iteration numproc
$d {full|red|no} # display modus
$p <con> # conjugate vector
$h <tmp> # temporaty vector
$R <restart> # restart index
npexecute <name> [$i] [$d] [$r] [$s] [$p];
$i # preprocess
$d # replace right hand side by the defect
$r # compute the residuum of the defect
$s # solve
$p # postprocess

-ldcg > numproc
ldcs # numproc for defect correction linear solvers
npinit <name> [$x <sol>] [$b <rhs>] [$A <mat sym>] 
       [$red <sc double list>] [$abslimit <sc double list>]
       $m <maxit> $LS <linear solver [$d {full|red|no}] 
       $DC <mat sym>;
$x <sol> # solution vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$red <sc double list> # reduction factor
$abslimit <sc double list> # absolute limit for the defect (default 1E-10) 
$m <maxit> # maximal number of iterations
$LS <linear solver> # linear solver numproc
$d {full|red|no} # display modus
$DC <mat sym> # defect correction matrix
npexecute <name> [$i] [$d] [$r] [$s] [$p];
$i # preprocess
$d # replace right hand side by the defect
$r # compute the residuum of the defect
$s # solve
$p # postprocess

-newton > numproc
newton  # newton method
npinit <name> $x <sol> 
              $A <assemble> $T <transfer> $S <solver>
              $abslimit <sc double list> $red <sc double list> 
              $rhoreass <double> $lsteps <l> $maxit <m> $line {0|1} 
			  $linrate {0|1|2} [$lambda {double}] 
			  $linminred <sc double list> [$display {no|red|full}] [$J <mat>];
$x <sol>           # solution vector
$A <assemble>      # assemble numproc of type 'NP_NL_ASSEMBLE'
$S <linear solver> # linear solver numproc of type 'NP_LINEAR_SOLVER'
$T <transfer>      # transfer numproc
$abslimit <sc double list>  # absolute limit for the defect (default 1.0E-10) 
$red <sc double list> # reduction factor 
$rhoreass <double>    # reassemble if nonlinear convergence rate worse than this 
$lsteps <l>           # maximum number of line search steps		
$maxit <m>            # maximum number of nonlinear iterations 
$line {0|1}           # do line search 
$linrate {0|1|2}      # 0: quadratic nonlin rate assumed, 1: nonquadratic nonlin rate assumed, 2: accept the corretion always
$lambda {double}      # nonlinear damp factor 
$linminred <sc double list> # minimum reduction for linear solver
$display {no|red|full}] # display mode
$J <mat>                # Jacobi matrix (optional)  
npexecute <name> [$i] [$s] [$p];
$i # preprocess
$s # solve
$p # postprocess

-transfer > numproc
transfer # transfer numproc
npinit <name> [$x <sol>] [$c <cor>] [$b <rhs>] [$A <mat>] 
              [$M] [$L] [$m] [$d {full|red|no}] [$S <cut>] 
$x <sol> # solution vector
$c <sol> # correction vector
$b <rhs> # right hand side vector
$A <mat> # stiffness matrix
$M # use iterpolation matrix for transfer (default: standard transfer)
$m # parallel nonconforming interpolation
$L # level optimization 
$d # display modus
$S <cut> # scaled restriction with cut 
npexecute <name> [$i] [$R] [$I] [$N] [$P] [$p];
$i # preprocess
$R # restrict defect
$I # interpolate correction
$N # interpolate new vectors
$P # project solution
$p # postprocess

-
####################### miscellaneous #########################################

-defaults
in the file 'defaults' in the application directory the user can specify the following
values (format: the name at the beginning of the line in arbitrary order, then following the value string;
the example values are taken from the nsa defaults file, omit the comments of course):

envmemory 		128000                                               # environment memory in bytes

helpfiles 		../../ug/doc/ug.help ../../ug/doc/ug2d.help ../pclib/ns.help  # help files to search for help

guimemory 		32000                                                # MAC only: for window management
scrollback 		500                                                  # MAC only: line buffer for shell
charsperline 	256                                                  # MAC only: max number of chars per line
font 			Monaco                                               # MAC only: font name
size 			9                                                    # MAC only: font size
TermWinH 		400                                                  # MAC only: horizontal position of shell window
TermWinV 		0                                                    # MAC only: vertical position of shell window
TermWinDH 		1000                                                 # MAC only: width of shell window
TermWinDV 		1000                                                 # MAC only: height of shell window

scriptpathes	./paramruns/ ./ ./plotscripts/                       # search scripts in these pathes
gridpathes		./grids/                                             # search grids in these pathes
protocoldir		../../../ug31results/ns/paramruns/results/           # write protocols into this dir
logfilesdir		../../../ug31results/ns/paramruns/results/           # write logfiles into this dir
metafilesdir	../../../ug31results/ns/paramruns/results/           # write metafiles into this dir
arraypaths      ./paramruns

-clear > vector matrix userdata
clear            # clear or assign a constant value to a user defined symbol
clear <symbol name> [$a] [$s] [$v <value>]
    $a                     # from level 0 through current level (default: current level only)
    $s                     # consider the skip fields
    $v <value>             # assign this value (instead of 0.0)

-copy > solution symbol
copy            # copy symbol to symbol on current level
copy $f <from-symbol> $t <to-symbol>

-interpolate > solution symbol
interpolate     # interpolate to current level from level below
interpolate <symbol>

-reinit > problem multigrid
reinit           # reinitialize a problem
reinit [$d <domain> $p <problem>]
    $d <domain>            # domain to initialize (default is the domain of the current mg)
    $p <problem>           # problem to initialize (default is the problem of the current mg)

-setkey > command delkey
setkey           # create a command key and assign executable statements to it
setkey $<command char> $" <command sequence>"
    $k <command char>      # specifiy a single character which will be the command key
    $" <command sequence>" # give an arbitrary sequence of statements which is to be
                           # executed when the command key is pressed
                           # NOTICE: when executed string varibales preceeded by a ?
                           # will be expanded with the CURRENT contents of this variable
                           # If they are preceeded by a @ as usual, the string vars will be
                           # evaluated instantaneously when the cmd key is created

-delkey > command setkey
delkey           # remove a command key allocated before
delkey $all | $<command char>
    $all                   # delete all command keys allocated before
    $<command char>        # delete only the command key associated with <command char>

-keylist > command setkey list
keylist          # list all command keys defined together with their contents

-refreshon > view multigrid refreshoff
refreshon        # pictures on the screen device will be updated instantaneously

-refreshoff > view multigrid refreshon
refreshoff       # pictures on the screen device will be updated ONLY explicitely

-newformat > format multigrid user data symbols
newformat        # create a user data format
newformat <format_name> [$V <vec_size>: {<vec_sym_name>}+ [$comp <comp_names> {$sub <sub_sym_name> <comps>}*]]
                        [$M <mat_size>: {<mat_sym_name>}+ [$comp <comp_names> {$sub <sub_sym_name> <matsizes+comps>}*]
                        [$d <mtype> <depth>]
  
  $V            # enrol storage for vector data: the specified size per type is multiplied
                # by the number of <vec_sym_name> specified. SYMBOLs are allocated with the
                # specified names, also scalar SYMBOLs are allocated
                
     <vec_size> := {<tp><size> }+, where <tp> is a char of
                                           n for NODE
                                           k for EDGE
                                           e for ELEM
                                           s for SIDE (3D only)
                   and <size> is a integer
 
 
  $comp         # optionally specify names for the components
     <comp_names> := one char per component of the symbol (without spaces)
  
  
  $sub          # if comp names have been specified optionally specify sub symbols for
                # each of the previously allocated symbols by sppecifying their comps
  
     <comps> := list of comps as specified in <comp_names>
  
  
  $M            # enrol storage for matrix data: the specified size per type is multiplied
                # by the number of <mat_sym_name> specified. SYMBOLs are allocated with the
                # specified names, also scalar SYMBOLs are allocated
                
     <mat_size> := {<rtp><rsize>x<ctp><csize> }+, where r and c refer to rows and columns of the matrix
 
 
  $comp         # optionally specify names for the components
     <comp_names> := TWO chars per component of the symbol (without spaces)
     
     
     <matsizes+comps> := {<rsize>x<csize> <comp_names>}+
  
  
  $d <mtype> <depth>  # set connection depth (default 0)
     
     <mtype> := <rtp>x<ctp>

-setpf > symbols format vmlist
setpf            # set printing format in context with vmlist command
setpf <format_name> [$V{0 | {+|-} {<vecsym_name>}+}]+ [$M{0 | {+|-} {<matsym_name>}+}]+

-showpf > symbols format vmlist
showpf           # show current printing format settings

-
##################  PlotObjectTypes  #########################################

-matrix > setplotobject setview plot matrix blockmatrix blockvector block
Matrix         # name of PlotObjType for plot Matrix where entries are indicated by colors
Matrix [$e <matrix eval proc> | $M <scalar matrix symbol>] [$f <fromValue>] [$t <toValue>] [$l 0|1]
    $f <fromValue> $t <toValue>     # range [fromValue,toValue]
    $e <matrix eval proc>           # plot entries of a symbol
    $M <scalar matrix symbol>       # plot entries of a evalproc
    $C 0|1                          # plot regular connections
    $E 0|1                          # plot extra connections
    $l 0|1                          # choose logarithmic coloring (ln |A_ij|)
    $T <threshold>                  # supress entries with |A_ij| < threshold
    $BV 0|1 [<dash> <space>]        # disabel|enabel plotting of blockmatrixstructure
                                    # optional you can enabel dotted lines up to
                                    #     the border of the matrix
                                    #     <dash> gives the length of one small linesegment,
                                    #     <space> the space between such segments

-array > crar wrar rear saar loar clar
array: family of commands to handle arrays of double. The commands are:
  crar $n <name> {$n_i}+ # create array of specified size
  dear $n <name>         # delete array
  wrar $n <name> {$n_i}+ $v <value> # write array[n_1][n_2]...[n_k] := <value>
  rear $n <name> {$n_i}+ # read array[n_1][n_2]...[n_k] to ':ARRAY_VALUE'
  clar $n <name>         # clear array, all entries := 0.0
  saar $n <name>         # save array to file '<name>.array'
  loar $n <name>         # load array from file '<name>.array'

-crar > array create dear saar loar wrar rear clar
crar             # create a new array structure
crar $n <name> {$<n_i>}+

  $n <name> # name of the array structure
  {$<n_i>}+ # list of extension in the i.th dimension
            # 1 <= i <= 'AR_NVAR_MAX'

-dear > array delete free dispose crar saar loar wrar rear clar
dear             # delete an array structure
dear $n <name>
  $n <name> # name of the array structure

-saar > array save store file defaults crar dear loar wrar rear clar
saar             # save array to file <name>.array
                 # path in the defaults file under 'arraypaths'
saar $n <name>
  $n <name> # name of the array structure

-loar > array load restore file defaults crar dear saar wrar rear clar
loar             # load array from file <name>.array
                 # path in the defaults file under 'arraypaths'
loar $n <name>
  $n <name> # name of the array structure

-wrar > array write store crar dear saar loar rear clar
wrar             # write value to a single array entry
wrar $n <name> {$<n_i>}+ $v <value>

  $n <name> # name of the array structure
  {$<n_i>}+ # list of the coordinates of the array entry;
            # dimension of the array as created;
            # index 0 <= n_i < allocated extension
  <value>   # double value to be stored

-rear > array read restore crar dear saar loar wrar clar
rear             # read value of a single array entry and
                 # store it in the environment variable :ARRAY_VALUE
rear $n <name> {$<n_i>}+

  $n <name> # name of the array structure
  {$<n_i>}+ # list of the coordinates of the array entry;
            # dimension of the array as created;
            # index 0 <= n_i < allocated extension

-clar > array clear reset init crar dear saar loar wrar rear
clar             # clear array; set all entries to 0.0
clar $n <name>
  $n <name> # name of the array structure

-ptest > parallel
ptest {$0|$1} # grid distribution (will replace later)
$0            # transfer complete grid
$1            # do load balancing

-pstat > parallel
pstat {$c|$i|$l|$s|$b|$m}  # parallel status information
$c                         # call ddd consistency check  
$i                         # display ddd interfaces
$s                         # show ddd status
$l                         # show list of local objects
$b                         # enter interactive debugger
$m                         # show ddd and dddif memory statistics

-context > parallel
context {$a|$e|<n>}  # set context for plotting and printing
$a                   # all processors
$e                   # empty
<n>                  # toggle processor n
  
-showconfig > show config configuration ugconf debug
showconfig           #  show the main configuration settings of this ug-program



